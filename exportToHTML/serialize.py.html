<html>
<head>
<title>serialize.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.ln { color: #606366; font-weight: normal; font-style: normal; }
.s0 { color: rgb(204,120,50); }
.s1 { color: rgb(169,183,198); }
.s2 { color: rgb(106,135,89); }
.s3 { color: rgb(128,128,128); }
.s4 { color: rgb(165,194,97); }
.s5 { color: rgb(104,151,187); }
.s6 { color: rgb(98,151,85); font-style: italic; }
</style>
</head>
<BODY BGCOLOR="#2b2b2b">
<TABLE CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<TR><TD><CENTER>
<FONT FACE="Arial, Helvetica" COLOR="#000000">
serialize.py</FONT>
</center></TD></TR></TABLE>
<pre>
<span class="s0">import </span><span class="s1">base64 
</span><span class="s0">import </span><span class="s1">io 
</span><span class="s0">import </span><span class="s1">json 
</span><span class="s0">import </span><span class="s1">zlib 
 
</span><span class="s0">from </span><span class="s1">pip._vendor.requests.structures </span><span class="s0">import </span><span class="s1">CaseInsensitiveDict 
 
</span><span class="s0">from </span><span class="s1">.compat </span><span class="s0">import </span><span class="s1">HTTPResponse</span><span class="s0">, </span><span class="s1">pickle</span><span class="s0">, </span><span class="s1">text_type 
 
 
</span><span class="s0">def </span><span class="s1">_b64_encode_bytes(b): 
    </span><span class="s0">return </span><span class="s1">base64.b64encode(b).decode(</span><span class="s2">&quot;ascii&quot;</span><span class="s1">) 
 
 
</span><span class="s0">def </span><span class="s1">_b64_encode_str(s): 
    </span><span class="s0">return </span><span class="s1">_b64_encode_bytes(s.encode(</span><span class="s2">&quot;utf8&quot;</span><span class="s1">)) 
 
 
</span><span class="s0">def </span><span class="s1">_b64_encode(s): 
    </span><span class="s0">if </span><span class="s1">isinstance(s</span><span class="s0">, </span><span class="s1">text_type): 
        </span><span class="s0">return </span><span class="s1">_b64_encode_str(s) 
    </span><span class="s0">return </span><span class="s1">_b64_encode_bytes(s) 
 
 
</span><span class="s0">def </span><span class="s1">_b64_decode_bytes(b): 
    </span><span class="s0">return </span><span class="s1">base64.b64decode(b.encode(</span><span class="s2">&quot;ascii&quot;</span><span class="s1">)) 
 
 
</span><span class="s0">def </span><span class="s1">_b64_decode_str(s): 
    </span><span class="s0">return </span><span class="s1">_b64_decode_bytes(s).decode(</span><span class="s2">&quot;utf8&quot;</span><span class="s1">) 
 
 
</span><span class="s0">class </span><span class="s1">Serializer(object): 
 
    </span><span class="s0">def </span><span class="s1">dumps(self</span><span class="s0">, </span><span class="s1">request</span><span class="s0">, </span><span class="s1">response</span><span class="s0">, </span><span class="s1">body=</span><span class="s0">None</span><span class="s1">): 
        response_headers = CaseInsensitiveDict(response.headers) 
 
        </span><span class="s0">if </span><span class="s1">body </span><span class="s0">is None</span><span class="s1">: 
            body = response.read(decode_content=</span><span class="s0">False</span><span class="s1">) 
 
            </span><span class="s3"># NOTE: 99% sure this is dead code. I'm only leaving it</span><span class="s1"> 
            </span><span class="s3">#       here b/c I don't have a test yet to prove</span><span class="s1"> 
            </span><span class="s3">#       it. Basically, before using</span><span class="s1"> 
            </span><span class="s3">#       `cachecontrol.filewrapper.CallbackFileWrapper`,</span><span class="s1"> 
            </span><span class="s3">#       this made an effort to reset the file handle. The</span><span class="s1"> 
            </span><span class="s3">#       `CallbackFileWrapper` short circuits this code by</span><span class="s1"> 
            </span><span class="s3">#       setting the body as the content is consumed, the</span><span class="s1"> 
            </span><span class="s3">#       result being a `body` argument is *always* passed</span><span class="s1"> 
            </span><span class="s3">#       into cache_response, and in turn,</span><span class="s1"> 
            </span><span class="s3">#       `Serializer.dump`.</span><span class="s1"> 
            response._fp = io.BytesIO(body) 
 
        data = { 
            </span><span class="s2">&quot;response&quot;</span><span class="s1">: { 
                </span><span class="s2">&quot;body&quot;</span><span class="s1">: _b64_encode_bytes(body)</span><span class="s0">,</span><span class="s1"> 
                </span><span class="s2">&quot;headers&quot;</span><span class="s1">: dict( 
                    (_b64_encode(k)</span><span class="s0">, </span><span class="s1">_b64_encode(v)) 
                    </span><span class="s0">for </span><span class="s1">k</span><span class="s0">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">response.headers.items() 
                )</span><span class="s0">,</span><span class="s1"> 
                </span><span class="s2">&quot;status&quot;</span><span class="s1">: response.status</span><span class="s0">,</span><span class="s1"> 
                </span><span class="s2">&quot;version&quot;</span><span class="s1">: response.version</span><span class="s0">,</span><span class="s1"> 
                </span><span class="s2">&quot;reason&quot;</span><span class="s1">: _b64_encode_str(response.reason)</span><span class="s0">,</span><span class="s1"> 
                </span><span class="s2">&quot;strict&quot;</span><span class="s1">: response.strict</span><span class="s0">,</span><span class="s1"> 
                </span><span class="s2">&quot;decode_content&quot;</span><span class="s1">: response.decode_content</span><span class="s0">,</span><span class="s1"> 
            }</span><span class="s0">,</span><span class="s1"> 
        } 
 
        </span><span class="s3"># Construct our vary headers</span><span class="s1"> 
        data[</span><span class="s2">&quot;vary&quot;</span><span class="s1">] = {} 
        </span><span class="s0">if </span><span class="s2">&quot;vary&quot; </span><span class="s0">in </span><span class="s1">response_headers: 
            varied_headers = response_headers[</span><span class="s2">'vary'</span><span class="s1">].split(</span><span class="s2">','</span><span class="s1">) 
            </span><span class="s0">for </span><span class="s1">header </span><span class="s0">in </span><span class="s1">varied_headers: 
                header = header.strip() 
                data[</span><span class="s2">&quot;vary&quot;</span><span class="s1">][header] = request.headers.get(header</span><span class="s0">, None</span><span class="s1">) 
 
        </span><span class="s3"># Encode our Vary headers to ensure they can be serialized as JSON</span><span class="s1"> 
        data[</span><span class="s2">&quot;vary&quot;</span><span class="s1">] = dict( 
            (_b64_encode(k)</span><span class="s0">, </span><span class="s1">_b64_encode(v) </span><span class="s0">if </span><span class="s1">v </span><span class="s0">is not None else </span><span class="s1">v) 
            </span><span class="s0">for </span><span class="s1">k</span><span class="s0">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">data[</span><span class="s2">&quot;vary&quot;</span><span class="s1">].items() 
        ) 
 
        </span><span class="s0">return </span><span class="s4">b&quot;,&quot;</span><span class="s1">.join([ 
            </span><span class="s4">b&quot;cc=2&quot;</span><span class="s0">,</span><span class="s1"> 
            zlib.compress( 
                json.dumps( 
                    data</span><span class="s0">, </span><span class="s1">separators=(</span><span class="s2">&quot;,&quot;</span><span class="s0">, </span><span class="s2">&quot;:&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">sort_keys=</span><span class="s0">True,</span><span class="s1"> 
                ).encode(</span><span class="s2">&quot;utf8&quot;</span><span class="s1">)</span><span class="s0">,</span><span class="s1"> 
            )</span><span class="s0">,</span><span class="s1"> 
        ]) 
 
    </span><span class="s0">def </span><span class="s1">loads(self</span><span class="s0">, </span><span class="s1">request</span><span class="s0">, </span><span class="s1">data): 
        </span><span class="s3"># Short circuit if we've been given an empty set of data</span><span class="s1"> 
        </span><span class="s0">if not </span><span class="s1">data: 
            </span><span class="s0">return</span><span class="s1"> 
 
        </span><span class="s3"># Determine what version of the serializer the data was serialized</span><span class="s1"> 
        </span><span class="s3"># with</span><span class="s1"> 
        </span><span class="s0">try</span><span class="s1">: 
            ver</span><span class="s0">, </span><span class="s1">data = data.split(</span><span class="s4">b&quot;,&quot;</span><span class="s0">, </span><span class="s5">1</span><span class="s1">) 
        </span><span class="s0">except </span><span class="s1">ValueError: 
            ver = </span><span class="s4">b&quot;cc=0&quot;</span><span class="s1"> 
 
        </span><span class="s3"># Make sure that our &quot;ver&quot; is actually a version and isn't a false</span><span class="s1"> 
        </span><span class="s3"># positive from a , being in the data stream.</span><span class="s1"> 
        </span><span class="s0">if </span><span class="s1">ver[:</span><span class="s5">3</span><span class="s1">] != </span><span class="s4">b&quot;cc=&quot;</span><span class="s1">: 
            data = ver + data 
            ver = </span><span class="s4">b&quot;cc=0&quot;</span><span class="s1"> 
 
        </span><span class="s3"># Get the version number out of the cc=N</span><span class="s1"> 
        ver = ver.split(</span><span class="s4">b&quot;=&quot;</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)[-</span><span class="s5">1</span><span class="s1">].decode(</span><span class="s2">&quot;ascii&quot;</span><span class="s1">) 
 
        </span><span class="s3"># Dispatch to the actual load method for the given version</span><span class="s1"> 
        </span><span class="s0">try</span><span class="s1">: 
            </span><span class="s0">return </span><span class="s1">getattr(self</span><span class="s0">, </span><span class="s2">&quot;_loads_v{0}&quot;</span><span class="s1">.format(ver))(request</span><span class="s0">, </span><span class="s1">data) 
        </span><span class="s0">except </span><span class="s1">AttributeError: 
            </span><span class="s3"># This is a version we don't have a loads function for, so we'll</span><span class="s1"> 
            </span><span class="s3"># just treat it as a miss and return None</span><span class="s1"> 
            </span><span class="s0">return</span><span class="s1"> 
 
    </span><span class="s0">def </span><span class="s1">prepare_response(self</span><span class="s0">, </span><span class="s1">request</span><span class="s0">, </span><span class="s1">cached): 
        </span><span class="s6">&quot;&quot;&quot;Verify our vary headers match and construct a real urllib3 
        HTTPResponse object. 
        &quot;&quot;&quot;</span><span class="s1"> 
        </span><span class="s3"># Special case the '*' Vary value as it means we cannot actually</span><span class="s1"> 
        </span><span class="s3"># determine if the cached response is suitable for this request.</span><span class="s1"> 
        </span><span class="s0">if </span><span class="s2">&quot;*&quot; </span><span class="s0">in </span><span class="s1">cached.get(</span><span class="s2">&quot;vary&quot;</span><span class="s0">, </span><span class="s1">{}): 
            </span><span class="s0">return</span><span class="s1"> 
 
        </span><span class="s3"># Ensure that the Vary headers for the cached response match our</span><span class="s1"> 
        </span><span class="s3"># request</span><span class="s1"> 
        </span><span class="s0">for </span><span class="s1">header</span><span class="s0">, </span><span class="s1">value </span><span class="s0">in </span><span class="s1">cached.get(</span><span class="s2">&quot;vary&quot;</span><span class="s0">, </span><span class="s1">{}).items(): 
            </span><span class="s0">if </span><span class="s1">request.headers.get(header</span><span class="s0">, None</span><span class="s1">) != value: 
                </span><span class="s0">return</span><span class="s1"> 
 
        body_raw = cached[</span><span class="s2">&quot;response&quot;</span><span class="s1">].pop(</span><span class="s2">&quot;body&quot;</span><span class="s1">) 
 
        headers = CaseInsensitiveDict(data=cached[</span><span class="s2">'response'</span><span class="s1">][</span><span class="s2">'headers'</span><span class="s1">]) 
        </span><span class="s0">if </span><span class="s1">headers.get(</span><span class="s2">'transfer-encoding'</span><span class="s0">, </span><span class="s2">''</span><span class="s1">) == </span><span class="s2">'chunked'</span><span class="s1">: 
            headers.pop(</span><span class="s2">'transfer-encoding'</span><span class="s1">) 
 
        cached[</span><span class="s2">'response'</span><span class="s1">][</span><span class="s2">'headers'</span><span class="s1">] = headers 
 
        </span><span class="s0">try</span><span class="s1">: 
            body = io.BytesIO(body_raw) 
        </span><span class="s0">except </span><span class="s1">TypeError: 
            </span><span class="s3"># This can happen if cachecontrol serialized to v1 format (pickle)</span><span class="s1"> 
            </span><span class="s3"># using Python 2. A Python 2 str(byte string) will be unpickled as</span><span class="s1"> 
            </span><span class="s3"># a Python 3 str (unicode string), which will cause the above to</span><span class="s1"> 
            </span><span class="s3"># fail with:</span><span class="s1"> 
            </span><span class="s3">#</span><span class="s1"> 
            </span><span class="s3">#     TypeError: 'str' does not support the buffer interface</span><span class="s1"> 
            body = io.BytesIO(body_raw.encode(</span><span class="s2">'utf8'</span><span class="s1">)) 
 
        </span><span class="s0">return </span><span class="s1">HTTPResponse( 
            body=body</span><span class="s0">,</span><span class="s1"> 
            preload_content=</span><span class="s0">False,</span><span class="s1"> 
            **cached[</span><span class="s2">&quot;response&quot;</span><span class="s1">] 
        ) 
 
    </span><span class="s0">def </span><span class="s1">_loads_v0(self</span><span class="s0">, </span><span class="s1">request</span><span class="s0">, </span><span class="s1">data): 
        </span><span class="s3"># The original legacy cache data. This doesn't contain enough</span><span class="s1"> 
        </span><span class="s3"># information to construct everything we need, so we'll treat this as</span><span class="s1"> 
        </span><span class="s3"># a miss.</span><span class="s1"> 
        </span><span class="s0">return</span><span class="s1"> 
 
    </span><span class="s0">def </span><span class="s1">_loads_v1(self</span><span class="s0">, </span><span class="s1">request</span><span class="s0">, </span><span class="s1">data): 
        </span><span class="s0">try</span><span class="s1">: 
            cached = pickle.loads(data) 
        </span><span class="s0">except </span><span class="s1">ValueError: 
            </span><span class="s0">return</span><span class="s1"> 
 
        </span><span class="s0">return </span><span class="s1">self.prepare_response(request</span><span class="s0">, </span><span class="s1">cached) 
 
    </span><span class="s0">def </span><span class="s1">_loads_v2(self</span><span class="s0">, </span><span class="s1">request</span><span class="s0">, </span><span class="s1">data): 
        </span><span class="s0">try</span><span class="s1">: 
            cached = json.loads(zlib.decompress(data).decode(</span><span class="s2">&quot;utf8&quot;</span><span class="s1">)) 
        </span><span class="s0">except </span><span class="s1">ValueError: 
            </span><span class="s0">return</span><span class="s1"> 
 
        </span><span class="s3"># We need to decode the items that we've base64 encoded</span><span class="s1"> 
        cached[</span><span class="s2">&quot;response&quot;</span><span class="s1">][</span><span class="s2">&quot;body&quot;</span><span class="s1">] = _b64_decode_bytes( 
            cached[</span><span class="s2">&quot;response&quot;</span><span class="s1">][</span><span class="s2">&quot;body&quot;</span><span class="s1">] 
        ) 
        cached[</span><span class="s2">&quot;response&quot;</span><span class="s1">][</span><span class="s2">&quot;headers&quot;</span><span class="s1">] = dict( 
            (_b64_decode_str(k)</span><span class="s0">, </span><span class="s1">_b64_decode_str(v)) 
            </span><span class="s0">for </span><span class="s1">k</span><span class="s0">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">cached[</span><span class="s2">&quot;response&quot;</span><span class="s1">][</span><span class="s2">&quot;headers&quot;</span><span class="s1">].items() 
        ) 
        cached[</span><span class="s2">&quot;response&quot;</span><span class="s1">][</span><span class="s2">&quot;reason&quot;</span><span class="s1">] = _b64_decode_str( 
            cached[</span><span class="s2">&quot;response&quot;</span><span class="s1">][</span><span class="s2">&quot;reason&quot;</span><span class="s1">]</span><span class="s0">,</span><span class="s1"> 
        ) 
        cached[</span><span class="s2">&quot;vary&quot;</span><span class="s1">] = dict( 
            (_b64_decode_str(k)</span><span class="s0">, </span><span class="s1">_b64_decode_str(v) </span><span class="s0">if </span><span class="s1">v </span><span class="s0">is not None else </span><span class="s1">v) 
            </span><span class="s0">for </span><span class="s1">k</span><span class="s0">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">cached[</span><span class="s2">&quot;vary&quot;</span><span class="s1">].items() 
        ) 
 
        </span><span class="s0">return </span><span class="s1">self.prepare_response(request</span><span class="s0">, </span><span class="s1">cached) 
</span></pre>
</body>
</html>