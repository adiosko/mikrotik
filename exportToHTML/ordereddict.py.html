<html>
<head>
<title>ordereddict.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.ln { color: #606366; font-weight: normal; font-style: normal; }
.s0 { color: rgb(128,128,128); }
.s1 { color: rgb(169,183,198); }
.s2 { color: rgb(204,120,50); }
.s3 { color: rgb(104,151,187); }
.s4 { color: rgb(106,135,89); }
</style>
</head>
<BODY BGCOLOR="#2b2b2b">
<TABLE CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<TR><TD><CENTER>
<FONT FACE="Arial, Helvetica" COLOR="#000000">
ordereddict.py</FONT>
</center></TD></TR></TABLE>
<pre>
<span class="s0"># Copyright (c) 2009 Raymond Hettinger</span><span class="s1"> 
</span><span class="s0">#</span><span class="s1"> 
</span><span class="s0"># Permission is hereby granted, free of charge, to any person</span><span class="s1"> 
</span><span class="s0"># obtaining a copy of this software and associated documentation files</span><span class="s1"> 
</span><span class="s0"># (the &quot;Software&quot;), to deal in the Software without restriction,</span><span class="s1"> 
</span><span class="s0"># including without limitation the rights to use, copy, modify, merge,</span><span class="s1"> 
</span><span class="s0"># publish, distribute, sublicense, and/or sell copies of the Software,</span><span class="s1"> 
</span><span class="s0"># and to permit persons to whom the Software is furnished to do so,</span><span class="s1"> 
</span><span class="s0"># subject to the following conditions:</span><span class="s1"> 
</span><span class="s0">#</span><span class="s1"> 
</span><span class="s0">#     The above copyright notice and this permission notice shall be</span><span class="s1"> 
</span><span class="s0">#     included in all copies or substantial portions of the Software.</span><span class="s1"> 
</span><span class="s0">#</span><span class="s1"> 
</span><span class="s0">#     THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,</span><span class="s1"> 
</span><span class="s0">#     EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES</span><span class="s1"> 
</span><span class="s0">#     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND</span><span class="s1"> 
</span><span class="s0">#     NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT</span><span class="s1"> 
</span><span class="s0">#     HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,</span><span class="s1"> 
</span><span class="s0">#     WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING</span><span class="s1"> 
</span><span class="s0">#     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR</span><span class="s1"> 
</span><span class="s0">#     OTHER DEALINGS IN THE SOFTWARE.</span><span class="s1"> 
 
</span><span class="s2">from </span><span class="s1">UserDict </span><span class="s2">import </span><span class="s1">DictMixin 
 
</span><span class="s2">class </span><span class="s1">OrderedDict(dict</span><span class="s2">, </span><span class="s1">DictMixin): 
 
    </span><span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwds): 
        </span><span class="s2">if </span><span class="s1">len(args) &gt; </span><span class="s3">1</span><span class="s1">: 
            </span><span class="s2">raise </span><span class="s1">TypeError(</span><span class="s4">'expected at most 1 arguments, got %d' </span><span class="s1">% len(args)) 
        </span><span class="s2">try</span><span class="s1">: 
            self.__end 
        </span><span class="s2">except </span><span class="s1">AttributeError: 
            self.clear() 
        self.update(*args</span><span class="s2">, </span><span class="s1">**kwds) 
 
    </span><span class="s2">def </span><span class="s1">clear(self): 
        self.__end = end = [] 
        end += [</span><span class="s2">None, </span><span class="s1">end</span><span class="s2">, </span><span class="s1">end]         </span><span class="s0"># sentinel node for doubly linked list</span><span class="s1"> 
        self.__map = {}                 </span><span class="s0"># key --&gt; [key, prev, next]</span><span class="s1"> 
        dict.clear(self) 
 
    </span><span class="s2">def </span><span class="s1">__setitem__(self</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">value): 
        </span><span class="s2">if </span><span class="s1">key </span><span class="s2">not in </span><span class="s1">self: 
            end = self.__end 
            curr = end[</span><span class="s3">1</span><span class="s1">] 
            curr[</span><span class="s3">2</span><span class="s1">] = end[</span><span class="s3">1</span><span class="s1">] = self.__map[key] = [key</span><span class="s2">, </span><span class="s1">curr</span><span class="s2">, </span><span class="s1">end] 
        dict.__setitem__(self</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">value) 
 
    </span><span class="s2">def </span><span class="s1">__delitem__(self</span><span class="s2">, </span><span class="s1">key): 
        dict.__delitem__(self</span><span class="s2">, </span><span class="s1">key) 
        key</span><span class="s2">, </span><span class="s1">prev</span><span class="s2">, </span><span class="s1">next = self.__map.pop(key) 
        prev[</span><span class="s3">2</span><span class="s1">] = next 
        next[</span><span class="s3">1</span><span class="s1">] = prev 
 
    </span><span class="s2">def </span><span class="s1">__iter__(self): 
        end = self.__end 
        curr = end[</span><span class="s3">2</span><span class="s1">] 
        </span><span class="s2">while </span><span class="s1">curr </span><span class="s2">is not </span><span class="s1">end: 
            </span><span class="s2">yield </span><span class="s1">curr[</span><span class="s3">0</span><span class="s1">] 
            curr = curr[</span><span class="s3">2</span><span class="s1">] 
 
    </span><span class="s2">def </span><span class="s1">__reversed__(self): 
        end = self.__end 
        curr = end[</span><span class="s3">1</span><span class="s1">] 
        </span><span class="s2">while </span><span class="s1">curr </span><span class="s2">is not </span><span class="s1">end: 
            </span><span class="s2">yield </span><span class="s1">curr[</span><span class="s3">0</span><span class="s1">] 
            curr = curr[</span><span class="s3">1</span><span class="s1">] 
 
    </span><span class="s2">def </span><span class="s1">popitem(self</span><span class="s2">, </span><span class="s1">last=</span><span class="s2">True</span><span class="s1">): 
        </span><span class="s2">if not </span><span class="s1">self: 
            </span><span class="s2">raise </span><span class="s1">KeyError(</span><span class="s4">'dictionary is empty'</span><span class="s1">) 
        </span><span class="s2">if </span><span class="s1">last: 
            key = reversed(self).next() 
        </span><span class="s2">else</span><span class="s1">: 
            key = iter(self).next() 
        value = self.pop(key) 
        </span><span class="s2">return </span><span class="s1">key</span><span class="s2">, </span><span class="s1">value 
 
    </span><span class="s2">def </span><span class="s1">__reduce__(self): 
        items = [[k</span><span class="s2">, </span><span class="s1">self[k]] </span><span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">self] 
        tmp = self.__map</span><span class="s2">, </span><span class="s1">self.__end 
        </span><span class="s2">del </span><span class="s1">self.__map</span><span class="s2">, </span><span class="s1">self.__end 
        inst_dict = vars(self).copy() 
        self.__map</span><span class="s2">, </span><span class="s1">self.__end = tmp 
        </span><span class="s2">if </span><span class="s1">inst_dict: 
            </span><span class="s2">return </span><span class="s1">(self.__class__</span><span class="s2">, </span><span class="s1">(items</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">inst_dict) 
        </span><span class="s2">return </span><span class="s1">self.__class__</span><span class="s2">, </span><span class="s1">(items</span><span class="s2">,</span><span class="s1">) 
 
    </span><span class="s2">def </span><span class="s1">keys(self): 
        </span><span class="s2">return </span><span class="s1">list(self) 
 
    setdefault = DictMixin.setdefault 
    update = DictMixin.update 
    pop = DictMixin.pop 
    values = DictMixin.values 
    items = DictMixin.items 
    iterkeys = DictMixin.iterkeys 
    itervalues = DictMixin.itervalues 
    iteritems = DictMixin.iteritems 
 
    </span><span class="s2">def </span><span class="s1">__repr__(self): 
        </span><span class="s2">if not </span><span class="s1">self: 
            </span><span class="s2">return </span><span class="s4">'%s()' </span><span class="s1">% (self.__class__.__name__</span><span class="s2">,</span><span class="s1">) 
        </span><span class="s2">return </span><span class="s4">'%s(%r)' </span><span class="s1">% (self.__class__.__name__</span><span class="s2">, </span><span class="s1">self.items()) 
 
    </span><span class="s2">def </span><span class="s1">copy(self): 
        </span><span class="s2">return </span><span class="s1">self.__class__(self) 
 
    @classmethod 
    </span><span class="s2">def </span><span class="s1">fromkeys(cls</span><span class="s2">, </span><span class="s1">iterable</span><span class="s2">, </span><span class="s1">value=</span><span class="s2">None</span><span class="s1">): 
        d = cls() 
        </span><span class="s2">for </span><span class="s1">key </span><span class="s2">in </span><span class="s1">iterable: 
            d[key] = value 
        </span><span class="s2">return </span><span class="s1">d 
 
    </span><span class="s2">def </span><span class="s1">__eq__(self</span><span class="s2">, </span><span class="s1">other): 
        </span><span class="s2">if </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">OrderedDict): 
            </span><span class="s2">if </span><span class="s1">len(self) != len(other): 
                </span><span class="s2">return False</span><span class="s1"> 
            </span><span class="s2">for </span><span class="s1">p</span><span class="s2">, </span><span class="s1">q </span><span class="s2">in  </span><span class="s1">zip(self.items()</span><span class="s2">, </span><span class="s1">other.items()): 
                </span><span class="s2">if </span><span class="s1">p != q: 
                    </span><span class="s2">return False</span><span class="s1"> 
            </span><span class="s2">return True</span><span class="s1"> 
        </span><span class="s2">return </span><span class="s1">dict.__eq__(self</span><span class="s2">, </span><span class="s1">other) 
 
    </span><span class="s2">def </span><span class="s1">__ne__(self</span><span class="s2">, </span><span class="s1">other): 
        </span><span class="s2">return not </span><span class="s1">self == other 
</span></pre>
</body>
</html>