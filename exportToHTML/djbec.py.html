<html>
<head>
<title>djbec.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.ln { color: #606366; font-weight: normal; font-style: normal; }
.s0 { color: rgb(128,128,128); }
.s1 { color: rgb(169,183,198); }
.s2 { color: rgb(204,120,50); }
.s3 { color: rgb(98,151,85); font-style: italic; }
.s4 { color: rgb(106,135,89); }
.s5 { color: rgb(104,151,187); }
</style>
</head>
<BODY BGCOLOR="#2b2b2b">
<TABLE CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<TR><TD><CENTER>
<FONT FACE="Arial, Helvetica" COLOR="#000000">
djbec.py</FONT>
</center></TD></TR></TABLE>
<pre>
<span class="s0"># Ed25519 digital signatures</span><span class="s1"> 
</span><span class="s0"># Based on http://ed25519.cr.yp.to/python/ed25519.py</span><span class="s1"> 
</span><span class="s0"># See also http://ed25519.cr.yp.to/software.html</span><span class="s1"> 
</span><span class="s0"># Adapted by Ron Garret</span><span class="s1"> 
</span><span class="s0"># Sped up considerably using coordinate transforms found on:</span><span class="s1"> 
</span><span class="s0"># http://www.hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html</span><span class="s1"> 
</span><span class="s0"># Specifically add-2008-hwcd-4 and dbl-2008-hwcd</span><span class="s1"> 
 
</span><span class="s2">import </span><span class="s1">hashlib 
</span><span class="s2">import </span><span class="s1">random 
 
</span><span class="s2">try</span><span class="s1">:  </span><span class="s0"># pragma nocover</span><span class="s1"> 
    unicode 
    PY3 = </span><span class="s2">False</span><span class="s1"> 
 
    </span><span class="s2">def </span><span class="s1">asbytes(b): 
        </span><span class="s3">&quot;&quot;&quot;Convert array of integers to byte string&quot;&quot;&quot;</span><span class="s1"> 
        </span><span class="s2">return </span><span class="s4">''</span><span class="s1">.join(chr(x) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">b) 
 
    </span><span class="s2">def </span><span class="s1">joinbytes(b): 
        </span><span class="s3">&quot;&quot;&quot;Convert array of bytes to byte string&quot;&quot;&quot;</span><span class="s1"> 
        </span><span class="s2">return </span><span class="s4">''</span><span class="s1">.join(b) 
 
    </span><span class="s2">def </span><span class="s1">bit(h</span><span class="s2">, </span><span class="s1">i): 
        </span><span class="s3">&quot;&quot;&quot;Return i'th bit of bytestring h&quot;&quot;&quot;</span><span class="s1"> 
        </span><span class="s2">return </span><span class="s1">(ord(h[i // </span><span class="s5">8</span><span class="s1">]) &gt;&gt; (i % </span><span class="s5">8</span><span class="s1">)) &amp; </span><span class="s5">1</span><span class="s1"> 
</span><span class="s2">except </span><span class="s1">NameError:  </span><span class="s0"># pragma nocover</span><span class="s1"> 
    PY3 = </span><span class="s2">True</span><span class="s1"> 
    asbytes = bytes 
    joinbytes = bytes 
 
    </span><span class="s2">def </span><span class="s1">bit(h</span><span class="s2">, </span><span class="s1">i): 
        </span><span class="s2">return </span><span class="s1">(h[i // </span><span class="s5">8</span><span class="s1">] &gt;&gt; (i % </span><span class="s5">8</span><span class="s1">)) &amp; </span><span class="s5">1</span><span class="s1"> 
 
b = </span><span class="s5">256</span><span class="s1"> 
q = </span><span class="s5">2 </span><span class="s1">** </span><span class="s5">255 </span><span class="s1">- </span><span class="s5">19</span><span class="s1"> 
l = </span><span class="s5">2 </span><span class="s1">** </span><span class="s5">252 </span><span class="s1">+ </span><span class="s5">27742317777372353535851937790883648493</span><span class="s1"> 
 
 
</span><span class="s2">def </span><span class="s1">H(m): 
    </span><span class="s2">return </span><span class="s1">hashlib.sha512(m).digest() 
 
 
</span><span class="s2">def </span><span class="s1">expmod(b</span><span class="s2">, </span><span class="s1">e</span><span class="s2">, </span><span class="s1">m): 
    </span><span class="s2">if </span><span class="s1">e == </span><span class="s5">0</span><span class="s1">: 
        </span><span class="s2">return </span><span class="s5">1</span><span class="s1"> 
 
    t = expmod(b</span><span class="s2">, </span><span class="s1">e // </span><span class="s5">2</span><span class="s2">, </span><span class="s1">m) ** </span><span class="s5">2 </span><span class="s1">% m 
    </span><span class="s2">if </span><span class="s1">e &amp; </span><span class="s5">1</span><span class="s1">: 
        t = (t * b) % m 
 
    </span><span class="s2">return </span><span class="s1">t 
 
 
</span><span class="s0"># Can probably get some extra speedup here by replacing this with</span><span class="s1"> 
</span><span class="s0"># an extended-euclidean, but performance seems OK without that</span><span class="s1"> 
</span><span class="s2">def </span><span class="s1">inv(x): 
    </span><span class="s2">return </span><span class="s1">expmod(x</span><span class="s2">, </span><span class="s1">q - </span><span class="s5">2</span><span class="s2">, </span><span class="s1">q) 
 
 
d = -</span><span class="s5">121665 </span><span class="s1">* inv(</span><span class="s5">121666</span><span class="s1">) 
I = expmod(</span><span class="s5">2</span><span class="s2">, </span><span class="s1">(q - </span><span class="s5">1</span><span class="s1">) // </span><span class="s5">4</span><span class="s2">, </span><span class="s1">q) 
 
 
</span><span class="s2">def </span><span class="s1">xrecover(y): 
    xx = (y * y - </span><span class="s5">1</span><span class="s1">) * inv(d * y * y + </span><span class="s5">1</span><span class="s1">) 
    x = expmod(xx</span><span class="s2">, </span><span class="s1">(q + </span><span class="s5">3</span><span class="s1">) // </span><span class="s5">8</span><span class="s2">, </span><span class="s1">q) 
    </span><span class="s2">if </span><span class="s1">(x * x - xx) % q != </span><span class="s5">0</span><span class="s1">: 
        x = (x * I) % q 
 
    </span><span class="s2">if </span><span class="s1">x % </span><span class="s5">2 </span><span class="s1">!= </span><span class="s5">0</span><span class="s1">: 
        x = q - x 
 
    </span><span class="s2">return </span><span class="s1">x 
 
 
By = </span><span class="s5">4 </span><span class="s1">* inv(</span><span class="s5">5</span><span class="s1">) 
Bx = xrecover(By) 
B = [Bx % q</span><span class="s2">, </span><span class="s1">By % q] 
 
 
</span><span class="s0"># def edwards(P,Q):</span><span class="s1"> 
</span><span class="s0">#    x1 = P[0]</span><span class="s1"> 
</span><span class="s0">#    y1 = P[1]</span><span class="s1"> 
</span><span class="s0">#    x2 = Q[0]</span><span class="s1"> 
</span><span class="s0">#    y2 = Q[1]</span><span class="s1"> 
</span><span class="s0">#    x3 = (x1*y2+x2*y1) * inv(1+d*x1*x2*y1*y2)</span><span class="s1"> 
</span><span class="s0">#    y3 = (y1*y2+x1*x2) * inv(1-d*x1*x2*y1*y2)</span><span class="s1"> 
</span><span class="s0">#    return (x3 % q,y3 % q)</span><span class="s1"> 
 
</span><span class="s0"># def scalarmult(P,e):</span><span class="s1"> 
</span><span class="s0">#    if e == 0: return [0,1]</span><span class="s1"> 
</span><span class="s0">#    Q = scalarmult(P,e/2)</span><span class="s1"> 
</span><span class="s0">#    Q = edwards(Q,Q)</span><span class="s1"> 
</span><span class="s0">#    if e &amp; 1: Q = edwards(Q,P)</span><span class="s1"> 
</span><span class="s0">#    return Q</span><span class="s1"> 
 
</span><span class="s0"># Faster (!) version based on:</span><span class="s1"> 
</span><span class="s0"># http://www.hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html</span><span class="s1"> 
 
</span><span class="s2">def </span><span class="s1">xpt_add(pt1</span><span class="s2">, </span><span class="s1">pt2): 
    (X1</span><span class="s2">, </span><span class="s1">Y1</span><span class="s2">, </span><span class="s1">Z1</span><span class="s2">, </span><span class="s1">T1) = pt1 
    (X2</span><span class="s2">, </span><span class="s1">Y2</span><span class="s2">, </span><span class="s1">Z2</span><span class="s2">, </span><span class="s1">T2) = pt2 
    A = ((Y1 - X1) * (Y2 + X2)) % q 
    B = ((Y1 + X1) * (Y2 - X2)) % q 
    C = (Z1 * </span><span class="s5">2 </span><span class="s1">* T2) % q 
    D = (T1 * </span><span class="s5">2 </span><span class="s1">* Z2) % q 
    E = (D + C) % q 
    F = (B - A) % q 
    G = (B + A) % q 
    H = (D - C) % q 
    X3 = (E * F) % q 
    Y3 = (G * H) % q 
    Z3 = (F * G) % q 
    T3 = (E * H) % q 
    </span><span class="s2">return </span><span class="s1">(X3</span><span class="s2">, </span><span class="s1">Y3</span><span class="s2">, </span><span class="s1">Z3</span><span class="s2">, </span><span class="s1">T3) 
 
 
</span><span class="s2">def </span><span class="s1">xpt_double(pt): 
    (X1</span><span class="s2">, </span><span class="s1">Y1</span><span class="s2">, </span><span class="s1">Z1</span><span class="s2">, </span><span class="s1">_) = pt 
    A = (X1 * X1) 
    B = (Y1 * Y1) 
    C = (</span><span class="s5">2 </span><span class="s1">* Z1 * Z1) 
    D = (-A) % q 
    J = (X1 + Y1) % q 
    E = (J * J - A - B) % q 
    G = (D + B) % q 
    F = (G - C) % q 
    H = (D - B) % q 
    X3 = (E * F) % q 
    Y3 = (G * H) % q 
    Z3 = (F * G) % q 
    T3 = (E * H) % q 
    </span><span class="s2">return </span><span class="s1">X3</span><span class="s2">, </span><span class="s1">Y3</span><span class="s2">, </span><span class="s1">Z3</span><span class="s2">, </span><span class="s1">T3 
 
 
</span><span class="s2">def </span><span class="s1">pt_xform(pt): 
    (x</span><span class="s2">, </span><span class="s1">y) = pt 
    </span><span class="s2">return </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s1">(x * y) % q 
 
 
</span><span class="s2">def </span><span class="s1">pt_unxform(pt): 
    (x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">z</span><span class="s2">, </span><span class="s1">_) = pt 
    </span><span class="s2">return </span><span class="s1">(x * inv(z)) % q</span><span class="s2">, </span><span class="s1">(y * inv(z)) % q 
 
 
</span><span class="s2">def </span><span class="s1">xpt_mult(pt</span><span class="s2">, </span><span class="s1">n): 
    </span><span class="s2">if </span><span class="s1">n == </span><span class="s5">0</span><span class="s1">: 
        </span><span class="s2">return </span><span class="s1">pt_xform((</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)) 
 
    _ = xpt_double(xpt_mult(pt</span><span class="s2">, </span><span class="s1">n &gt;&gt; </span><span class="s5">1</span><span class="s1">)) 
    </span><span class="s2">return </span><span class="s1">xpt_add(_</span><span class="s2">, </span><span class="s1">pt) </span><span class="s2">if </span><span class="s1">n &amp; </span><span class="s5">1 </span><span class="s2">else </span><span class="s1">_ 
 
 
</span><span class="s2">def </span><span class="s1">scalarmult(pt</span><span class="s2">, </span><span class="s1">e): 
    </span><span class="s2">return </span><span class="s1">pt_unxform(xpt_mult(pt_xform(pt)</span><span class="s2">, </span><span class="s1">e)) 
 
 
</span><span class="s2">def </span><span class="s1">encodeint(y): 
    bits = [(y &gt;&gt; i) &amp; </span><span class="s5">1 </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(b)] 
    e = [(sum([bits[i * </span><span class="s5">8 </span><span class="s1">+ j] &lt;&lt; j </span><span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">range(</span><span class="s5">8</span><span class="s1">)])) 
         </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(b // </span><span class="s5">8</span><span class="s1">)] 
    </span><span class="s2">return </span><span class="s1">asbytes(e) 
 
 
</span><span class="s2">def </span><span class="s1">encodepoint(P): 
    x = P[</span><span class="s5">0</span><span class="s1">] 
    y = P[</span><span class="s5">1</span><span class="s1">] 
    bits = [(y &gt;&gt; i) &amp; </span><span class="s5">1 </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(b - </span><span class="s5">1</span><span class="s1">)] + [x &amp; </span><span class="s5">1</span><span class="s1">] 
    e = [(sum([bits[i * </span><span class="s5">8 </span><span class="s1">+ j] &lt;&lt; j </span><span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">range(</span><span class="s5">8</span><span class="s1">)])) 
         </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(b // </span><span class="s5">8</span><span class="s1">)] 
    </span><span class="s2">return </span><span class="s1">asbytes(e) 
 
 
</span><span class="s2">def </span><span class="s1">publickey(sk): 
    h = H(sk) 
    a = </span><span class="s5">2 </span><span class="s1">** (b - </span><span class="s5">2</span><span class="s1">) + sum(</span><span class="s5">2 </span><span class="s1">** i * bit(h</span><span class="s2">, </span><span class="s1">i) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s5">3</span><span class="s2">, </span><span class="s1">b - </span><span class="s5">2</span><span class="s1">)) 
    A = scalarmult(B</span><span class="s2">, </span><span class="s1">a) 
    </span><span class="s2">return </span><span class="s1">encodepoint(A) 
 
 
</span><span class="s2">def </span><span class="s1">Hint(m): 
    h = H(m) 
    </span><span class="s2">return </span><span class="s1">sum(</span><span class="s5">2 </span><span class="s1">** i * bit(h</span><span class="s2">, </span><span class="s1">i) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s5">2 </span><span class="s1">* b)) 
 
 
</span><span class="s2">def </span><span class="s1">signature(m</span><span class="s2">, </span><span class="s1">sk</span><span class="s2">, </span><span class="s1">pk): 
    h = H(sk) 
    a = </span><span class="s5">2 </span><span class="s1">** (b - </span><span class="s5">2</span><span class="s1">) + sum(</span><span class="s5">2 </span><span class="s1">** i * bit(h</span><span class="s2">, </span><span class="s1">i) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s5">3</span><span class="s2">, </span><span class="s1">b - </span><span class="s5">2</span><span class="s1">)) 
    inter = joinbytes([h[i] </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(b // </span><span class="s5">8</span><span class="s2">, </span><span class="s1">b // </span><span class="s5">4</span><span class="s1">)]) 
    r = Hint(inter + m) 
    R = scalarmult(B</span><span class="s2">, </span><span class="s1">r) 
    S = (r + Hint(encodepoint(R) + pk + m) * a) % l 
    </span><span class="s2">return </span><span class="s1">encodepoint(R) + encodeint(S) 
 
 
</span><span class="s2">def </span><span class="s1">isoncurve(P): 
    x = P[</span><span class="s5">0</span><span class="s1">] 
    y = P[</span><span class="s5">1</span><span class="s1">] 
    </span><span class="s2">return </span><span class="s1">(-x * x + y * y - </span><span class="s5">1 </span><span class="s1">- d * x * x * y * y) % q == </span><span class="s5">0</span><span class="s1"> 
 
 
</span><span class="s2">def </span><span class="s1">decodeint(s): 
    </span><span class="s2">return </span><span class="s1">sum(</span><span class="s5">2 </span><span class="s1">** i * bit(s</span><span class="s2">, </span><span class="s1">i) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">b)) 
 
 
</span><span class="s2">def </span><span class="s1">decodepoint(s): 
    y = sum(</span><span class="s5">2 </span><span class="s1">** i * bit(s</span><span class="s2">, </span><span class="s1">i) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">b - </span><span class="s5">1</span><span class="s1">)) 
    x = xrecover(y) 
    </span><span class="s2">if </span><span class="s1">x &amp; </span><span class="s5">1 </span><span class="s1">!= bit(s</span><span class="s2">, </span><span class="s1">b - </span><span class="s5">1</span><span class="s1">): 
        x = q - x 
 
    P = [x</span><span class="s2">, </span><span class="s1">y] 
    </span><span class="s2">if not </span><span class="s1">isoncurve(P): 
        </span><span class="s2">raise </span><span class="s1">Exception(</span><span class="s4">&quot;decoding point that is not on curve&quot;</span><span class="s1">) 
 
    </span><span class="s2">return </span><span class="s1">P 
 
 
</span><span class="s2">def </span><span class="s1">checkvalid(s</span><span class="s2">, </span><span class="s1">m</span><span class="s2">, </span><span class="s1">pk): 
    </span><span class="s2">if </span><span class="s1">len(s) != b // </span><span class="s5">4</span><span class="s1">: 
        </span><span class="s2">raise </span><span class="s1">Exception(</span><span class="s4">&quot;signature length is wrong&quot;</span><span class="s1">) 
    </span><span class="s2">if </span><span class="s1">len(pk) != b // </span><span class="s5">8</span><span class="s1">: 
        </span><span class="s2">raise </span><span class="s1">Exception(</span><span class="s4">&quot;public-key length is wrong&quot;</span><span class="s1">) 
 
    R = decodepoint(s[</span><span class="s5">0</span><span class="s1">:b // </span><span class="s5">8</span><span class="s1">]) 
    A = decodepoint(pk) 
    S = decodeint(s[b // </span><span class="s5">8</span><span class="s1">:b // </span><span class="s5">4</span><span class="s1">]) 
    h = Hint(encodepoint(R) + pk + m) 
    v1 = scalarmult(B</span><span class="s2">, </span><span class="s1">S) 
    </span><span class="s0">#  v2 = edwards(R,scalarmult(A,h))</span><span class="s1"> 
    v2 = pt_unxform(xpt_add(pt_xform(R)</span><span class="s2">, </span><span class="s1">pt_xform(scalarmult(A</span><span class="s2">, </span><span class="s1">h)))) 
    </span><span class="s2">return </span><span class="s1">v1 == v2 
 
 
</span><span class="s0">##########################################################</span><span class="s1"> 
</span><span class="s0">#</span><span class="s1"> 
</span><span class="s0"># Curve25519 reference implementation by Matthew Dempsky, from:</span><span class="s1"> 
</span><span class="s0"># http://cr.yp.to/highspeed/naclcrypto-20090310.pdf</span><span class="s1"> 
 
</span><span class="s0"># P = 2 ** 255 - 19</span><span class="s1"> 
P = q 
A = </span><span class="s5">486662</span><span class="s1"> 
 
 
</span><span class="s0"># def expmod(b, e, m):</span><span class="s1"> 
</span><span class="s0">#    if e == 0: return 1</span><span class="s1"> 
</span><span class="s0">#    t = expmod(b, e / 2, m) ** 2 % m</span><span class="s1"> 
</span><span class="s0">#    if e &amp; 1: t = (t * b) % m</span><span class="s1"> 
</span><span class="s0">#    return t</span><span class="s1"> 
 
</span><span class="s0"># def inv(x): return expmod(x, P - 2, P)</span><span class="s1"> 
 
 
</span><span class="s2">def </span><span class="s1">add(n</span><span class="s2">, </span><span class="s1">m</span><span class="s2">, </span><span class="s1">d): 
    (xn</span><span class="s2">, </span><span class="s1">zn) = n 
    (xm</span><span class="s2">, </span><span class="s1">zm) = m 
    (xd</span><span class="s2">, </span><span class="s1">zd) = d 
    x = </span><span class="s5">4 </span><span class="s1">* (xm * xn - zm * zn) ** </span><span class="s5">2 </span><span class="s1">* zd 
    z = </span><span class="s5">4 </span><span class="s1">* (xm * zn - zm * xn) ** </span><span class="s5">2 </span><span class="s1">* xd 
    </span><span class="s2">return </span><span class="s1">(x % P</span><span class="s2">, </span><span class="s1">z % P) 
 
 
</span><span class="s2">def </span><span class="s1">double(n): 
    (xn</span><span class="s2">, </span><span class="s1">zn) = n 
    x = (xn ** </span><span class="s5">2 </span><span class="s1">- zn ** </span><span class="s5">2</span><span class="s1">) ** </span><span class="s5">2</span><span class="s1"> 
    z = </span><span class="s5">4 </span><span class="s1">* xn * zn * (xn ** </span><span class="s5">2 </span><span class="s1">+ A * xn * zn + zn ** </span><span class="s5">2</span><span class="s1">) 
    </span><span class="s2">return </span><span class="s1">(x % P</span><span class="s2">, </span><span class="s1">z % P) 
 
 
</span><span class="s2">def </span><span class="s1">curve25519(n</span><span class="s2">, </span><span class="s1">base=</span><span class="s5">9</span><span class="s1">): 
    one = (base</span><span class="s2">, </span><span class="s5">1</span><span class="s1">) 
    two = double(one) 
 
    </span><span class="s0"># f(m) evaluates to a tuple</span><span class="s1"> 
    </span><span class="s0"># containing the mth multiple and the</span><span class="s1"> 
    </span><span class="s0"># (m+1)th multiple of base.</span><span class="s1"> 
    </span><span class="s2">def </span><span class="s1">f(m): 
        </span><span class="s2">if </span><span class="s1">m == </span><span class="s5">1</span><span class="s1">: 
            </span><span class="s2">return </span><span class="s1">(one</span><span class="s2">, </span><span class="s1">two) 
 
        (pm</span><span class="s2">, </span><span class="s1">pm1) = f(m // </span><span class="s5">2</span><span class="s1">) 
        </span><span class="s2">if </span><span class="s1">m &amp; </span><span class="s5">1</span><span class="s1">: 
            </span><span class="s2">return </span><span class="s1">(add(pm</span><span class="s2">, </span><span class="s1">pm1</span><span class="s2">, </span><span class="s1">one)</span><span class="s2">, </span><span class="s1">double(pm1)) 
 
        </span><span class="s2">return </span><span class="s1">(double(pm)</span><span class="s2">, </span><span class="s1">add(pm</span><span class="s2">, </span><span class="s1">pm1</span><span class="s2">, </span><span class="s1">one)) 
 
    ((x</span><span class="s2">, </span><span class="s1">z)</span><span class="s2">, </span><span class="s1">_) = f(n) 
    </span><span class="s2">return </span><span class="s1">(x * inv(z)) % P 
 
 
</span><span class="s2">def </span><span class="s1">genkey(n=</span><span class="s5">0</span><span class="s1">): 
    n = n </span><span class="s2">or </span><span class="s1">random.randint(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">P) 
    n &amp;= ~</span><span class="s5">7</span><span class="s1"> 
    n &amp;= ~(</span><span class="s5">128 </span><span class="s1">&lt;&lt; </span><span class="s5">8 </span><span class="s1">* </span><span class="s5">31</span><span class="s1">) 
    n |= </span><span class="s5">64 </span><span class="s1">&lt;&lt; </span><span class="s5">8 </span><span class="s1">* </span><span class="s5">31</span><span class="s1"> 
    </span><span class="s2">return </span><span class="s1">n 
 
 
</span><span class="s0"># def str2int(s):</span><span class="s1"> 
</span><span class="s0">#    return int(hexlify(s), 16)</span><span class="s1"> 
</span><span class="s0">#    # return sum(ord(s[i]) &lt;&lt; (8 * i) for i in range(32))</span><span class="s1"> 
</span><span class="s0">#</span><span class="s1"> 
</span><span class="s0"># def int2str(n):</span><span class="s1"> 
</span><span class="s0">#    return unhexlify(&quot;%x&quot; % n)</span><span class="s1"> 
</span><span class="s0">#    # return ''.join([chr((n &gt;&gt; (8 * i)) &amp; 255) for i in range(32)])</span><span class="s1"> 
 
</span><span class="s0">#################################################</span><span class="s1"> 
 
 
</span><span class="s2">def </span><span class="s1">dsa_test(): 
    </span><span class="s2">import </span><span class="s1">os 
    msg = str(random.randint(q</span><span class="s2">, </span><span class="s1">q + q)).encode(</span><span class="s4">'utf-8'</span><span class="s1">) 
    sk = os.urandom(</span><span class="s5">32</span><span class="s1">) 
    pk = publickey(sk) 
    sig = signature(msg</span><span class="s2">, </span><span class="s1">sk</span><span class="s2">, </span><span class="s1">pk) 
    </span><span class="s2">return </span><span class="s1">checkvalid(sig</span><span class="s2">, </span><span class="s1">msg</span><span class="s2">, </span><span class="s1">pk) 
 
 
</span><span class="s2">def </span><span class="s1">dh_test(): 
    sk1 = genkey() 
    sk2 = genkey() 
    </span><span class="s2">return </span><span class="s1">curve25519(sk1</span><span class="s2">, </span><span class="s1">curve25519(sk2)) == curve25519(sk2</span><span class="s2">, </span><span class="s1">curve25519(sk1)) 
</span></pre>
</body>
</html>