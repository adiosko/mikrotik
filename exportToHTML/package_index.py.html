<html>
<head>
<title>package_index.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.ln { color: #606366; font-weight: normal; font-style: normal; }
.s0 { color: rgb(98,151,85); font-style: italic; }
.s1 { color: rgb(169,183,198); }
.s2 { color: rgb(204,120,50); }
.s3 { color: rgb(106,135,89); }
.s4 { color: rgb(128,128,128); }
.s5 { color: rgb(104,151,187); }
</style>
</head>
<BODY BGCOLOR="#2b2b2b">
<TABLE CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<TR><TD><CENTER>
<FONT FACE="Arial, Helvetica" COLOR="#000000">
package_index.py</FONT>
</center></TD></TR></TABLE>
<pre>
<span class="s0">&quot;&quot;&quot;PyPI and direct package downloading&quot;&quot;&quot;</span><span class="s1"> 
</span><span class="s2">import </span><span class="s1">sys 
</span><span class="s2">import </span><span class="s1">os 
</span><span class="s2">import </span><span class="s1">re 
</span><span class="s2">import </span><span class="s1">shutil 
</span><span class="s2">import </span><span class="s1">socket 
</span><span class="s2">import </span><span class="s1">base64 
</span><span class="s2">import </span><span class="s1">hashlib 
</span><span class="s2">import </span><span class="s1">itertools 
</span><span class="s2">from </span><span class="s1">functools </span><span class="s2">import </span><span class="s1">wraps 
 
</span><span class="s2">try</span><span class="s1">: 
    </span><span class="s2">from </span><span class="s1">urllib.parse </span><span class="s2">import </span><span class="s1">splituser 
</span><span class="s2">except </span><span class="s1">ImportError: 
    </span><span class="s2">from </span><span class="s1">urllib2 </span><span class="s2">import </span><span class="s1">splituser 
 
</span><span class="s2">from </span><span class="s1">setuptools.extern </span><span class="s2">import </span><span class="s1">six 
</span><span class="s2">from </span><span class="s1">setuptools.extern.six.moves </span><span class="s2">import </span><span class="s1">urllib</span><span class="s2">, </span><span class="s1">http_client</span><span class="s2">, </span><span class="s1">configparser</span><span class="s2">, </span><span class="s1">map 
 
</span><span class="s2">import </span><span class="s1">setuptools 
</span><span class="s2">from </span><span class="s1">pkg_resources </span><span class="s2">import </span><span class="s1">( 
    CHECKOUT_DIST</span><span class="s2">, </span><span class="s1">Distribution</span><span class="s2">, </span><span class="s1">BINARY_DIST</span><span class="s2">, </span><span class="s1">normalize_path</span><span class="s2">, </span><span class="s1">SOURCE_DIST</span><span class="s2">,</span><span class="s1"> 
    Environment</span><span class="s2">, </span><span class="s1">find_distributions</span><span class="s2">, </span><span class="s1">safe_name</span><span class="s2">, </span><span class="s1">safe_version</span><span class="s2">,</span><span class="s1"> 
    to_filename</span><span class="s2">, </span><span class="s1">Requirement</span><span class="s2">, </span><span class="s1">DEVELOP_DIST</span><span class="s2">, </span><span class="s1">EGG_DIST</span><span class="s2">,</span><span class="s1"> 
) 
</span><span class="s2">from </span><span class="s1">setuptools </span><span class="s2">import </span><span class="s1">ssl_support 
</span><span class="s2">from </span><span class="s1">distutils </span><span class="s2">import </span><span class="s1">log 
</span><span class="s2">from </span><span class="s1">distutils.errors </span><span class="s2">import </span><span class="s1">DistutilsError 
</span><span class="s2">from </span><span class="s1">fnmatch </span><span class="s2">import </span><span class="s1">translate 
</span><span class="s2">from </span><span class="s1">setuptools.py27compat </span><span class="s2">import </span><span class="s1">get_all_headers 
</span><span class="s2">from </span><span class="s1">setuptools.wheel </span><span class="s2">import </span><span class="s1">Wheel 
 
EGG_FRAGMENT = re.compile(</span><span class="s3">r'^egg=([-A-Za-z0-9_.+!]+)$'</span><span class="s1">) 
HREF = re.compile(</span><span class="s3">&quot;&quot;&quot;href</span><span class="s2">\\</span><span class="s3">s*=</span><span class="s2">\\</span><span class="s3">s*['&quot;]?([^'&quot;&gt; ]+)&quot;&quot;&quot;</span><span class="s2">, </span><span class="s1">re.I) 
</span><span class="s4"># this is here to fix emacs' cruddy broken syntax highlighting</span><span class="s1"> 
PYPI_MD5 = re.compile( 
    </span><span class="s3">'&lt;a href=&quot;([^&quot;#]+)&quot;&gt;([^&lt;]+)&lt;/a&gt;</span><span class="s2">\n\\</span><span class="s3">s+</span><span class="s2">\\</span><span class="s3">(&lt;a (?:title=&quot;MD5 hash&quot;</span><span class="s2">\n\\</span><span class="s3">s+)'</span><span class="s1"> 
    </span><span class="s3">'href=&quot;[^?]+</span><span class="s2">\\</span><span class="s3">?:action=show_md5&amp;amp;digest=([0-9a-f]{32})&quot;&gt;md5&lt;/a&gt;</span><span class="s2">\\</span><span class="s3">)'</span><span class="s1"> 
) 
URL_SCHEME = re.compile(</span><span class="s3">'([-+.a-z0-9]{2,}):'</span><span class="s2">, </span><span class="s1">re.I).match 
EXTENSIONS = </span><span class="s3">&quot;.tar.gz .tar.bz2 .tar .zip .tgz&quot;</span><span class="s1">.split() 
 
__all__ = [ 
    </span><span class="s3">'PackageIndex'</span><span class="s2">, </span><span class="s3">'distros_for_url'</span><span class="s2">, </span><span class="s3">'parse_bdist_wininst'</span><span class="s2">,</span><span class="s1"> 
    </span><span class="s3">'interpret_distro_name'</span><span class="s2">,</span><span class="s1"> 
] 
 
_SOCKET_TIMEOUT = </span><span class="s5">15</span><span class="s1"> 
 
_tmpl = </span><span class="s3">&quot;setuptools/{setuptools.__version__} Python-urllib/{py_major}&quot;</span><span class="s1"> 
user_agent = _tmpl.format(py_major=sys.version[:</span><span class="s5">3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">setuptools=setuptools) 
 
 
</span><span class="s2">def </span><span class="s1">parse_requirement_arg(spec): 
    </span><span class="s2">try</span><span class="s1">: 
        </span><span class="s2">return </span><span class="s1">Requirement.parse(spec) 
    </span><span class="s2">except </span><span class="s1">ValueError: 
        </span><span class="s2">raise </span><span class="s1">DistutilsError( 
            </span><span class="s3">&quot;Not a URL, existing file, or requirement spec: %r&quot; </span><span class="s1">% (spec</span><span class="s2">,</span><span class="s1">) 
        ) 
 
 
</span><span class="s2">def </span><span class="s1">parse_bdist_wininst(name): 
    </span><span class="s0">&quot;&quot;&quot;Return (base,pyversion) or (None,None) for possible .exe name&quot;&quot;&quot;</span><span class="s1"> 
 
    lower = name.lower() 
    base</span><span class="s2">, </span><span class="s1">py_ver</span><span class="s2">, </span><span class="s1">plat = </span><span class="s2">None, None, None</span><span class="s1"> 
 
    </span><span class="s2">if </span><span class="s1">lower.endswith(</span><span class="s3">'.exe'</span><span class="s1">): 
        </span><span class="s2">if </span><span class="s1">lower.endswith(</span><span class="s3">'.win32.exe'</span><span class="s1">): 
            base = name[:-</span><span class="s5">10</span><span class="s1">] 
            plat = </span><span class="s3">'win32'</span><span class="s1"> 
        </span><span class="s2">elif </span><span class="s1">lower.startswith(</span><span class="s3">'.win32-py'</span><span class="s2">, </span><span class="s1">-</span><span class="s5">16</span><span class="s1">): 
            py_ver = name[-</span><span class="s5">7</span><span class="s1">:-</span><span class="s5">4</span><span class="s1">] 
            base = name[:-</span><span class="s5">16</span><span class="s1">] 
            plat = </span><span class="s3">'win32'</span><span class="s1"> 
        </span><span class="s2">elif </span><span class="s1">lower.endswith(</span><span class="s3">'.win-amd64.exe'</span><span class="s1">): 
            base = name[:-</span><span class="s5">14</span><span class="s1">] 
            plat = </span><span class="s3">'win-amd64'</span><span class="s1"> 
        </span><span class="s2">elif </span><span class="s1">lower.startswith(</span><span class="s3">'.win-amd64-py'</span><span class="s2">, </span><span class="s1">-</span><span class="s5">20</span><span class="s1">): 
            py_ver = name[-</span><span class="s5">7</span><span class="s1">:-</span><span class="s5">4</span><span class="s1">] 
            base = name[:-</span><span class="s5">20</span><span class="s1">] 
            plat = </span><span class="s3">'win-amd64'</span><span class="s1"> 
    </span><span class="s2">return </span><span class="s1">base</span><span class="s2">, </span><span class="s1">py_ver</span><span class="s2">, </span><span class="s1">plat 
 
 
</span><span class="s2">def </span><span class="s1">egg_info_for_url(url): 
    parts = urllib.parse.urlparse(url) 
    scheme</span><span class="s2">, </span><span class="s1">server</span><span class="s2">, </span><span class="s1">path</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">, </span><span class="s1">query</span><span class="s2">, </span><span class="s1">fragment = parts 
    base = urllib.parse.unquote(path.split(</span><span class="s3">'/'</span><span class="s1">)[-</span><span class="s5">1</span><span class="s1">]) 
    </span><span class="s2">if </span><span class="s1">server == </span><span class="s3">'sourceforge.net' </span><span class="s2">and </span><span class="s1">base == </span><span class="s3">'download'</span><span class="s1">:  </span><span class="s4"># XXX Yuck</span><span class="s1"> 
        base = urllib.parse.unquote(path.split(</span><span class="s3">'/'</span><span class="s1">)[-</span><span class="s5">2</span><span class="s1">]) 
    </span><span class="s2">if </span><span class="s3">'#' </span><span class="s2">in </span><span class="s1">base: 
        base</span><span class="s2">, </span><span class="s1">fragment = base.split(</span><span class="s3">'#'</span><span class="s2">, </span><span class="s5">1</span><span class="s1">) 
    </span><span class="s2">return </span><span class="s1">base</span><span class="s2">, </span><span class="s1">fragment 
 
 
</span><span class="s2">def </span><span class="s1">distros_for_url(url</span><span class="s2">, </span><span class="s1">metadata=</span><span class="s2">None</span><span class="s1">): 
    </span><span class="s0">&quot;&quot;&quot;Yield egg or source distribution objects that might be found at a URL&quot;&quot;&quot;</span><span class="s1"> 
    base</span><span class="s2">, </span><span class="s1">fragment = egg_info_for_url(url) 
    </span><span class="s2">for </span><span class="s1">dist </span><span class="s2">in </span><span class="s1">distros_for_location(url</span><span class="s2">, </span><span class="s1">base</span><span class="s2">, </span><span class="s1">metadata): 
        </span><span class="s2">yield </span><span class="s1">dist 
    </span><span class="s2">if </span><span class="s1">fragment: 
        match = EGG_FRAGMENT.match(fragment) 
        </span><span class="s2">if </span><span class="s1">match: 
            </span><span class="s2">for </span><span class="s1">dist </span><span class="s2">in </span><span class="s1">interpret_distro_name( 
                url</span><span class="s2">, </span><span class="s1">match.group(</span><span class="s5">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">metadata</span><span class="s2">, </span><span class="s1">precedence=CHECKOUT_DIST 
            ): 
                </span><span class="s2">yield </span><span class="s1">dist 
 
 
</span><span class="s2">def </span><span class="s1">distros_for_location(location</span><span class="s2">, </span><span class="s1">basename</span><span class="s2">, </span><span class="s1">metadata=</span><span class="s2">None</span><span class="s1">): 
    </span><span class="s0">&quot;&quot;&quot;Yield egg or source distribution objects based on basename&quot;&quot;&quot;</span><span class="s1"> 
    </span><span class="s2">if </span><span class="s1">basename.endswith(</span><span class="s3">'.egg.zip'</span><span class="s1">): 
        basename = basename[:-</span><span class="s5">4</span><span class="s1">]  </span><span class="s4"># strip the .zip</span><span class="s1"> 
    </span><span class="s2">if </span><span class="s1">basename.endswith(</span><span class="s3">'.egg'</span><span class="s1">) </span><span class="s2">and </span><span class="s3">'-' </span><span class="s2">in </span><span class="s1">basename: 
        </span><span class="s4"># only one, unambiguous interpretation</span><span class="s1"> 
        </span><span class="s2">return </span><span class="s1">[Distribution.from_location(location</span><span class="s2">, </span><span class="s1">basename</span><span class="s2">, </span><span class="s1">metadata)] 
    </span><span class="s2">if </span><span class="s1">basename.endswith(</span><span class="s3">'.whl'</span><span class="s1">) </span><span class="s2">and </span><span class="s3">'-' </span><span class="s2">in </span><span class="s1">basename: 
        wheel = Wheel(basename) 
        </span><span class="s2">if not </span><span class="s1">wheel.is_compatible(): 
            </span><span class="s2">return </span><span class="s1">[] 
        </span><span class="s2">return </span><span class="s1">[Distribution( 
            location=location</span><span class="s2">,</span><span class="s1"> 
            project_name=wheel.project_name</span><span class="s2">,</span><span class="s1"> 
            version=wheel.version</span><span class="s2">,</span><span class="s1"> 
            </span><span class="s4"># Increase priority over eggs.</span><span class="s1"> 
            precedence=EGG_DIST + </span><span class="s5">1</span><span class="s2">,</span><span class="s1"> 
        )] 
    </span><span class="s2">if </span><span class="s1">basename.endswith(</span><span class="s3">'.exe'</span><span class="s1">): 
        win_base</span><span class="s2">, </span><span class="s1">py_ver</span><span class="s2">, </span><span class="s1">platform = parse_bdist_wininst(basename) 
        </span><span class="s2">if </span><span class="s1">win_base </span><span class="s2">is not None</span><span class="s1">: 
            </span><span class="s2">return </span><span class="s1">interpret_distro_name( 
                location</span><span class="s2">, </span><span class="s1">win_base</span><span class="s2">, </span><span class="s1">metadata</span><span class="s2">, </span><span class="s1">py_ver</span><span class="s2">, </span><span class="s1">BINARY_DIST</span><span class="s2">, </span><span class="s1">platform 
            ) 
    </span><span class="s4"># Try source distro extensions (.zip, .tgz, etc.)</span><span class="s1"> 
    </span><span class="s4">#</span><span class="s1"> 
    </span><span class="s2">for </span><span class="s1">ext </span><span class="s2">in </span><span class="s1">EXTENSIONS: 
        </span><span class="s2">if </span><span class="s1">basename.endswith(ext): 
            basename = basename[:-len(ext)] 
            </span><span class="s2">return </span><span class="s1">interpret_distro_name(location</span><span class="s2">, </span><span class="s1">basename</span><span class="s2">, </span><span class="s1">metadata) 
    </span><span class="s2">return </span><span class="s1">[]  </span><span class="s4"># no extension matched</span><span class="s1"> 
 
 
</span><span class="s2">def </span><span class="s1">distros_for_filename(filename</span><span class="s2">, </span><span class="s1">metadata=</span><span class="s2">None</span><span class="s1">): 
    </span><span class="s0">&quot;&quot;&quot;Yield possible egg or source distribution objects based on a filename&quot;&quot;&quot;</span><span class="s1"> 
    </span><span class="s2">return </span><span class="s1">distros_for_location( 
        normalize_path(filename)</span><span class="s2">, </span><span class="s1">os.path.basename(filename)</span><span class="s2">, </span><span class="s1">metadata 
    ) 
 
 
</span><span class="s2">def </span><span class="s1">interpret_distro_name( 
        location</span><span class="s2">, </span><span class="s1">basename</span><span class="s2">, </span><span class="s1">metadata</span><span class="s2">, </span><span class="s1">py_version=</span><span class="s2">None, </span><span class="s1">precedence=SOURCE_DIST</span><span class="s2">,</span><span class="s1"> 
        platform=</span><span class="s2">None</span><span class="s1"> 
): 
    </span><span class="s0">&quot;&quot;&quot;Generate alternative interpretations of a source distro name 
 
    Note: if `location` is a filesystem filename, you should call 
    ``pkg_resources.normalize_path()`` on it before passing it to this 
    routine! 
    &quot;&quot;&quot;</span><span class="s1"> 
    </span><span class="s4"># Generate alternative interpretations of a source distro name</span><span class="s1"> 
    </span><span class="s4"># Because some packages are ambiguous as to name/versions split</span><span class="s1"> 
    </span><span class="s4"># e.g. &quot;adns-python-1.1.0&quot;, &quot;egenix-mx-commercial&quot;, etc.</span><span class="s1"> 
    </span><span class="s4"># So, we generate each possible interepretation (e.g. &quot;adns, python-1.1.0&quot;</span><span class="s1"> 
    </span><span class="s4"># &quot;adns-python, 1.1.0&quot;, and &quot;adns-python-1.1.0, no version&quot;).  In practice,</span><span class="s1"> 
    </span><span class="s4"># the spurious interpretations should be ignored, because in the event</span><span class="s1"> 
    </span><span class="s4"># there's also an &quot;adns&quot; package, the spurious &quot;python-1.1.0&quot; version will</span><span class="s1"> 
    </span><span class="s4"># compare lower than any numeric version number, and is therefore unlikely</span><span class="s1"> 
    </span><span class="s4"># to match a request for it.  It's still a potential problem, though, and</span><span class="s1"> 
    </span><span class="s4"># in the long run PyPI and the distutils should go for &quot;safe&quot; names and</span><span class="s1"> 
    </span><span class="s4"># versions in distribution archive names (sdist and bdist).</span><span class="s1"> 
 
    parts = basename.split(</span><span class="s3">'-'</span><span class="s1">) 
    </span><span class="s2">if not </span><span class="s1">py_version </span><span class="s2">and </span><span class="s1">any(re.match(</span><span class="s3">r'py\d\.\d$'</span><span class="s2">, </span><span class="s1">p) </span><span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">parts[</span><span class="s5">2</span><span class="s1">:]): 
        </span><span class="s4"># it is a bdist_dumb, not an sdist -- bail out</span><span class="s1"> 
        </span><span class="s2">return</span><span class="s1"> 
 
    </span><span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">range(</span><span class="s5">1</span><span class="s2">, </span><span class="s1">len(parts) + </span><span class="s5">1</span><span class="s1">): 
        </span><span class="s2">yield </span><span class="s1">Distribution( 
            location</span><span class="s2">, </span><span class="s1">metadata</span><span class="s2">, </span><span class="s3">'-'</span><span class="s1">.join(parts[:p])</span><span class="s2">, </span><span class="s3">'-'</span><span class="s1">.join(parts[p:])</span><span class="s2">,</span><span class="s1"> 
            py_version=py_version</span><span class="s2">, </span><span class="s1">precedence=precedence</span><span class="s2">,</span><span class="s1"> 
            platform=platform 
        ) 
 
 
</span><span class="s4"># From Python 2.7 docs</span><span class="s1"> 
</span><span class="s2">def </span><span class="s1">unique_everseen(iterable</span><span class="s2">, </span><span class="s1">key=</span><span class="s2">None</span><span class="s1">): 
    </span><span class="s0">&quot;List unique elements, preserving order. Remember all elements ever seen.&quot;</span><span class="s1"> 
    </span><span class="s4"># unique_everseen('AAAABBBCCDAABBB') --&gt; A B C D</span><span class="s1"> 
    </span><span class="s4"># unique_everseen('ABBCcAD', str.lower) --&gt; A B C D</span><span class="s1"> 
    seen = set() 
    seen_add = seen.add 
    </span><span class="s2">if </span><span class="s1">key </span><span class="s2">is None</span><span class="s1">: 
        </span><span class="s2">for </span><span class="s1">element </span><span class="s2">in </span><span class="s1">six.moves.filterfalse(seen.__contains__</span><span class="s2">, </span><span class="s1">iterable): 
            seen_add(element) 
            </span><span class="s2">yield </span><span class="s1">element 
    </span><span class="s2">else</span><span class="s1">: 
        </span><span class="s2">for </span><span class="s1">element </span><span class="s2">in </span><span class="s1">iterable: 
            k = key(element) 
            </span><span class="s2">if </span><span class="s1">k </span><span class="s2">not in </span><span class="s1">seen: 
                seen_add(k) 
                </span><span class="s2">yield </span><span class="s1">element 
 
 
</span><span class="s2">def </span><span class="s1">unique_values(func): 
    </span><span class="s0">&quot;&quot;&quot; 
    Wrap a function returning an iterable such that the resulting iterable 
    only ever yields unique items. 
    &quot;&quot;&quot;</span><span class="s1"> 
 
    @wraps(func) 
    </span><span class="s2">def </span><span class="s1">wrapper(*args</span><span class="s2">, </span><span class="s1">**kwargs): 
        </span><span class="s2">return </span><span class="s1">unique_everseen(func(*args</span><span class="s2">, </span><span class="s1">**kwargs)) 
 
    </span><span class="s2">return </span><span class="s1">wrapper 
 
 
REL = re.compile(</span><span class="s3">r&quot;&quot;&quot;&lt;([^&gt;]*\srel\s*=\s*['&quot;]?([^'&quot;&gt;]+)[^&gt;]*)&gt;&quot;&quot;&quot;</span><span class="s2">, </span><span class="s1">re.I) 
</span><span class="s4"># this line is here to fix emacs' cruddy broken syntax highlighting</span><span class="s1"> 
 
 
@unique_values 
</span><span class="s2">def </span><span class="s1">find_external_links(url</span><span class="s2">, </span><span class="s1">page): 
    </span><span class="s0">&quot;&quot;&quot;Find rel=&quot;homepage&quot; and rel=&quot;download&quot; links in `page`, yielding URLs&quot;&quot;&quot;</span><span class="s1"> 
 
    </span><span class="s2">for </span><span class="s1">match </span><span class="s2">in </span><span class="s1">REL.finditer(page): 
        tag</span><span class="s2">, </span><span class="s1">rel = match.groups() 
        rels = set(map(str.strip</span><span class="s2">, </span><span class="s1">rel.lower().split(</span><span class="s3">','</span><span class="s1">))) 
        </span><span class="s2">if </span><span class="s3">'homepage' </span><span class="s2">in </span><span class="s1">rels </span><span class="s2">or </span><span class="s3">'download' </span><span class="s2">in </span><span class="s1">rels: 
            </span><span class="s2">for </span><span class="s1">match </span><span class="s2">in </span><span class="s1">HREF.finditer(tag): 
                </span><span class="s2">yield </span><span class="s1">urllib.parse.urljoin(url</span><span class="s2">, </span><span class="s1">htmldecode(match.group(</span><span class="s5">1</span><span class="s1">))) 
 
    </span><span class="s2">for </span><span class="s1">tag </span><span class="s2">in </span><span class="s1">(</span><span class="s3">&quot;&lt;th&gt;Home Page&quot;</span><span class="s2">, </span><span class="s3">&quot;&lt;th&gt;Download URL&quot;</span><span class="s1">): 
        pos = page.find(tag) 
        </span><span class="s2">if </span><span class="s1">pos != -</span><span class="s5">1</span><span class="s1">: 
            match = HREF.search(page</span><span class="s2">, </span><span class="s1">pos) 
            </span><span class="s2">if </span><span class="s1">match: 
                </span><span class="s2">yield </span><span class="s1">urllib.parse.urljoin(url</span><span class="s2">, </span><span class="s1">htmldecode(match.group(</span><span class="s5">1</span><span class="s1">))) 
 
 
</span><span class="s2">class </span><span class="s1">ContentChecker(object): 
    </span><span class="s0">&quot;&quot;&quot; 
    A null content checker that defines the interface for checking content 
    &quot;&quot;&quot;</span><span class="s1"> 
 
    </span><span class="s2">def </span><span class="s1">feed(self</span><span class="s2">, </span><span class="s1">block): 
        </span><span class="s0">&quot;&quot;&quot; 
        Feed a block of data to the hash. 
        &quot;&quot;&quot;</span><span class="s1"> 
        </span><span class="s2">return</span><span class="s1"> 
 
    </span><span class="s2">def </span><span class="s1">is_valid(self): 
        </span><span class="s0">&quot;&quot;&quot; 
        Check the hash. Return False if validation fails. 
        &quot;&quot;&quot;</span><span class="s1"> 
        </span><span class="s2">return True</span><span class="s1"> 
 
    </span><span class="s2">def </span><span class="s1">report(self</span><span class="s2">, </span><span class="s1">reporter</span><span class="s2">, </span><span class="s1">template): 
        </span><span class="s0">&quot;&quot;&quot; 
        Call reporter with information about the checker (hash name) 
        substituted into the template. 
        &quot;&quot;&quot;</span><span class="s1"> 
        </span><span class="s2">return</span><span class="s1"> 
 
 
</span><span class="s2">class </span><span class="s1">HashChecker(ContentChecker): 
    pattern = re.compile( 
        </span><span class="s3">r'(?P&lt;hash_name&gt;sha1|sha224|sha384|sha256|sha512|md5)='</span><span class="s1"> 
        </span><span class="s3">r'(?P&lt;expected&gt;[a-f0-9]+)'</span><span class="s1"> 
    ) 
 
    </span><span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">hash_name</span><span class="s2">, </span><span class="s1">expected): 
        self.hash_name = hash_name 
        self.hash = hashlib.new(hash_name) 
        self.expected = expected 
 
    @classmethod 
    </span><span class="s2">def </span><span class="s1">from_url(cls</span><span class="s2">, </span><span class="s1">url): 
        </span><span class="s0">&quot;Construct a (possibly null) ContentChecker from a URL&quot;</span><span class="s1"> 
        fragment = urllib.parse.urlparse(url)[-</span><span class="s5">1</span><span class="s1">] 
        </span><span class="s2">if not </span><span class="s1">fragment: 
            </span><span class="s2">return </span><span class="s1">ContentChecker() 
        match = cls.pattern.search(fragment) 
        </span><span class="s2">if not </span><span class="s1">match: 
            </span><span class="s2">return </span><span class="s1">ContentChecker() 
        </span><span class="s2">return </span><span class="s1">cls(**match.groupdict()) 
 
    </span><span class="s2">def </span><span class="s1">feed(self</span><span class="s2">, </span><span class="s1">block): 
        self.hash.update(block) 
 
    </span><span class="s2">def </span><span class="s1">is_valid(self): 
        </span><span class="s2">return </span><span class="s1">self.hash.hexdigest() == self.expected 
 
    </span><span class="s2">def </span><span class="s1">report(self</span><span class="s2">, </span><span class="s1">reporter</span><span class="s2">, </span><span class="s1">template): 
        msg = template % self.hash_name 
        </span><span class="s2">return </span><span class="s1">reporter(msg) 
 
 
</span><span class="s2">class </span><span class="s1">PackageIndex(Environment): 
    </span><span class="s0">&quot;&quot;&quot;A distribution index that scans web pages for download URLs&quot;&quot;&quot;</span><span class="s1"> 
 
    </span><span class="s2">def </span><span class="s1">__init__( 
            self</span><span class="s2">, </span><span class="s1">index_url=</span><span class="s3">&quot;https://pypi.python.org/simple&quot;</span><span class="s2">, </span><span class="s1">hosts=(</span><span class="s3">'*'</span><span class="s2">,</span><span class="s1">)</span><span class="s2">,</span><span class="s1"> 
            ca_bundle=</span><span class="s2">None, </span><span class="s1">verify_ssl=</span><span class="s2">True, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kw 
    ): 
        Environment.__init__(self</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kw) 
        self.index_url = index_url + </span><span class="s3">&quot;/&quot; </span><span class="s1">[:</span><span class="s2">not </span><span class="s1">index_url.endswith(</span><span class="s3">'/'</span><span class="s1">)] 
        self.scanned_urls = {} 
        self.fetched_urls = {} 
        self.package_pages = {} 
        self.allows = re.compile(</span><span class="s3">'|'</span><span class="s1">.join(map(translate</span><span class="s2">, </span><span class="s1">hosts))).match 
        self.to_scan = [] 
        use_ssl = ( 
            verify_ssl 
            </span><span class="s2">and </span><span class="s1">ssl_support.is_available 
            </span><span class="s2">and </span><span class="s1">(ca_bundle </span><span class="s2">or </span><span class="s1">ssl_support.find_ca_bundle()) 
        ) 
        </span><span class="s2">if </span><span class="s1">use_ssl: 
            self.opener = ssl_support.opener_for(ca_bundle) 
        </span><span class="s2">else</span><span class="s1">: 
            self.opener = urllib.request.urlopen 
 
    </span><span class="s2">def </span><span class="s1">process_url(self</span><span class="s2">, </span><span class="s1">url</span><span class="s2">, </span><span class="s1">retrieve=</span><span class="s2">False</span><span class="s1">): 
        </span><span class="s0">&quot;&quot;&quot;Evaluate a URL as a possible download, and maybe retrieve it&quot;&quot;&quot;</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">url </span><span class="s2">in </span><span class="s1">self.scanned_urls </span><span class="s2">and not </span><span class="s1">retrieve: 
            </span><span class="s2">return</span><span class="s1"> 
        self.scanned_urls[url] = </span><span class="s2">True</span><span class="s1"> 
        </span><span class="s2">if not </span><span class="s1">URL_SCHEME(url): 
            self.process_filename(url) 
            </span><span class="s2">return</span><span class="s1"> 
        </span><span class="s2">else</span><span class="s1">: 
            dists = list(distros_for_url(url)) 
            </span><span class="s2">if </span><span class="s1">dists: 
                </span><span class="s2">if not </span><span class="s1">self.url_ok(url): 
                    </span><span class="s2">return</span><span class="s1"> 
                self.debug(</span><span class="s3">&quot;Found link: %s&quot;</span><span class="s2">, </span><span class="s1">url) 
 
        </span><span class="s2">if </span><span class="s1">dists </span><span class="s2">or not </span><span class="s1">retrieve </span><span class="s2">or </span><span class="s1">url </span><span class="s2">in </span><span class="s1">self.fetched_urls: 
            list(map(self.add</span><span class="s2">, </span><span class="s1">dists)) 
            </span><span class="s2">return  </span><span class="s4"># don't need the actual page</span><span class="s1"> 
 
        </span><span class="s2">if not </span><span class="s1">self.url_ok(url): 
            self.fetched_urls[url] = </span><span class="s2">True</span><span class="s1"> 
            </span><span class="s2">return</span><span class="s1"> 
 
        self.info(</span><span class="s3">&quot;Reading %s&quot;</span><span class="s2">, </span><span class="s1">url) 
        self.fetched_urls[url] = </span><span class="s2">True  </span><span class="s4"># prevent multiple fetch attempts</span><span class="s1"> 
        tmpl = </span><span class="s3">&quot;Download error on %s: %%s -- Some packages may not be found!&quot;</span><span class="s1"> 
        f = self.open_url(url</span><span class="s2">, </span><span class="s1">tmpl % url) 
        </span><span class="s2">if </span><span class="s1">f </span><span class="s2">is None</span><span class="s1">: 
            </span><span class="s2">return</span><span class="s1"> 
        self.fetched_urls[f.url] = </span><span class="s2">True</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s3">'html' </span><span class="s2">not in </span><span class="s1">f.headers.get(</span><span class="s3">'content-type'</span><span class="s2">, </span><span class="s3">''</span><span class="s1">).lower(): 
            f.close()  </span><span class="s4"># not html, we can't process it</span><span class="s1"> 
            </span><span class="s2">return</span><span class="s1"> 
 
        base = f.url  </span><span class="s4"># handle redirects</span><span class="s1"> 
        page = f.read() 
        </span><span class="s2">if not </span><span class="s1">isinstance(page</span><span class="s2">, </span><span class="s1">str): 
            </span><span class="s4"># In Python 3 and got bytes but want str.</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">isinstance(f</span><span class="s2">, </span><span class="s1">urllib.error.HTTPError): 
                </span><span class="s4"># Errors have no charset, assume latin1:</span><span class="s1"> 
                charset = </span><span class="s3">'latin-1'</span><span class="s1"> 
            </span><span class="s2">else</span><span class="s1">: 
                charset = f.headers.get_param(</span><span class="s3">'charset'</span><span class="s1">) </span><span class="s2">or </span><span class="s3">'latin-1'</span><span class="s1"> 
            page = page.decode(charset</span><span class="s2">, </span><span class="s3">&quot;ignore&quot;</span><span class="s1">) 
        f.close() 
        </span><span class="s2">for </span><span class="s1">match </span><span class="s2">in </span><span class="s1">HREF.finditer(page): 
            link = urllib.parse.urljoin(base</span><span class="s2">, </span><span class="s1">htmldecode(match.group(</span><span class="s5">1</span><span class="s1">))) 
            self.process_url(link) 
        </span><span class="s2">if </span><span class="s1">url.startswith(self.index_url) </span><span class="s2">and </span><span class="s1">getattr(f</span><span class="s2">, </span><span class="s3">'code'</span><span class="s2">, None</span><span class="s1">) != </span><span class="s5">404</span><span class="s1">: 
            page = self.process_index(url</span><span class="s2">, </span><span class="s1">page) 
 
    </span><span class="s2">def </span><span class="s1">process_filename(self</span><span class="s2">, </span><span class="s1">fn</span><span class="s2">, </span><span class="s1">nested=</span><span class="s2">False</span><span class="s1">): 
        </span><span class="s4"># process filenames or directories</span><span class="s1"> 
        </span><span class="s2">if not </span><span class="s1">os.path.exists(fn): 
            self.warn(</span><span class="s3">&quot;Not found: %s&quot;</span><span class="s2">, </span><span class="s1">fn) 
            </span><span class="s2">return</span><span class="s1"> 
 
        </span><span class="s2">if </span><span class="s1">os.path.isdir(fn) </span><span class="s2">and not </span><span class="s1">nested: 
            path = os.path.realpath(fn) 
            </span><span class="s2">for </span><span class="s1">item </span><span class="s2">in </span><span class="s1">os.listdir(path): 
                self.process_filename(os.path.join(path</span><span class="s2">, </span><span class="s1">item)</span><span class="s2">, True</span><span class="s1">) 
 
        dists = distros_for_filename(fn) 
        </span><span class="s2">if </span><span class="s1">dists: 
            self.debug(</span><span class="s3">&quot;Found: %s&quot;</span><span class="s2">, </span><span class="s1">fn) 
            list(map(self.add</span><span class="s2">, </span><span class="s1">dists)) 
 
    </span><span class="s2">def </span><span class="s1">url_ok(self</span><span class="s2">, </span><span class="s1">url</span><span class="s2">, </span><span class="s1">fatal=</span><span class="s2">False</span><span class="s1">): 
        s = URL_SCHEME(url) 
        is_file = s </span><span class="s2">and </span><span class="s1">s.group(</span><span class="s5">1</span><span class="s1">).lower() == </span><span class="s3">'file'</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">is_file </span><span class="s2">or </span><span class="s1">self.allows(urllib.parse.urlparse(url)[</span><span class="s5">1</span><span class="s1">]): 
            </span><span class="s2">return True</span><span class="s1"> 
        msg = ( 
            </span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">Note: Bypassing %s (disallowed host; see &quot;</span><span class="s1"> 
            </span><span class="s3">&quot;http://bit.ly/2hrImnY for details).</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">) 
        </span><span class="s2">if </span><span class="s1">fatal: 
            </span><span class="s2">raise </span><span class="s1">DistutilsError(msg % url) 
        </span><span class="s2">else</span><span class="s1">: 
            self.warn(msg</span><span class="s2">, </span><span class="s1">url) 
 
    </span><span class="s2">def </span><span class="s1">scan_egg_links(self</span><span class="s2">, </span><span class="s1">search_path): 
        dirs = filter(os.path.isdir</span><span class="s2">, </span><span class="s1">search_path) 
        egg_links = ( 
            (path</span><span class="s2">, </span><span class="s1">entry) 
            </span><span class="s2">for </span><span class="s1">path </span><span class="s2">in </span><span class="s1">dirs 
            </span><span class="s2">for </span><span class="s1">entry </span><span class="s2">in </span><span class="s1">os.listdir(path) 
            </span><span class="s2">if </span><span class="s1">entry.endswith(</span><span class="s3">'.egg-link'</span><span class="s1">) 
        ) 
        list(itertools.starmap(self.scan_egg_link</span><span class="s2">, </span><span class="s1">egg_links)) 
 
    </span><span class="s2">def </span><span class="s1">scan_egg_link(self</span><span class="s2">, </span><span class="s1">path</span><span class="s2">, </span><span class="s1">entry): 
        </span><span class="s2">with </span><span class="s1">open(os.path.join(path</span><span class="s2">, </span><span class="s1">entry)) </span><span class="s2">as </span><span class="s1">raw_lines: 
            </span><span class="s4"># filter non-empty lines</span><span class="s1"> 
            lines = list(filter(</span><span class="s2">None, </span><span class="s1">map(str.strip</span><span class="s2">, </span><span class="s1">raw_lines))) 
 
        </span><span class="s2">if </span><span class="s1">len(lines) != </span><span class="s5">2</span><span class="s1">: 
            </span><span class="s4"># format is not recognized; punt</span><span class="s1"> 
            </span><span class="s2">return</span><span class="s1"> 
 
        egg_path</span><span class="s2">, </span><span class="s1">setup_path = lines 
 
        </span><span class="s2">for </span><span class="s1">dist </span><span class="s2">in </span><span class="s1">find_distributions(os.path.join(path</span><span class="s2">, </span><span class="s1">egg_path)): 
            dist.location = os.path.join(path</span><span class="s2">, </span><span class="s1">*lines) 
            dist.precedence = SOURCE_DIST 
            self.add(dist) 
 
    </span><span class="s2">def </span><span class="s1">process_index(self</span><span class="s2">, </span><span class="s1">url</span><span class="s2">, </span><span class="s1">page): 
        </span><span class="s0">&quot;&quot;&quot;Process the contents of a PyPI page&quot;&quot;&quot;</span><span class="s1"> 
 
        </span><span class="s2">def </span><span class="s1">scan(link): 
            </span><span class="s4"># Process a URL to see if it's for a package page</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">link.startswith(self.index_url): 
                parts = list(map( 
                    urllib.parse.unquote</span><span class="s2">, </span><span class="s1">link[len(self.index_url):].split(</span><span class="s3">'/'</span><span class="s1">) 
                )) 
                </span><span class="s2">if </span><span class="s1">len(parts) == </span><span class="s5">2 </span><span class="s2">and </span><span class="s3">'#' </span><span class="s2">not in </span><span class="s1">parts[</span><span class="s5">1</span><span class="s1">]: 
                    </span><span class="s4"># it's a package page, sanitize and index it</span><span class="s1"> 
                    pkg = safe_name(parts[</span><span class="s5">0</span><span class="s1">]) 
                    ver = safe_version(parts[</span><span class="s5">1</span><span class="s1">]) 
                    self.package_pages.setdefault(pkg.lower()</span><span class="s2">, </span><span class="s1">{})[link] = </span><span class="s2">True</span><span class="s1"> 
                    </span><span class="s2">return </span><span class="s1">to_filename(pkg)</span><span class="s2">, </span><span class="s1">to_filename(ver) 
            </span><span class="s2">return None, None</span><span class="s1"> 
 
        </span><span class="s4"># process an index page into the package-page index</span><span class="s1"> 
        </span><span class="s2">for </span><span class="s1">match </span><span class="s2">in </span><span class="s1">HREF.finditer(page): 
            </span><span class="s2">try</span><span class="s1">: 
                scan(urllib.parse.urljoin(url</span><span class="s2">, </span><span class="s1">htmldecode(match.group(</span><span class="s5">1</span><span class="s1">)))) 
            </span><span class="s2">except </span><span class="s1">ValueError: 
                </span><span class="s2">pass</span><span class="s1"> 
 
        pkg</span><span class="s2">, </span><span class="s1">ver = scan(url)  </span><span class="s4"># ensure this page is in the page index</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">pkg: 
            </span><span class="s4"># process individual package page</span><span class="s1"> 
            </span><span class="s2">for </span><span class="s1">new_url </span><span class="s2">in </span><span class="s1">find_external_links(url</span><span class="s2">, </span><span class="s1">page): 
                </span><span class="s4"># Process the found URL</span><span class="s1"> 
                base</span><span class="s2">, </span><span class="s1">frag = egg_info_for_url(new_url) 
                </span><span class="s2">if </span><span class="s1">base.endswith(</span><span class="s3">'.py'</span><span class="s1">) </span><span class="s2">and not </span><span class="s1">frag: 
                    </span><span class="s2">if </span><span class="s1">ver: 
                        new_url += </span><span class="s3">'#egg=%s-%s' </span><span class="s1">% (pkg</span><span class="s2">, </span><span class="s1">ver) 
                    </span><span class="s2">else</span><span class="s1">: 
                        self.need_version_info(url) 
                self.scan_url(new_url) 
 
            </span><span class="s2">return </span><span class="s1">PYPI_MD5.sub( 
                </span><span class="s2">lambda </span><span class="s1">m: </span><span class="s3">'&lt;a href=&quot;%s#md5=%s&quot;&gt;%s&lt;/a&gt;' </span><span class="s1">% m.group(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">3</span><span class="s2">, </span><span class="s5">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">page 
            ) 
        </span><span class="s2">else</span><span class="s1">: 
            </span><span class="s2">return </span><span class="s3">&quot;&quot;  </span><span class="s4"># no sense double-scanning non-package pages</span><span class="s1"> 
 
    </span><span class="s2">def </span><span class="s1">need_version_info(self</span><span class="s2">, </span><span class="s1">url): 
        self.scan_all( 
            </span><span class="s3">&quot;Page at %s links to .py file(s) without version info; an index &quot;</span><span class="s1"> 
            </span><span class="s3">&quot;scan is required.&quot;</span><span class="s2">, </span><span class="s1">url 
        ) 
 
    </span><span class="s2">def </span><span class="s1">scan_all(self</span><span class="s2">, </span><span class="s1">msg=</span><span class="s2">None, </span><span class="s1">*args): 
        </span><span class="s2">if </span><span class="s1">self.index_url </span><span class="s2">not in </span><span class="s1">self.fetched_urls: 
            </span><span class="s2">if </span><span class="s1">msg: 
                self.warn(msg</span><span class="s2">, </span><span class="s1">*args) 
            self.info( 
                </span><span class="s3">&quot;Scanning index of all packages (this may take a while)&quot;</span><span class="s1"> 
            ) 
        self.scan_url(self.index_url) 
 
    </span><span class="s2">def </span><span class="s1">find_packages(self</span><span class="s2">, </span><span class="s1">requirement): 
        self.scan_url(self.index_url + requirement.unsafe_name + </span><span class="s3">'/'</span><span class="s1">) 
 
        </span><span class="s2">if not </span><span class="s1">self.package_pages.get(requirement.key): 
            </span><span class="s4"># Fall back to safe version of the name</span><span class="s1"> 
            self.scan_url(self.index_url + requirement.project_name + </span><span class="s3">'/'</span><span class="s1">) 
 
        </span><span class="s2">if not </span><span class="s1">self.package_pages.get(requirement.key): 
            </span><span class="s4"># We couldn't find the target package, so search the index page too</span><span class="s1"> 
            self.not_found_in_index(requirement) 
 
        </span><span class="s2">for </span><span class="s1">url </span><span class="s2">in </span><span class="s1">list(self.package_pages.get(requirement.key</span><span class="s2">, </span><span class="s1">())): 
            </span><span class="s4"># scan each page that might be related to the desired package</span><span class="s1"> 
            self.scan_url(url) 
 
    </span><span class="s2">def </span><span class="s1">obtain(self</span><span class="s2">, </span><span class="s1">requirement</span><span class="s2">, </span><span class="s1">installer=</span><span class="s2">None</span><span class="s1">): 
        self.prescan() 
        self.find_packages(requirement) 
        </span><span class="s2">for </span><span class="s1">dist </span><span class="s2">in </span><span class="s1">self[requirement.key]: 
            </span><span class="s2">if </span><span class="s1">dist </span><span class="s2">in </span><span class="s1">requirement: 
                </span><span class="s2">return </span><span class="s1">dist 
            self.debug(</span><span class="s3">&quot;%s does not match %s&quot;</span><span class="s2">, </span><span class="s1">requirement</span><span class="s2">, </span><span class="s1">dist) 
        </span><span class="s2">return </span><span class="s1">super(PackageIndex</span><span class="s2">, </span><span class="s1">self).obtain(requirement</span><span class="s2">, </span><span class="s1">installer) 
 
    </span><span class="s2">def </span><span class="s1">check_hash(self</span><span class="s2">, </span><span class="s1">checker</span><span class="s2">, </span><span class="s1">filename</span><span class="s2">, </span><span class="s1">tfp): 
        </span><span class="s0">&quot;&quot;&quot; 
        checker is a ContentChecker 
        &quot;&quot;&quot;</span><span class="s1"> 
        checker.report( 
            self.debug</span><span class="s2">,</span><span class="s1"> 
            </span><span class="s3">&quot;Validating %%s checksum for %s&quot; </span><span class="s1">% filename) 
        </span><span class="s2">if not </span><span class="s1">checker.is_valid(): 
            tfp.close() 
            os.unlink(filename) 
            </span><span class="s2">raise </span><span class="s1">DistutilsError( 
                </span><span class="s3">&quot;%s validation failed for %s; &quot;</span><span class="s1"> 
                </span><span class="s3">&quot;possible download problem?&quot;</span><span class="s1"> 
                % (checker.hash.name</span><span class="s2">, </span><span class="s1">os.path.basename(filename)) 
            ) 
 
    </span><span class="s2">def </span><span class="s1">add_find_links(self</span><span class="s2">, </span><span class="s1">urls): 
        </span><span class="s0">&quot;&quot;&quot;Add `urls` to the list that will be prescanned for searches&quot;&quot;&quot;</span><span class="s1"> 
        </span><span class="s2">for </span><span class="s1">url </span><span class="s2">in </span><span class="s1">urls: 
            </span><span class="s2">if </span><span class="s1">( 
                self.to_scan </span><span class="s2">is None  </span><span class="s4"># if we have already &quot;gone online&quot;</span><span class="s1"> 
                </span><span class="s2">or not </span><span class="s1">URL_SCHEME(url)  </span><span class="s4"># or it's a local file/directory</span><span class="s1"> 
                </span><span class="s2">or </span><span class="s1">url.startswith(</span><span class="s3">'file:'</span><span class="s1">) 
                </span><span class="s2">or </span><span class="s1">list(distros_for_url(url))  </span><span class="s4"># or a direct package link</span><span class="s1"> 
            ): 
                </span><span class="s4"># then go ahead and process it now</span><span class="s1"> 
                self.scan_url(url) 
            </span><span class="s2">else</span><span class="s1">: 
                </span><span class="s4"># otherwise, defer retrieval till later</span><span class="s1"> 
                self.to_scan.append(url) 
 
    </span><span class="s2">def </span><span class="s1">prescan(self): 
        </span><span class="s0">&quot;&quot;&quot;Scan urls scheduled for prescanning (e.g. --find-links)&quot;&quot;&quot;</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">self.to_scan: 
            list(map(self.scan_url</span><span class="s2">, </span><span class="s1">self.to_scan)) 
        self.to_scan = </span><span class="s2">None  </span><span class="s4"># from now on, go ahead and process immediately</span><span class="s1"> 
 
    </span><span class="s2">def </span><span class="s1">not_found_in_index(self</span><span class="s2">, </span><span class="s1">requirement): 
        </span><span class="s2">if </span><span class="s1">self[requirement.key]:  </span><span class="s4"># we've seen at least one distro</span><span class="s1"> 
            meth</span><span class="s2">, </span><span class="s1">msg = self.info</span><span class="s2">, </span><span class="s3">&quot;Couldn't retrieve index page for %r&quot;</span><span class="s1"> 
        </span><span class="s2">else</span><span class="s1">:  </span><span class="s4"># no distros seen for this name, might be misspelled</span><span class="s1"> 
            meth</span><span class="s2">, </span><span class="s1">msg = ( 
                self.warn</span><span class="s2">,</span><span class="s1"> 
                </span><span class="s3">&quot;Couldn't find index page for %r (maybe misspelled?)&quot;</span><span class="s1">) 
        meth(msg</span><span class="s2">, </span><span class="s1">requirement.unsafe_name) 
        self.scan_all() 
 
    </span><span class="s2">def </span><span class="s1">download(self</span><span class="s2">, </span><span class="s1">spec</span><span class="s2">, </span><span class="s1">tmpdir): 
        </span><span class="s0">&quot;&quot;&quot;Locate and/or download `spec` to `tmpdir`, returning a local path 
 
        `spec` may be a ``Requirement`` object, or a string containing a URL, 
        an existing local filename, or a project/version requirement spec 
        (i.e. the string form of a ``Requirement`` object).  If it is the URL 
        of a .py file with an unambiguous ``#egg=name-version`` tag (i.e., one 
        that escapes ``-`` as ``_`` throughout), a trivial ``setup.py`` is 
        automatically created alongside the downloaded file. 
 
        If `spec` is a ``Requirement`` object or a string containing a 
        project/version requirement spec, this method returns the location of 
        a matching distribution (possibly after downloading it to `tmpdir`). 
        If `spec` is a locally existing file or directory name, it is simply 
        returned unchanged.  If `spec` is a URL, it is downloaded to a subpath 
        of `tmpdir`, and the local filename is returned.  Various errors may be 
        raised if a problem occurs during downloading. 
        &quot;&quot;&quot;</span><span class="s1"> 
        </span><span class="s2">if not </span><span class="s1">isinstance(spec</span><span class="s2">, </span><span class="s1">Requirement): 
            scheme = URL_SCHEME(spec) 
            </span><span class="s2">if </span><span class="s1">scheme: 
                </span><span class="s4"># It's a url, download it to tmpdir</span><span class="s1"> 
                found = self._download_url(scheme.group(</span><span class="s5">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">spec</span><span class="s2">, </span><span class="s1">tmpdir) 
                base</span><span class="s2">, </span><span class="s1">fragment = egg_info_for_url(spec) 
                </span><span class="s2">if </span><span class="s1">base.endswith(</span><span class="s3">'.py'</span><span class="s1">): 
                    found = self.gen_setup(found</span><span class="s2">, </span><span class="s1">fragment</span><span class="s2">, </span><span class="s1">tmpdir) 
                </span><span class="s2">return </span><span class="s1">found 
            </span><span class="s2">elif </span><span class="s1">os.path.exists(spec): 
                </span><span class="s4"># Existing file or directory, just return it</span><span class="s1"> 
                </span><span class="s2">return </span><span class="s1">spec 
            </span><span class="s2">else</span><span class="s1">: 
                spec = parse_requirement_arg(spec) 
        </span><span class="s2">return </span><span class="s1">getattr(self.fetch_distribution(spec</span><span class="s2">, </span><span class="s1">tmpdir)</span><span class="s2">, </span><span class="s3">'location'</span><span class="s2">, None</span><span class="s1">) 
 
    </span><span class="s2">def </span><span class="s1">fetch_distribution( 
            self</span><span class="s2">, </span><span class="s1">requirement</span><span class="s2">, </span><span class="s1">tmpdir</span><span class="s2">, </span><span class="s1">force_scan=</span><span class="s2">False, </span><span class="s1">source=</span><span class="s2">False,</span><span class="s1"> 
            develop_ok=</span><span class="s2">False, </span><span class="s1">local_index=</span><span class="s2">None</span><span class="s1">): 
        </span><span class="s0">&quot;&quot;&quot;Obtain a distribution suitable for fulfilling `requirement` 
 
        `requirement` must be a ``pkg_resources.Requirement`` instance. 
        If necessary, or if the `force_scan` flag is set, the requirement is 
        searched for in the (online) package index as well as the locally 
        installed packages.  If a distribution matching `requirement` is found, 
        the returned distribution's ``location`` is the value you would have 
        gotten from calling the ``download()`` method with the matching 
        distribution's URL or filename.  If no matching distribution is found, 
        ``None`` is returned. 
 
        If the `source` flag is set, only source distributions and source 
        checkout links will be considered.  Unless the `develop_ok` flag is 
        set, development and system eggs (i.e., those using the ``.egg-info`` 
        format) will be ignored. 
        &quot;&quot;&quot;</span><span class="s1"> 
        </span><span class="s4"># process a Requirement</span><span class="s1"> 
        self.info(</span><span class="s3">&quot;Searching for %s&quot;</span><span class="s2">, </span><span class="s1">requirement) 
        skipped = {} 
        dist = </span><span class="s2">None</span><span class="s1"> 
 
        </span><span class="s2">def </span><span class="s1">find(req</span><span class="s2">, </span><span class="s1">env=</span><span class="s2">None</span><span class="s1">): 
            </span><span class="s2">if </span><span class="s1">env </span><span class="s2">is None</span><span class="s1">: 
                env = self 
            </span><span class="s4"># Find a matching distribution; may be called more than once</span><span class="s1"> 
 
            </span><span class="s2">for </span><span class="s1">dist </span><span class="s2">in </span><span class="s1">env[req.key]: 
 
                </span><span class="s2">if </span><span class="s1">dist.precedence == DEVELOP_DIST </span><span class="s2">and not </span><span class="s1">develop_ok: 
                    </span><span class="s2">if </span><span class="s1">dist </span><span class="s2">not in </span><span class="s1">skipped: 
                        self.warn( 
                            </span><span class="s3">&quot;Skipping development or system egg: %s&quot;</span><span class="s2">, </span><span class="s1">dist</span><span class="s2">,</span><span class="s1"> 
                        ) 
                        skipped[dist] = </span><span class="s5">1</span><span class="s1"> 
                    </span><span class="s2">continue</span><span class="s1"> 
 
                test = ( 
                    dist </span><span class="s2">in </span><span class="s1">req 
                    </span><span class="s2">and </span><span class="s1">(dist.precedence &lt;= SOURCE_DIST </span><span class="s2">or not </span><span class="s1">source) 
                ) 
                </span><span class="s2">if </span><span class="s1">test: 
                    loc = self.download(dist.location</span><span class="s2">, </span><span class="s1">tmpdir) 
                    dist.download_location = loc 
                    </span><span class="s2">if </span><span class="s1">os.path.exists(dist.download_location): 
                        </span><span class="s2">return </span><span class="s1">dist 
 
        </span><span class="s2">if </span><span class="s1">force_scan: 
            self.prescan() 
            self.find_packages(requirement) 
            dist = find(requirement) 
 
        </span><span class="s2">if not </span><span class="s1">dist </span><span class="s2">and </span><span class="s1">local_index </span><span class="s2">is not None</span><span class="s1">: 
            dist = find(requirement</span><span class="s2">, </span><span class="s1">local_index) 
 
        </span><span class="s2">if </span><span class="s1">dist </span><span class="s2">is None</span><span class="s1">: 
            </span><span class="s2">if </span><span class="s1">self.to_scan </span><span class="s2">is not None</span><span class="s1">: 
                self.prescan() 
            dist = find(requirement) 
 
        </span><span class="s2">if </span><span class="s1">dist </span><span class="s2">is None and not </span><span class="s1">force_scan: 
            self.find_packages(requirement) 
            dist = find(requirement) 
 
        </span><span class="s2">if </span><span class="s1">dist </span><span class="s2">is None</span><span class="s1">: 
            self.warn( 
                </span><span class="s3">&quot;No local packages or working download links found for %s%s&quot;</span><span class="s2">,</span><span class="s1"> 
                (source </span><span class="s2">and </span><span class="s3">&quot;a source distribution of &quot; </span><span class="s2">or </span><span class="s3">&quot;&quot;</span><span class="s1">)</span><span class="s2">,</span><span class="s1"> 
                requirement</span><span class="s2">,</span><span class="s1"> 
            ) 
        </span><span class="s2">else</span><span class="s1">: 
            self.info(</span><span class="s3">&quot;Best match: %s&quot;</span><span class="s2">, </span><span class="s1">dist) 
            </span><span class="s2">return </span><span class="s1">dist.clone(location=dist.download_location) 
 
    </span><span class="s2">def </span><span class="s1">fetch(self</span><span class="s2">, </span><span class="s1">requirement</span><span class="s2">, </span><span class="s1">tmpdir</span><span class="s2">, </span><span class="s1">force_scan=</span><span class="s2">False, </span><span class="s1">source=</span><span class="s2">False</span><span class="s1">): 
        </span><span class="s0">&quot;&quot;&quot;Obtain a file suitable for fulfilling `requirement` 
 
        DEPRECATED; use the ``fetch_distribution()`` method now instead.  For 
        backward compatibility, this routine is identical but returns the 
        ``location`` of the downloaded distribution instead of a distribution 
        object. 
        &quot;&quot;&quot;</span><span class="s1"> 
        dist = self.fetch_distribution(requirement</span><span class="s2">, </span><span class="s1">tmpdir</span><span class="s2">, </span><span class="s1">force_scan</span><span class="s2">, </span><span class="s1">source) 
        </span><span class="s2">if </span><span class="s1">dist </span><span class="s2">is not None</span><span class="s1">: 
            </span><span class="s2">return </span><span class="s1">dist.location 
        </span><span class="s2">return None</span><span class="s1"> 
 
    </span><span class="s2">def </span><span class="s1">gen_setup(self</span><span class="s2">, </span><span class="s1">filename</span><span class="s2">, </span><span class="s1">fragment</span><span class="s2">, </span><span class="s1">tmpdir): 
        match = EGG_FRAGMENT.match(fragment) 
        dists = match </span><span class="s2">and </span><span class="s1">[ 
            d </span><span class="s2">for </span><span class="s1">d </span><span class="s2">in</span><span class="s1"> 
            interpret_distro_name(filename</span><span class="s2">, </span><span class="s1">match.group(</span><span class="s5">1</span><span class="s1">)</span><span class="s2">, None</span><span class="s1">) </span><span class="s2">if </span><span class="s1">d.version 
        ] </span><span class="s2">or </span><span class="s1">[] 
 
        </span><span class="s2">if </span><span class="s1">len(dists) == </span><span class="s5">1</span><span class="s1">:  </span><span class="s4"># unambiguous ``#egg`` fragment</span><span class="s1"> 
            basename = os.path.basename(filename) 
 
            </span><span class="s4"># Make sure the file has been downloaded to the temp dir.</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">os.path.dirname(filename) != tmpdir: 
                dst = os.path.join(tmpdir</span><span class="s2">, </span><span class="s1">basename) 
                </span><span class="s2">from </span><span class="s1">setuptools.command.easy_install </span><span class="s2">import </span><span class="s1">samefile 
                </span><span class="s2">if not </span><span class="s1">samefile(filename</span><span class="s2">, </span><span class="s1">dst): 
                    shutil.copy2(filename</span><span class="s2">, </span><span class="s1">dst) 
                    filename = dst 
 
            </span><span class="s2">with </span><span class="s1">open(os.path.join(tmpdir</span><span class="s2">, </span><span class="s3">'setup.py'</span><span class="s1">)</span><span class="s2">, </span><span class="s3">'w'</span><span class="s1">) </span><span class="s2">as </span><span class="s1">file: 
                file.write( 
                    </span><span class="s3">&quot;from setuptools import setup</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1"> 
                    </span><span class="s3">&quot;setup(name=%r, version=%r, py_modules=[%r])</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1"> 
                    % ( 
                        dists[</span><span class="s5">0</span><span class="s1">].project_name</span><span class="s2">, </span><span class="s1">dists[</span><span class="s5">0</span><span class="s1">].version</span><span class="s2">,</span><span class="s1"> 
                        os.path.splitext(basename)[</span><span class="s5">0</span><span class="s1">] 
                    ) 
                ) 
            </span><span class="s2">return </span><span class="s1">filename 
 
        </span><span class="s2">elif </span><span class="s1">match: 
            </span><span class="s2">raise </span><span class="s1">DistutilsError( 
                </span><span class="s3">&quot;Can't unambiguously interpret project/version identifier %r; &quot;</span><span class="s1"> 
                </span><span class="s3">&quot;any dashes in the name or version should be escaped using &quot;</span><span class="s1"> 
                </span><span class="s3">&quot;underscores. %r&quot; </span><span class="s1">% (fragment</span><span class="s2">, </span><span class="s1">dists) 
            ) 
        </span><span class="s2">else</span><span class="s1">: 
            </span><span class="s2">raise </span><span class="s1">DistutilsError( 
                </span><span class="s3">&quot;Can't process plain .py files without an '#egg=name-version'&quot;</span><span class="s1"> 
                </span><span class="s3">&quot; suffix to enable automatic setup script generation.&quot;</span><span class="s1"> 
            ) 
 
    dl_blocksize = </span><span class="s5">8192</span><span class="s1"> 
 
    </span><span class="s2">def </span><span class="s1">_download_to(self</span><span class="s2">, </span><span class="s1">url</span><span class="s2">, </span><span class="s1">filename): 
        self.info(</span><span class="s3">&quot;Downloading %s&quot;</span><span class="s2">, </span><span class="s1">url) 
        </span><span class="s4"># Download the file</span><span class="s1"> 
        fp = </span><span class="s2">None</span><span class="s1"> 
        </span><span class="s2">try</span><span class="s1">: 
            checker = HashChecker.from_url(url) 
            fp = self.open_url(url) 
            </span><span class="s2">if </span><span class="s1">isinstance(fp</span><span class="s2">, </span><span class="s1">urllib.error.HTTPError): 
                </span><span class="s2">raise </span><span class="s1">DistutilsError( 
                    </span><span class="s3">&quot;Can't download %s: %s %s&quot; </span><span class="s1">% (url</span><span class="s2">, </span><span class="s1">fp.code</span><span class="s2">, </span><span class="s1">fp.msg) 
                ) 
            headers = fp.info() 
            blocknum = </span><span class="s5">0</span><span class="s1"> 
            bs = self.dl_blocksize 
            size = -</span><span class="s5">1</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s3">&quot;content-length&quot; </span><span class="s2">in </span><span class="s1">headers: 
                </span><span class="s4"># Some servers return multiple Content-Length headers :(</span><span class="s1"> 
                sizes = get_all_headers(headers</span><span class="s2">, </span><span class="s3">'Content-Length'</span><span class="s1">) 
                size = max(map(int</span><span class="s2">, </span><span class="s1">sizes)) 
                self.reporthook(url</span><span class="s2">, </span><span class="s1">filename</span><span class="s2">, </span><span class="s1">blocknum</span><span class="s2">, </span><span class="s1">bs</span><span class="s2">, </span><span class="s1">size) 
            </span><span class="s2">with </span><span class="s1">open(filename</span><span class="s2">, </span><span class="s3">'wb'</span><span class="s1">) </span><span class="s2">as </span><span class="s1">tfp: 
                </span><span class="s2">while True</span><span class="s1">: 
                    block = fp.read(bs) 
                    </span><span class="s2">if </span><span class="s1">block: 
                        checker.feed(block) 
                        tfp.write(block) 
                        blocknum += </span><span class="s5">1</span><span class="s1"> 
                        self.reporthook(url</span><span class="s2">, </span><span class="s1">filename</span><span class="s2">, </span><span class="s1">blocknum</span><span class="s2">, </span><span class="s1">bs</span><span class="s2">, </span><span class="s1">size) 
                    </span><span class="s2">else</span><span class="s1">: 
                        </span><span class="s2">break</span><span class="s1"> 
                self.check_hash(checker</span><span class="s2">, </span><span class="s1">filename</span><span class="s2">, </span><span class="s1">tfp) 
            </span><span class="s2">return </span><span class="s1">headers 
        </span><span class="s2">finally</span><span class="s1">: 
            </span><span class="s2">if </span><span class="s1">fp: 
                fp.close() 
 
    </span><span class="s2">def </span><span class="s1">reporthook(self</span><span class="s2">, </span><span class="s1">url</span><span class="s2">, </span><span class="s1">filename</span><span class="s2">, </span><span class="s1">blocknum</span><span class="s2">, </span><span class="s1">blksize</span><span class="s2">, </span><span class="s1">size): 
        </span><span class="s2">pass  </span><span class="s4"># no-op</span><span class="s1"> 
 
    </span><span class="s2">def </span><span class="s1">open_url(self</span><span class="s2">, </span><span class="s1">url</span><span class="s2">, </span><span class="s1">warning=</span><span class="s2">None</span><span class="s1">): 
        </span><span class="s2">if </span><span class="s1">url.startswith(</span><span class="s3">'file:'</span><span class="s1">): 
            </span><span class="s2">return </span><span class="s1">local_open(url) 
        </span><span class="s2">try</span><span class="s1">: 
            </span><span class="s2">return </span><span class="s1">open_with_auth(url</span><span class="s2">, </span><span class="s1">self.opener) 
        </span><span class="s2">except </span><span class="s1">(ValueError</span><span class="s2">, </span><span class="s1">http_client.InvalidURL) </span><span class="s2">as </span><span class="s1">v: 
            msg = </span><span class="s3">' '</span><span class="s1">.join([str(arg) </span><span class="s2">for </span><span class="s1">arg </span><span class="s2">in </span><span class="s1">v.args]) 
            </span><span class="s2">if </span><span class="s1">warning: 
                self.warn(warning</span><span class="s2">, </span><span class="s1">msg) 
            </span><span class="s2">else</span><span class="s1">: 
                </span><span class="s2">raise </span><span class="s1">DistutilsError(</span><span class="s3">'%s %s' </span><span class="s1">% (url</span><span class="s2">, </span><span class="s1">msg)) 
        </span><span class="s2">except </span><span class="s1">urllib.error.HTTPError </span><span class="s2">as </span><span class="s1">v: 
            </span><span class="s2">return </span><span class="s1">v 
        </span><span class="s2">except </span><span class="s1">urllib.error.URLError </span><span class="s2">as </span><span class="s1">v: 
            </span><span class="s2">if </span><span class="s1">warning: 
                self.warn(warning</span><span class="s2">, </span><span class="s1">v.reason) 
            </span><span class="s2">else</span><span class="s1">: 
                </span><span class="s2">raise </span><span class="s1">DistutilsError(</span><span class="s3">&quot;Download error for %s: %s&quot;</span><span class="s1"> 
                                     % (url</span><span class="s2">, </span><span class="s1">v.reason)) 
        </span><span class="s2">except </span><span class="s1">http_client.BadStatusLine </span><span class="s2">as </span><span class="s1">v: 
            </span><span class="s2">if </span><span class="s1">warning: 
                self.warn(warning</span><span class="s2">, </span><span class="s1">v.line) 
            </span><span class="s2">else</span><span class="s1">: 
                </span><span class="s2">raise </span><span class="s1">DistutilsError( 
                    </span><span class="s3">'%s returned a bad status line. The server might be '</span><span class="s1"> 
                    </span><span class="s3">'down, %s' </span><span class="s1">% 
                    (url</span><span class="s2">, </span><span class="s1">v.line) 
                ) 
        </span><span class="s2">except </span><span class="s1">(http_client.HTTPException</span><span class="s2">, </span><span class="s1">socket.error) </span><span class="s2">as </span><span class="s1">v: 
            </span><span class="s2">if </span><span class="s1">warning: 
                self.warn(warning</span><span class="s2">, </span><span class="s1">v) 
            </span><span class="s2">else</span><span class="s1">: 
                </span><span class="s2">raise </span><span class="s1">DistutilsError(</span><span class="s3">&quot;Download error for %s: %s&quot;</span><span class="s1"> 
                                     % (url</span><span class="s2">, </span><span class="s1">v)) 
 
    </span><span class="s2">def </span><span class="s1">_download_url(self</span><span class="s2">, </span><span class="s1">scheme</span><span class="s2">, </span><span class="s1">url</span><span class="s2">, </span><span class="s1">tmpdir): 
        </span><span class="s4"># Determine download filename</span><span class="s1"> 
        </span><span class="s4">#</span><span class="s1"> 
        name</span><span class="s2">, </span><span class="s1">fragment = egg_info_for_url(url) 
        </span><span class="s2">if </span><span class="s1">name: 
            </span><span class="s2">while </span><span class="s3">'..' </span><span class="s2">in </span><span class="s1">name: 
                name = name.replace(</span><span class="s3">'..'</span><span class="s2">, </span><span class="s3">'.'</span><span class="s1">).replace(</span><span class="s3">'</span><span class="s2">\\</span><span class="s3">'</span><span class="s2">, </span><span class="s3">'_'</span><span class="s1">) 
        </span><span class="s2">else</span><span class="s1">: 
            name = </span><span class="s3">&quot;__downloaded__&quot;  </span><span class="s4"># default if URL has no path contents</span><span class="s1"> 
 
        </span><span class="s2">if </span><span class="s1">name.endswith(</span><span class="s3">'.egg.zip'</span><span class="s1">): 
            name = name[:-</span><span class="s5">4</span><span class="s1">]  </span><span class="s4"># strip the extra .zip before download</span><span class="s1"> 
 
        filename = os.path.join(tmpdir</span><span class="s2">, </span><span class="s1">name) 
 
        </span><span class="s4"># Download the file</span><span class="s1"> 
        </span><span class="s4">#</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">scheme == </span><span class="s3">'svn' </span><span class="s2">or </span><span class="s1">scheme.startswith(</span><span class="s3">'svn+'</span><span class="s1">): 
            </span><span class="s2">return </span><span class="s1">self._download_svn(url</span><span class="s2">, </span><span class="s1">filename) 
        </span><span class="s2">elif </span><span class="s1">scheme == </span><span class="s3">'git' </span><span class="s2">or </span><span class="s1">scheme.startswith(</span><span class="s3">'git+'</span><span class="s1">): 
            </span><span class="s2">return </span><span class="s1">self._download_git(url</span><span class="s2">, </span><span class="s1">filename) 
        </span><span class="s2">elif </span><span class="s1">scheme.startswith(</span><span class="s3">'hg+'</span><span class="s1">): 
            </span><span class="s2">return </span><span class="s1">self._download_hg(url</span><span class="s2">, </span><span class="s1">filename) 
        </span><span class="s2">elif </span><span class="s1">scheme == </span><span class="s3">'file'</span><span class="s1">: 
            </span><span class="s2">return </span><span class="s1">urllib.request.url2pathname(urllib.parse.urlparse(url)[</span><span class="s5">2</span><span class="s1">]) 
        </span><span class="s2">else</span><span class="s1">: 
            self.url_ok(url</span><span class="s2">, True</span><span class="s1">)  </span><span class="s4"># raises error if not allowed</span><span class="s1"> 
            </span><span class="s2">return </span><span class="s1">self._attempt_download(url</span><span class="s2">, </span><span class="s1">filename) 
 
    </span><span class="s2">def </span><span class="s1">scan_url(self</span><span class="s2">, </span><span class="s1">url): 
        self.process_url(url</span><span class="s2">, True</span><span class="s1">) 
 
    </span><span class="s2">def </span><span class="s1">_attempt_download(self</span><span class="s2">, </span><span class="s1">url</span><span class="s2">, </span><span class="s1">filename): 
        headers = self._download_to(url</span><span class="s2">, </span><span class="s1">filename) 
        </span><span class="s2">if </span><span class="s3">'html' </span><span class="s2">in </span><span class="s1">headers.get(</span><span class="s3">'content-type'</span><span class="s2">, </span><span class="s3">''</span><span class="s1">).lower(): 
            </span><span class="s2">return </span><span class="s1">self._download_html(url</span><span class="s2">, </span><span class="s1">headers</span><span class="s2">, </span><span class="s1">filename) 
        </span><span class="s2">else</span><span class="s1">: 
            </span><span class="s2">return </span><span class="s1">filename 
 
    </span><span class="s2">def </span><span class="s1">_download_html(self</span><span class="s2">, </span><span class="s1">url</span><span class="s2">, </span><span class="s1">headers</span><span class="s2">, </span><span class="s1">filename): 
        file = open(filename) 
        </span><span class="s2">for </span><span class="s1">line </span><span class="s2">in </span><span class="s1">file: 
            </span><span class="s2">if </span><span class="s1">line.strip(): 
                </span><span class="s4"># Check for a subversion index page</span><span class="s1"> 
                </span><span class="s2">if </span><span class="s1">re.search(</span><span class="s3">r'&lt;title&gt;([^- ]+ - )?Revision \d+:'</span><span class="s2">, </span><span class="s1">line): 
                    </span><span class="s4"># it's a subversion index page:</span><span class="s1"> 
                    file.close() 
                    os.unlink(filename) 
                    </span><span class="s2">return </span><span class="s1">self._download_svn(url</span><span class="s2">, </span><span class="s1">filename) 
                </span><span class="s2">break  </span><span class="s4"># not an index page</span><span class="s1"> 
        file.close() 
        os.unlink(filename) 
        </span><span class="s2">raise </span><span class="s1">DistutilsError(</span><span class="s3">&quot;Unexpected HTML page found at &quot; </span><span class="s1">+ url) 
 
    </span><span class="s2">def </span><span class="s1">_download_svn(self</span><span class="s2">, </span><span class="s1">url</span><span class="s2">, </span><span class="s1">filename): 
        url = url.split(</span><span class="s3">'#'</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)[</span><span class="s5">0</span><span class="s1">]  </span><span class="s4"># remove any fragment for svn's sake</span><span class="s1"> 
        creds = </span><span class="s3">''</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">url.lower().startswith(</span><span class="s3">'svn:'</span><span class="s1">) </span><span class="s2">and </span><span class="s3">'@' </span><span class="s2">in </span><span class="s1">url: 
            scheme</span><span class="s2">, </span><span class="s1">netloc</span><span class="s2">, </span><span class="s1">path</span><span class="s2">, </span><span class="s1">p</span><span class="s2">, </span><span class="s1">q</span><span class="s2">, </span><span class="s1">f = urllib.parse.urlparse(url) 
            </span><span class="s2">if not </span><span class="s1">netloc </span><span class="s2">and </span><span class="s1">path.startswith(</span><span class="s3">'//'</span><span class="s1">) </span><span class="s2">and </span><span class="s3">'/' </span><span class="s2">in </span><span class="s1">path[</span><span class="s5">2</span><span class="s1">:]: 
                netloc</span><span class="s2">, </span><span class="s1">path = path[</span><span class="s5">2</span><span class="s1">:].split(</span><span class="s3">'/'</span><span class="s2">, </span><span class="s5">1</span><span class="s1">) 
                auth</span><span class="s2">, </span><span class="s1">host = splituser(netloc) 
                </span><span class="s2">if </span><span class="s1">auth: 
                    </span><span class="s2">if </span><span class="s3">':' </span><span class="s2">in </span><span class="s1">auth: 
                        user</span><span class="s2">, </span><span class="s1">pw = auth.split(</span><span class="s3">':'</span><span class="s2">, </span><span class="s5">1</span><span class="s1">) 
                        creds = </span><span class="s3">&quot; --username=%s --password=%s&quot; </span><span class="s1">% (user</span><span class="s2">, </span><span class="s1">pw) 
                    </span><span class="s2">else</span><span class="s1">: 
                        creds = </span><span class="s3">&quot; --username=&quot; </span><span class="s1">+ auth 
                    netloc = host 
                    parts = scheme</span><span class="s2">, </span><span class="s1">netloc</span><span class="s2">, </span><span class="s1">url</span><span class="s2">, </span><span class="s1">p</span><span class="s2">, </span><span class="s1">q</span><span class="s2">, </span><span class="s1">f 
                    url = urllib.parse.urlunparse(parts) 
        self.info(</span><span class="s3">&quot;Doing subversion checkout from %s to %s&quot;</span><span class="s2">, </span><span class="s1">url</span><span class="s2">, </span><span class="s1">filename) 
        os.system(</span><span class="s3">&quot;svn checkout%s -q %s %s&quot; </span><span class="s1">% (creds</span><span class="s2">, </span><span class="s1">url</span><span class="s2">, </span><span class="s1">filename)) 
        </span><span class="s2">return </span><span class="s1">filename 
 
    @staticmethod 
    </span><span class="s2">def </span><span class="s1">_vcs_split_rev_from_url(url</span><span class="s2">, </span><span class="s1">pop_prefix=</span><span class="s2">False</span><span class="s1">): 
        scheme</span><span class="s2">, </span><span class="s1">netloc</span><span class="s2">, </span><span class="s1">path</span><span class="s2">, </span><span class="s1">query</span><span class="s2">, </span><span class="s1">frag = urllib.parse.urlsplit(url) 
 
        scheme = scheme.split(</span><span class="s3">'+'</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)[-</span><span class="s5">1</span><span class="s1">] 
 
        </span><span class="s4"># Some fragment identification fails</span><span class="s1"> 
        path = path.split(</span><span class="s3">'#'</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)[</span><span class="s5">0</span><span class="s1">] 
 
        rev = </span><span class="s2">None</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s3">'@' </span><span class="s2">in </span><span class="s1">path: 
            path</span><span class="s2">, </span><span class="s1">rev = path.rsplit(</span><span class="s3">'@'</span><span class="s2">, </span><span class="s5">1</span><span class="s1">) 
 
        </span><span class="s4"># Also, discard fragment</span><span class="s1"> 
        url = urllib.parse.urlunsplit((scheme</span><span class="s2">, </span><span class="s1">netloc</span><span class="s2">, </span><span class="s1">path</span><span class="s2">, </span><span class="s1">query</span><span class="s2">, </span><span class="s3">''</span><span class="s1">)) 
 
        </span><span class="s2">return </span><span class="s1">url</span><span class="s2">, </span><span class="s1">rev 
 
    </span><span class="s2">def </span><span class="s1">_download_git(self</span><span class="s2">, </span><span class="s1">url</span><span class="s2">, </span><span class="s1">filename): 
        filename = filename.split(</span><span class="s3">'#'</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)[</span><span class="s5">0</span><span class="s1">] 
        url</span><span class="s2">, </span><span class="s1">rev = self._vcs_split_rev_from_url(url</span><span class="s2">, </span><span class="s1">pop_prefix=</span><span class="s2">True</span><span class="s1">) 
 
        self.info(</span><span class="s3">&quot;Doing git clone from %s to %s&quot;</span><span class="s2">, </span><span class="s1">url</span><span class="s2">, </span><span class="s1">filename) 
        os.system(</span><span class="s3">&quot;git clone --quiet %s %s&quot; </span><span class="s1">% (url</span><span class="s2">, </span><span class="s1">filename)) 
 
        </span><span class="s2">if </span><span class="s1">rev </span><span class="s2">is not None</span><span class="s1">: 
            self.info(</span><span class="s3">&quot;Checking out %s&quot;</span><span class="s2">, </span><span class="s1">rev) 
            os.system(</span><span class="s3">&quot;(cd %s &amp;&amp; git checkout --quiet %s)&quot; </span><span class="s1">% ( 
                filename</span><span class="s2">,</span><span class="s1"> 
                rev</span><span class="s2">,</span><span class="s1"> 
            )) 
 
        </span><span class="s2">return </span><span class="s1">filename 
 
    </span><span class="s2">def </span><span class="s1">_download_hg(self</span><span class="s2">, </span><span class="s1">url</span><span class="s2">, </span><span class="s1">filename): 
        filename = filename.split(</span><span class="s3">'#'</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)[</span><span class="s5">0</span><span class="s1">] 
        url</span><span class="s2">, </span><span class="s1">rev = self._vcs_split_rev_from_url(url</span><span class="s2">, </span><span class="s1">pop_prefix=</span><span class="s2">True</span><span class="s1">) 
 
        self.info(</span><span class="s3">&quot;Doing hg clone from %s to %s&quot;</span><span class="s2">, </span><span class="s1">url</span><span class="s2">, </span><span class="s1">filename) 
        os.system(</span><span class="s3">&quot;hg clone --quiet %s %s&quot; </span><span class="s1">% (url</span><span class="s2">, </span><span class="s1">filename)) 
 
        </span><span class="s2">if </span><span class="s1">rev </span><span class="s2">is not None</span><span class="s1">: 
            self.info(</span><span class="s3">&quot;Updating to %s&quot;</span><span class="s2">, </span><span class="s1">rev) 
            os.system(</span><span class="s3">&quot;(cd %s &amp;&amp; hg up -C -r %s -q)&quot; </span><span class="s1">% ( 
                filename</span><span class="s2">,</span><span class="s1"> 
                rev</span><span class="s2">,</span><span class="s1"> 
            )) 
 
        </span><span class="s2">return </span><span class="s1">filename 
 
    </span><span class="s2">def </span><span class="s1">debug(self</span><span class="s2">, </span><span class="s1">msg</span><span class="s2">, </span><span class="s1">*args): 
        log.debug(msg</span><span class="s2">, </span><span class="s1">*args) 
 
    </span><span class="s2">def </span><span class="s1">info(self</span><span class="s2">, </span><span class="s1">msg</span><span class="s2">, </span><span class="s1">*args): 
        log.info(msg</span><span class="s2">, </span><span class="s1">*args) 
 
    </span><span class="s2">def </span><span class="s1">warn(self</span><span class="s2">, </span><span class="s1">msg</span><span class="s2">, </span><span class="s1">*args): 
        log.warn(msg</span><span class="s2">, </span><span class="s1">*args) 
 
 
</span><span class="s4"># This pattern matches a character entity reference (a decimal numeric</span><span class="s1"> 
</span><span class="s4"># references, a hexadecimal numeric reference, or a named reference).</span><span class="s1"> 
entity_sub = re.compile(</span><span class="s3">r'&amp;(#(\d+|x[\da-fA-F]+)|[\w.:-]+);?'</span><span class="s1">).sub 
 
 
</span><span class="s2">def </span><span class="s1">uchr(c): 
    </span><span class="s2">if not </span><span class="s1">isinstance(c</span><span class="s2">, </span><span class="s1">int): 
        </span><span class="s2">return </span><span class="s1">c 
    </span><span class="s2">if </span><span class="s1">c &gt; </span><span class="s5">255</span><span class="s1">: 
        </span><span class="s2">return </span><span class="s1">six.unichr(c) 
    </span><span class="s2">return </span><span class="s1">chr(c) 
 
 
</span><span class="s2">def </span><span class="s1">decode_entity(match): 
    what = match.group(</span><span class="s5">1</span><span class="s1">) 
    </span><span class="s2">if </span><span class="s1">what.startswith(</span><span class="s3">'#x'</span><span class="s1">): 
        what = int(what[</span><span class="s5">2</span><span class="s1">:]</span><span class="s2">, </span><span class="s5">16</span><span class="s1">) 
    </span><span class="s2">elif </span><span class="s1">what.startswith(</span><span class="s3">'#'</span><span class="s1">): 
        what = int(what[</span><span class="s5">1</span><span class="s1">:]) 
    </span><span class="s2">else</span><span class="s1">: 
        what = six.moves.html_entities.name2codepoint.get(what</span><span class="s2">, </span><span class="s1">match.group(</span><span class="s5">0</span><span class="s1">)) 
    </span><span class="s2">return </span><span class="s1">uchr(what) 
 
 
</span><span class="s2">def </span><span class="s1">htmldecode(text): 
    </span><span class="s0">&quot;&quot;&quot;Decode HTML entities in the given text.&quot;&quot;&quot;</span><span class="s1"> 
    </span><span class="s2">return </span><span class="s1">entity_sub(decode_entity</span><span class="s2">, </span><span class="s1">text) 
 
 
</span><span class="s2">def </span><span class="s1">socket_timeout(timeout=</span><span class="s5">15</span><span class="s1">): 
    </span><span class="s2">def </span><span class="s1">_socket_timeout(func): 
        </span><span class="s2">def </span><span class="s1">_socket_timeout(*args</span><span class="s2">, </span><span class="s1">**kwargs): 
            old_timeout = socket.getdefaulttimeout() 
            socket.setdefaulttimeout(timeout) 
            </span><span class="s2">try</span><span class="s1">: 
                </span><span class="s2">return </span><span class="s1">func(*args</span><span class="s2">, </span><span class="s1">**kwargs) 
            </span><span class="s2">finally</span><span class="s1">: 
                socket.setdefaulttimeout(old_timeout) 
 
        </span><span class="s2">return </span><span class="s1">_socket_timeout 
 
    </span><span class="s2">return </span><span class="s1">_socket_timeout 
 
 
</span><span class="s2">def </span><span class="s1">_encode_auth(auth): 
    </span><span class="s0">&quot;&quot;&quot; 
    A function compatible with Python 2.3-3.3 that will encode 
    auth from a URL suitable for an HTTP header. 
    &gt;&gt;&gt; str(_encode_auth('username%3Apassword')) 
    'dXNlcm5hbWU6cGFzc3dvcmQ=' 
 
    Long auth strings should not cause a newline to be inserted. 
    &gt;&gt;&gt; long_auth = 'username:' + 'password'*10 
    &gt;&gt;&gt; chr(10) in str(_encode_auth(long_auth)) 
    False 
    &quot;&quot;&quot;</span><span class="s1"> 
    auth_s = urllib.parse.unquote(auth) 
    </span><span class="s4"># convert to bytes</span><span class="s1"> 
    auth_bytes = auth_s.encode() 
    </span><span class="s4"># use the legacy interface for Python 2.3 support</span><span class="s1"> 
    encoded_bytes = base64.encodestring(auth_bytes) 
    </span><span class="s4"># convert back to a string</span><span class="s1"> 
    encoded = encoded_bytes.decode() 
    </span><span class="s4"># strip the trailing carriage return</span><span class="s1"> 
    </span><span class="s2">return </span><span class="s1">encoded.replace(</span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s2">, </span><span class="s3">''</span><span class="s1">) 
 
 
</span><span class="s2">class </span><span class="s1">Credential(object): 
    </span><span class="s0">&quot;&quot;&quot; 
    A username/password pair. Use like a namedtuple. 
    &quot;&quot;&quot;</span><span class="s1"> 
 
    </span><span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">username</span><span class="s2">, </span><span class="s1">password): 
        self.username = username 
        self.password = password 
 
    </span><span class="s2">def </span><span class="s1">__iter__(self): 
        </span><span class="s2">yield </span><span class="s1">self.username 
        </span><span class="s2">yield </span><span class="s1">self.password 
 
    </span><span class="s2">def </span><span class="s1">__str__(self): 
        </span><span class="s2">return </span><span class="s3">'%(username)s:%(password)s' </span><span class="s1">% vars(self) 
 
 
</span><span class="s2">class </span><span class="s1">PyPIConfig(configparser.RawConfigParser): 
    </span><span class="s2">def </span><span class="s1">__init__(self): 
        </span><span class="s0">&quot;&quot;&quot; 
        Load from ~/.pypirc 
        &quot;&quot;&quot;</span><span class="s1"> 
        defaults = dict.fromkeys([</span><span class="s3">'username'</span><span class="s2">, </span><span class="s3">'password'</span><span class="s2">, </span><span class="s3">'repository'</span><span class="s1">]</span><span class="s2">, </span><span class="s3">''</span><span class="s1">) 
        configparser.RawConfigParser.__init__(self</span><span class="s2">, </span><span class="s1">defaults) 
 
        rc = os.path.join(os.path.expanduser(</span><span class="s3">'~'</span><span class="s1">)</span><span class="s2">, </span><span class="s3">'.pypirc'</span><span class="s1">) 
        </span><span class="s2">if </span><span class="s1">os.path.exists(rc): 
            self.read(rc) 
 
    @property 
    </span><span class="s2">def </span><span class="s1">creds_by_repository(self): 
        sections_with_repositories = [ 
            section </span><span class="s2">for </span><span class="s1">section </span><span class="s2">in </span><span class="s1">self.sections() 
            </span><span class="s2">if </span><span class="s1">self.get(section</span><span class="s2">, </span><span class="s3">'repository'</span><span class="s1">).strip() 
        ] 
 
        </span><span class="s2">return </span><span class="s1">dict(map(self._get_repo_cred</span><span class="s2">, </span><span class="s1">sections_with_repositories)) 
 
    </span><span class="s2">def </span><span class="s1">_get_repo_cred(self</span><span class="s2">, </span><span class="s1">section): 
        repo = self.get(section</span><span class="s2">, </span><span class="s3">'repository'</span><span class="s1">).strip() 
        </span><span class="s2">return </span><span class="s1">repo</span><span class="s2">, </span><span class="s1">Credential( 
            self.get(section</span><span class="s2">, </span><span class="s3">'username'</span><span class="s1">).strip()</span><span class="s2">,</span><span class="s1"> 
            self.get(section</span><span class="s2">, </span><span class="s3">'password'</span><span class="s1">).strip()</span><span class="s2">,</span><span class="s1"> 
        ) 
 
    </span><span class="s2">def </span><span class="s1">find_credential(self</span><span class="s2">, </span><span class="s1">url): 
        </span><span class="s0">&quot;&quot;&quot; 
        If the URL indicated appears to be a repository defined in this 
        config, return the credential for that repository. 
        &quot;&quot;&quot;</span><span class="s1"> 
        </span><span class="s2">for </span><span class="s1">repository</span><span class="s2">, </span><span class="s1">cred </span><span class="s2">in </span><span class="s1">self.creds_by_repository.items(): 
            </span><span class="s2">if </span><span class="s1">url.startswith(repository): 
                </span><span class="s2">return </span><span class="s1">cred 
 
 
</span><span class="s2">def </span><span class="s1">open_with_auth(url</span><span class="s2">, </span><span class="s1">opener=urllib.request.urlopen): 
    </span><span class="s0">&quot;&quot;&quot;Open a urllib2 request, handling HTTP authentication&quot;&quot;&quot;</span><span class="s1"> 
 
    scheme</span><span class="s2">, </span><span class="s1">netloc</span><span class="s2">, </span><span class="s1">path</span><span class="s2">, </span><span class="s1">params</span><span class="s2">, </span><span class="s1">query</span><span class="s2">, </span><span class="s1">frag = urllib.parse.urlparse(url) 
 
    </span><span class="s4"># Double scheme does not raise on Mac OS X as revealed by a</span><span class="s1"> 
    </span><span class="s4"># failing test. We would expect &quot;nonnumeric port&quot;. Refs #20.</span><span class="s1"> 
    </span><span class="s2">if </span><span class="s1">netloc.endswith(</span><span class="s3">':'</span><span class="s1">): 
        </span><span class="s2">raise </span><span class="s1">http_client.InvalidURL(</span><span class="s3">&quot;nonnumeric port: ''&quot;</span><span class="s1">) 
 
    </span><span class="s2">if </span><span class="s1">scheme </span><span class="s2">in </span><span class="s1">(</span><span class="s3">'http'</span><span class="s2">, </span><span class="s3">'https'</span><span class="s1">): 
        auth</span><span class="s2">, </span><span class="s1">host = splituser(netloc) 
    </span><span class="s2">else</span><span class="s1">: 
        auth = </span><span class="s2">None</span><span class="s1"> 
 
    </span><span class="s2">if not </span><span class="s1">auth: 
        cred = PyPIConfig().find_credential(url) 
        </span><span class="s2">if </span><span class="s1">cred: 
            auth = str(cred) 
            info = cred.username</span><span class="s2">, </span><span class="s1">url 
            log.info(</span><span class="s3">'Authenticating as %s for %s (from .pypirc)'</span><span class="s2">, </span><span class="s1">*info) 
 
    </span><span class="s2">if </span><span class="s1">auth: 
        auth = </span><span class="s3">&quot;Basic &quot; </span><span class="s1">+ _encode_auth(auth) 
        parts = scheme</span><span class="s2">, </span><span class="s1">host</span><span class="s2">, </span><span class="s1">path</span><span class="s2">, </span><span class="s1">params</span><span class="s2">, </span><span class="s1">query</span><span class="s2">, </span><span class="s1">frag 
        new_url = urllib.parse.urlunparse(parts) 
        request = urllib.request.Request(new_url) 
        request.add_header(</span><span class="s3">&quot;Authorization&quot;</span><span class="s2">, </span><span class="s1">auth) 
    </span><span class="s2">else</span><span class="s1">: 
        request = urllib.request.Request(url) 
 
    request.add_header(</span><span class="s3">'User-Agent'</span><span class="s2">, </span><span class="s1">user_agent) 
    fp = opener(request) 
 
    </span><span class="s2">if </span><span class="s1">auth: 
        </span><span class="s4"># Put authentication info back into request URL if same host,</span><span class="s1"> 
        </span><span class="s4"># so that links found on the page will work</span><span class="s1"> 
        s2</span><span class="s2">, </span><span class="s1">h2</span><span class="s2">, </span><span class="s1">path2</span><span class="s2">, </span><span class="s1">param2</span><span class="s2">, </span><span class="s1">query2</span><span class="s2">, </span><span class="s1">frag2 = urllib.parse.urlparse(fp.url) 
        </span><span class="s2">if </span><span class="s1">s2 == scheme </span><span class="s2">and </span><span class="s1">h2 == host: 
            parts = s2</span><span class="s2">, </span><span class="s1">netloc</span><span class="s2">, </span><span class="s1">path2</span><span class="s2">, </span><span class="s1">param2</span><span class="s2">, </span><span class="s1">query2</span><span class="s2">, </span><span class="s1">frag2 
            fp.url = urllib.parse.urlunparse(parts) 
 
    </span><span class="s2">return </span><span class="s1">fp 
 
 
</span><span class="s4"># adding a timeout to avoid freezing package_index</span><span class="s1"> 
open_with_auth = socket_timeout(_SOCKET_TIMEOUT)(open_with_auth) 
 
 
</span><span class="s2">def </span><span class="s1">fix_sf_url(url): 
    </span><span class="s2">return </span><span class="s1">url  </span><span class="s4"># backward compatibility</span><span class="s1"> 
 
 
</span><span class="s2">def </span><span class="s1">local_open(url): 
    </span><span class="s0">&quot;&quot;&quot;Read a local path, with special support for directories&quot;&quot;&quot;</span><span class="s1"> 
    scheme</span><span class="s2">, </span><span class="s1">server</span><span class="s2">, </span><span class="s1">path</span><span class="s2">, </span><span class="s1">param</span><span class="s2">, </span><span class="s1">query</span><span class="s2">, </span><span class="s1">frag = urllib.parse.urlparse(url) 
    filename = urllib.request.url2pathname(path) 
    </span><span class="s2">if </span><span class="s1">os.path.isfile(filename): 
        </span><span class="s2">return </span><span class="s1">urllib.request.urlopen(url) 
    </span><span class="s2">elif </span><span class="s1">path.endswith(</span><span class="s3">'/'</span><span class="s1">) </span><span class="s2">and </span><span class="s1">os.path.isdir(filename): 
        files = [] 
        </span><span class="s2">for </span><span class="s1">f </span><span class="s2">in </span><span class="s1">os.listdir(filename): 
            filepath = os.path.join(filename</span><span class="s2">, </span><span class="s1">f) 
            </span><span class="s2">if </span><span class="s1">f == </span><span class="s3">'index.html'</span><span class="s1">: 
                </span><span class="s2">with </span><span class="s1">open(filepath</span><span class="s2">, </span><span class="s3">'r'</span><span class="s1">) </span><span class="s2">as </span><span class="s1">fp: 
                    body = fp.read() 
                </span><span class="s2">break</span><span class="s1"> 
            </span><span class="s2">elif </span><span class="s1">os.path.isdir(filepath): 
                f += </span><span class="s3">'/'</span><span class="s1"> 
            files.append(</span><span class="s3">'&lt;a href=&quot;{name}&quot;&gt;{name}&lt;/a&gt;'</span><span class="s1">.format(name=f)) 
        </span><span class="s2">else</span><span class="s1">: 
            tmpl = ( 
                </span><span class="s3">&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;{url}&lt;/title&gt;&quot;</span><span class="s1"> 
                </span><span class="s3">&quot;&lt;/head&gt;&lt;body&gt;{files}&lt;/body&gt;&lt;/html&gt;&quot;</span><span class="s1">) 
            body = tmpl.format(url=url</span><span class="s2">, </span><span class="s1">files=</span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">.join(files)) 
        status</span><span class="s2">, </span><span class="s1">message = </span><span class="s5">200</span><span class="s2">, </span><span class="s3">&quot;OK&quot;</span><span class="s1"> 
    </span><span class="s2">else</span><span class="s1">: 
        status</span><span class="s2">, </span><span class="s1">message</span><span class="s2">, </span><span class="s1">body = </span><span class="s5">404</span><span class="s2">, </span><span class="s3">&quot;Path not found&quot;</span><span class="s2">, </span><span class="s3">&quot;Not found&quot;</span><span class="s1"> 
 
    headers = {</span><span class="s3">'content-type'</span><span class="s1">: </span><span class="s3">'text/html'</span><span class="s1">} 
    body_stream = six.StringIO(body) 
    </span><span class="s2">return </span><span class="s1">urllib.error.HTTPError(url</span><span class="s2">, </span><span class="s1">status</span><span class="s2">, </span><span class="s1">message</span><span class="s2">, </span><span class="s1">headers</span><span class="s2">, </span><span class="s1">body_stream) 
</span></pre>
</body>
</html>