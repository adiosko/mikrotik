<html>
<head>
<title>req_install.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.ln { color: #606366; font-weight: normal; font-style: normal; }
.s0 { color: rgb(204,120,50); }
.s1 { color: rgb(169,183,198); }
.s2 { color: rgb(106,135,89); }
.s3 { color: rgb(104,151,187); }
.s4 { color: rgb(128,128,128); }
.s5 { color: rgb(98,151,85); font-style: italic; }
</style>
</head>
<BODY BGCOLOR="#2b2b2b">
<TABLE CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<TR><TD><CENTER>
<FONT FACE="Arial, Helvetica" COLOR="#000000">
req_install.py</FONT>
</center></TD></TR></TABLE>
<pre>
<span class="s0">from </span><span class="s1">__future__ </span><span class="s0">import </span><span class="s1">absolute_import 
 
</span><span class="s0">import </span><span class="s1">logging 
</span><span class="s0">import </span><span class="s1">os 
</span><span class="s0">import </span><span class="s1">re 
</span><span class="s0">import </span><span class="s1">shutil 
</span><span class="s0">import </span><span class="s1">sys 
</span><span class="s0">import </span><span class="s1">tempfile 
</span><span class="s0">import </span><span class="s1">traceback 
</span><span class="s0">import </span><span class="s1">warnings 
</span><span class="s0">import </span><span class="s1">zipfile 
 
</span><span class="s0">from </span><span class="s1">distutils </span><span class="s0">import </span><span class="s1">sysconfig 
</span><span class="s0">from </span><span class="s1">distutils.util </span><span class="s0">import </span><span class="s1">change_root 
</span><span class="s0">from </span><span class="s1">email.parser </span><span class="s0">import </span><span class="s1">FeedParser 
 
</span><span class="s0">from </span><span class="s1">pip._vendor </span><span class="s0">import </span><span class="s1">pkg_resources</span><span class="s0">, </span><span class="s1">six 
</span><span class="s0">from </span><span class="s1">pip._vendor.packaging </span><span class="s0">import </span><span class="s1">specifiers 
</span><span class="s0">from </span><span class="s1">pip._vendor.packaging.markers </span><span class="s0">import </span><span class="s1">Marker 
</span><span class="s0">from </span><span class="s1">pip._vendor.packaging.requirements </span><span class="s0">import </span><span class="s1">InvalidRequirement</span><span class="s0">, </span><span class="s1">Requirement 
</span><span class="s0">from </span><span class="s1">pip._vendor.packaging.utils </span><span class="s0">import </span><span class="s1">canonicalize_name 
</span><span class="s0">from </span><span class="s1">pip._vendor.packaging.version </span><span class="s0">import </span><span class="s1">Version</span><span class="s0">, </span><span class="s1">parse </span><span class="s0">as </span><span class="s1">parse_version 
</span><span class="s0">from </span><span class="s1">pip._vendor.six.moves </span><span class="s0">import </span><span class="s1">configparser 
 
</span><span class="s0">import </span><span class="s1">pip.wheel 
 
</span><span class="s0">from </span><span class="s1">pip.compat </span><span class="s0">import </span><span class="s1">native_str</span><span class="s0">, </span><span class="s1">get_stdlib</span><span class="s0">, </span><span class="s1">WINDOWS 
</span><span class="s0">from </span><span class="s1">pip.download </span><span class="s0">import </span><span class="s1">is_url</span><span class="s0">, </span><span class="s1">url_to_path</span><span class="s0">, </span><span class="s1">path_to_url</span><span class="s0">, </span><span class="s1">is_archive_file 
</span><span class="s0">from </span><span class="s1">pip.exceptions </span><span class="s0">import </span><span class="s1">( 
    InstallationError</span><span class="s0">, </span><span class="s1">UninstallationError</span><span class="s0">,</span><span class="s1"> 
) 
</span><span class="s0">from </span><span class="s1">pip.locations </span><span class="s0">import </span><span class="s1">( 
    bin_py</span><span class="s0">, </span><span class="s1">running_under_virtualenv</span><span class="s0">, </span><span class="s1">PIP_DELETE_MARKER_FILENAME</span><span class="s0">, </span><span class="s1">bin_user</span><span class="s0">,</span><span class="s1"> 
) 
</span><span class="s0">from </span><span class="s1">pip.utils </span><span class="s0">import </span><span class="s1">( 
    display_path</span><span class="s0">, </span><span class="s1">rmtree</span><span class="s0">, </span><span class="s1">ask_path_exists</span><span class="s0">, </span><span class="s1">backup_dir</span><span class="s0">, </span><span class="s1">is_installable_dir</span><span class="s0">,</span><span class="s1"> 
    dist_in_usersite</span><span class="s0">, </span><span class="s1">dist_in_site_packages</span><span class="s0">, </span><span class="s1">egg_link_path</span><span class="s0">,</span><span class="s1"> 
    call_subprocess</span><span class="s0">, </span><span class="s1">read_text_file</span><span class="s0">, </span><span class="s1">FakeFile</span><span class="s0">, </span><span class="s1">_make_build_dir</span><span class="s0">, </span><span class="s1">ensure_dir</span><span class="s0">,</span><span class="s1"> 
    get_installed_version</span><span class="s0">, </span><span class="s1">normalize_path</span><span class="s0">, </span><span class="s1">dist_is_local</span><span class="s0">,</span><span class="s1"> 
) 
 
</span><span class="s0">from </span><span class="s1">pip.utils.hashes </span><span class="s0">import </span><span class="s1">Hashes 
</span><span class="s0">from </span><span class="s1">pip.utils.deprecation </span><span class="s0">import </span><span class="s1">RemovedInPip10Warning 
</span><span class="s0">from </span><span class="s1">pip.utils.logging </span><span class="s0">import </span><span class="s1">indent_log 
</span><span class="s0">from </span><span class="s1">pip.utils.setuptools_build </span><span class="s0">import </span><span class="s1">SETUPTOOLS_SHIM 
</span><span class="s0">from </span><span class="s1">pip.utils.ui </span><span class="s0">import </span><span class="s1">open_spinner 
</span><span class="s0">from </span><span class="s1">pip.req.req_uninstall </span><span class="s0">import </span><span class="s1">UninstallPathSet 
</span><span class="s0">from </span><span class="s1">pip.vcs </span><span class="s0">import </span><span class="s1">vcs 
</span><span class="s0">from </span><span class="s1">pip.wheel </span><span class="s0">import </span><span class="s1">move_wheel_files</span><span class="s0">, </span><span class="s1">Wheel 
 
 
logger = logging.getLogger(__name__) 
 
operators = specifiers.Specifier._operators.keys() 
 
 
</span><span class="s0">def </span><span class="s1">_strip_extras(path): 
    m = re.match(</span><span class="s2">r'^(.+)(\[[^\]]+\])$'</span><span class="s0">, </span><span class="s1">path) 
    extras = </span><span class="s0">None</span><span class="s1"> 
    </span><span class="s0">if </span><span class="s1">m: 
        path_no_extras = m.group(</span><span class="s3">1</span><span class="s1">) 
        extras = m.group(</span><span class="s3">2</span><span class="s1">) 
    </span><span class="s0">else</span><span class="s1">: 
        path_no_extras = path 
 
    </span><span class="s0">return </span><span class="s1">path_no_extras</span><span class="s0">, </span><span class="s1">extras 
 
 
</span><span class="s0">def </span><span class="s1">_safe_extras(extras): 
    </span><span class="s0">return </span><span class="s1">set(pkg_resources.safe_extra(extra) </span><span class="s0">for </span><span class="s1">extra </span><span class="s0">in </span><span class="s1">extras) 
 
 
</span><span class="s0">class </span><span class="s1">InstallRequirement(object): 
 
    </span><span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">req</span><span class="s0">, </span><span class="s1">comes_from</span><span class="s0">, </span><span class="s1">source_dir=</span><span class="s0">None, </span><span class="s1">editable=</span><span class="s0">False,</span><span class="s1"> 
                 link=</span><span class="s0">None, </span><span class="s1">as_egg=</span><span class="s0">False, </span><span class="s1">update=</span><span class="s0">True,</span><span class="s1"> 
                 pycompile=</span><span class="s0">True, </span><span class="s1">markers=</span><span class="s0">None, </span><span class="s1">isolated=</span><span class="s0">False, </span><span class="s1">options=</span><span class="s0">None,</span><span class="s1"> 
                 wheel_cache=</span><span class="s0">None, </span><span class="s1">constraint=</span><span class="s0">False</span><span class="s1">): 
        self.extras = () 
        </span><span class="s0">if </span><span class="s1">isinstance(req</span><span class="s0">, </span><span class="s1">six.string_types): 
            </span><span class="s0">try</span><span class="s1">: 
                req = Requirement(req) 
            </span><span class="s0">except </span><span class="s1">InvalidRequirement: 
                </span><span class="s0">if </span><span class="s1">os.path.sep </span><span class="s0">in </span><span class="s1">req: 
                    add_msg = </span><span class="s2">&quot;It looks like a path. Does it exist ?&quot;</span><span class="s1"> 
                </span><span class="s0">elif </span><span class="s2">'=' </span><span class="s0">in </span><span class="s1">req </span><span class="s0">and not </span><span class="s1">any(op </span><span class="s0">in </span><span class="s1">req </span><span class="s0">for </span><span class="s1">op </span><span class="s0">in </span><span class="s1">operators): 
                    add_msg = </span><span class="s2">&quot;= is not a valid operator. Did you mean == ?&quot;</span><span class="s1"> 
                </span><span class="s0">else</span><span class="s1">: 
                    add_msg = traceback.format_exc() 
                </span><span class="s0">raise </span><span class="s1">InstallationError( 
                    </span><span class="s2">&quot;Invalid requirement: '%s'</span><span class="s0">\n</span><span class="s2">%s&quot; </span><span class="s1">% (req</span><span class="s0">, </span><span class="s1">add_msg)) 
            self.extras = _safe_extras(req.extras) 
 
        self.req = req 
        self.comes_from = comes_from 
        self.constraint = constraint 
        self.source_dir = source_dir 
        self.editable = editable 
 
        self._wheel_cache = wheel_cache 
        self.link = self.original_link = link 
        self.as_egg = as_egg 
        </span><span class="s0">if </span><span class="s1">markers </span><span class="s0">is not None</span><span class="s1">: 
            self.markers = markers 
        </span><span class="s0">else</span><span class="s1">: 
            self.markers = req </span><span class="s0">and </span><span class="s1">req.marker 
        self._egg_info_path = </span><span class="s0">None</span><span class="s1"> 
        </span><span class="s4"># This holds the pkg_resources.Distribution object if this requirement</span><span class="s1"> 
        </span><span class="s4"># is already available:</span><span class="s1"> 
        self.satisfied_by = </span><span class="s0">None</span><span class="s1"> 
        </span><span class="s4"># This hold the pkg_resources.Distribution object if this requirement</span><span class="s1"> 
        </span><span class="s4"># conflicts with another installed distribution:</span><span class="s1"> 
        self.conflicts_with = </span><span class="s0">None</span><span class="s1"> 
        </span><span class="s4"># Temporary build location</span><span class="s1"> 
        self._temp_build_dir = </span><span class="s0">None</span><span class="s1"> 
        </span><span class="s4"># Used to store the global directory where the _temp_build_dir should</span><span class="s1"> 
        </span><span class="s4"># have been created. Cf _correct_build_location method.</span><span class="s1"> 
        self._ideal_build_dir = </span><span class="s0">None</span><span class="s1"> 
        </span><span class="s4"># True if the editable should be updated:</span><span class="s1"> 
        self.update = update 
        </span><span class="s4"># Set to True after successful installation</span><span class="s1"> 
        self.install_succeeded = </span><span class="s0">None</span><span class="s1"> 
        </span><span class="s4"># UninstallPathSet of uninstalled distribution (for possible rollback)</span><span class="s1"> 
        self.uninstalled = </span><span class="s0">None</span><span class="s1"> 
        </span><span class="s4"># Set True if a legitimate do-nothing-on-uninstall has happened - e.g.</span><span class="s1"> 
        </span><span class="s4"># system site packages, stdlib packages.</span><span class="s1"> 
        self.nothing_to_uninstall = </span><span class="s0">False</span><span class="s1"> 
        self.use_user_site = </span><span class="s0">False</span><span class="s1"> 
        self.target_dir = </span><span class="s0">None</span><span class="s1"> 
        self.options = options </span><span class="s0">if </span><span class="s1">options </span><span class="s0">else </span><span class="s1">{} 
        self.pycompile = pycompile 
        </span><span class="s4"># Set to True after successful preparation of this requirement</span><span class="s1"> 
        self.prepared = </span><span class="s0">False</span><span class="s1"> 
 
        self.isolated = isolated 
 
    @classmethod 
    </span><span class="s0">def </span><span class="s1">from_editable(cls</span><span class="s0">, </span><span class="s1">editable_req</span><span class="s0">, </span><span class="s1">comes_from=</span><span class="s0">None, </span><span class="s1">default_vcs=</span><span class="s0">None,</span><span class="s1"> 
                      isolated=</span><span class="s0">False, </span><span class="s1">options=</span><span class="s0">None, </span><span class="s1">wheel_cache=</span><span class="s0">None,</span><span class="s1"> 
                      constraint=</span><span class="s0">False</span><span class="s1">): 
        </span><span class="s0">from </span><span class="s1">pip.index </span><span class="s0">import </span><span class="s1">Link 
 
        name</span><span class="s0">, </span><span class="s1">url</span><span class="s0">, </span><span class="s1">extras_override = parse_editable( 
            editable_req</span><span class="s0">, </span><span class="s1">default_vcs) 
        </span><span class="s0">if </span><span class="s1">url.startswith(</span><span class="s2">'file:'</span><span class="s1">): 
            source_dir = url_to_path(url) 
        </span><span class="s0">else</span><span class="s1">: 
            source_dir = </span><span class="s0">None</span><span class="s1"> 
 
        res = cls(name</span><span class="s0">, </span><span class="s1">comes_from</span><span class="s0">, </span><span class="s1">source_dir=source_dir</span><span class="s0">,</span><span class="s1"> 
                  editable=</span><span class="s0">True,</span><span class="s1"> 
                  link=Link(url)</span><span class="s0">,</span><span class="s1"> 
                  constraint=constraint</span><span class="s0">,</span><span class="s1"> 
                  isolated=isolated</span><span class="s0">,</span><span class="s1"> 
                  options=options </span><span class="s0">if </span><span class="s1">options </span><span class="s0">else </span><span class="s1">{}</span><span class="s0">,</span><span class="s1"> 
                  wheel_cache=wheel_cache) 
 
        </span><span class="s0">if </span><span class="s1">extras_override </span><span class="s0">is not None</span><span class="s1">: 
            res.extras = _safe_extras(extras_override) 
 
        </span><span class="s0">return </span><span class="s1">res 
 
    @classmethod 
    </span><span class="s0">def </span><span class="s1">from_line( 
            cls</span><span class="s0">, </span><span class="s1">name</span><span class="s0">, </span><span class="s1">comes_from=</span><span class="s0">None, </span><span class="s1">isolated=</span><span class="s0">False, </span><span class="s1">options=</span><span class="s0">None,</span><span class="s1"> 
            wheel_cache=</span><span class="s0">None, </span><span class="s1">constraint=</span><span class="s0">False</span><span class="s1">): 
        </span><span class="s5">&quot;&quot;&quot;Creates an InstallRequirement from a name, which might be a 
        requirement, directory containing 'setup.py', filename, or URL. 
        &quot;&quot;&quot;</span><span class="s1"> 
        </span><span class="s0">from </span><span class="s1">pip.index </span><span class="s0">import </span><span class="s1">Link 
 
        </span><span class="s0">if </span><span class="s1">is_url(name): 
            marker_sep = </span><span class="s2">'; '</span><span class="s1"> 
        </span><span class="s0">else</span><span class="s1">: 
            marker_sep = </span><span class="s2">';'</span><span class="s1"> 
        </span><span class="s0">if </span><span class="s1">marker_sep </span><span class="s0">in </span><span class="s1">name: 
            name</span><span class="s0">, </span><span class="s1">markers = name.split(marker_sep</span><span class="s0">, </span><span class="s3">1</span><span class="s1">) 
            markers = markers.strip() 
            </span><span class="s0">if not </span><span class="s1">markers: 
                markers = </span><span class="s0">None</span><span class="s1"> 
            </span><span class="s0">else</span><span class="s1">: 
                markers = Marker(markers) 
        </span><span class="s0">else</span><span class="s1">: 
            markers = </span><span class="s0">None</span><span class="s1"> 
        name = name.strip() 
        req = </span><span class="s0">None</span><span class="s1"> 
        path = os.path.normpath(os.path.abspath(name)) 
        link = </span><span class="s0">None</span><span class="s1"> 
        extras = </span><span class="s0">None</span><span class="s1"> 
 
        </span><span class="s0">if </span><span class="s1">is_url(name): 
            link = Link(name) 
        </span><span class="s0">else</span><span class="s1">: 
            p</span><span class="s0">, </span><span class="s1">extras = _strip_extras(path) 
            </span><span class="s0">if </span><span class="s1">(os.path.isdir(p) </span><span class="s0">and</span><span class="s1"> 
                    (os.path.sep </span><span class="s0">in </span><span class="s1">name </span><span class="s0">or </span><span class="s1">name.startswith(</span><span class="s2">'.'</span><span class="s1">))): 
 
                </span><span class="s0">if not </span><span class="s1">is_installable_dir(p): 
                    </span><span class="s0">raise </span><span class="s1">InstallationError( 
                        </span><span class="s2">&quot;Directory %r is not installable. File 'setup.py' &quot;</span><span class="s1"> 
                        </span><span class="s2">&quot;not found.&quot; </span><span class="s1">% name 
                    ) 
                link = Link(path_to_url(p)) 
            </span><span class="s0">elif </span><span class="s1">is_archive_file(p): 
                </span><span class="s0">if not </span><span class="s1">os.path.isfile(p): 
                    logger.warning( 
                        </span><span class="s2">'Requirement %r looks like a filename, but the '</span><span class="s1"> 
                        </span><span class="s2">'file does not exist'</span><span class="s0">,</span><span class="s1"> 
                        name 
                    ) 
                link = Link(path_to_url(p)) 
 
        </span><span class="s4"># it's a local file, dir, or url</span><span class="s1"> 
        </span><span class="s0">if </span><span class="s1">link: 
            </span><span class="s4"># Handle relative file URLs</span><span class="s1"> 
            </span><span class="s0">if </span><span class="s1">link.scheme == </span><span class="s2">'file' </span><span class="s0">and </span><span class="s1">re.search(</span><span class="s2">r'\.\./'</span><span class="s0">, </span><span class="s1">link.url): 
                link = Link( 
                    path_to_url(os.path.normpath(os.path.abspath(link.path)))) 
            </span><span class="s4"># wheel file</span><span class="s1"> 
            </span><span class="s0">if </span><span class="s1">link.is_wheel: 
                wheel = Wheel(link.filename)  </span><span class="s4"># can raise InvalidWheelFilename</span><span class="s1"> 
                req = </span><span class="s2">&quot;%s==%s&quot; </span><span class="s1">% (wheel.name</span><span class="s0">, </span><span class="s1">wheel.version) 
            </span><span class="s0">else</span><span class="s1">: 
                </span><span class="s4"># set the req to the egg fragment.  when it's not there, this</span><span class="s1"> 
                </span><span class="s4"># will become an 'unnamed' requirement</span><span class="s1"> 
                req = link.egg_fragment 
 
        </span><span class="s4"># a requirement specifier</span><span class="s1"> 
        </span><span class="s0">else</span><span class="s1">: 
            req = name 
 
        options = options </span><span class="s0">if </span><span class="s1">options </span><span class="s0">else </span><span class="s1">{} 
        res = cls(req</span><span class="s0">, </span><span class="s1">comes_from</span><span class="s0">, </span><span class="s1">link=link</span><span class="s0">, </span><span class="s1">markers=markers</span><span class="s0">,</span><span class="s1"> 
                  isolated=isolated</span><span class="s0">, </span><span class="s1">options=options</span><span class="s0">,</span><span class="s1"> 
                  wheel_cache=wheel_cache</span><span class="s0">, </span><span class="s1">constraint=constraint) 
 
        </span><span class="s0">if </span><span class="s1">extras: 
            res.extras = _safe_extras( 
                Requirement(</span><span class="s2">'placeholder' </span><span class="s1">+ extras).extras) 
 
        </span><span class="s0">return </span><span class="s1">res 
 
    </span><span class="s0">def </span><span class="s1">__str__(self): 
        </span><span class="s0">if </span><span class="s1">self.req: 
            s = str(self.req) 
            </span><span class="s0">if </span><span class="s1">self.link: 
                s += </span><span class="s2">' from %s' </span><span class="s1">% self.link.url 
        </span><span class="s0">else</span><span class="s1">: 
            s = self.link.url </span><span class="s0">if </span><span class="s1">self.link </span><span class="s0">else None</span><span class="s1"> 
        </span><span class="s0">if </span><span class="s1">self.satisfied_by </span><span class="s0">is not None</span><span class="s1">: 
            s += </span><span class="s2">' in %s' </span><span class="s1">% display_path(self.satisfied_by.location) 
        </span><span class="s0">if </span><span class="s1">self.comes_from: 
            </span><span class="s0">if </span><span class="s1">isinstance(self.comes_from</span><span class="s0">, </span><span class="s1">six.string_types): 
                comes_from = self.comes_from 
            </span><span class="s0">else</span><span class="s1">: 
                comes_from = self.comes_from.from_path() 
            </span><span class="s0">if </span><span class="s1">comes_from: 
                s += </span><span class="s2">' (from %s)' </span><span class="s1">% comes_from 
        </span><span class="s0">return </span><span class="s1">s 
 
    </span><span class="s0">def </span><span class="s1">__repr__(self): 
        </span><span class="s0">return </span><span class="s2">'&lt;%s object: %s editable=%r&gt;' </span><span class="s1">% ( 
            self.__class__.__name__</span><span class="s0">, </span><span class="s1">str(self)</span><span class="s0">, </span><span class="s1">self.editable) 
 
    </span><span class="s0">def </span><span class="s1">populate_link(self</span><span class="s0">, </span><span class="s1">finder</span><span class="s0">, </span><span class="s1">upgrade</span><span class="s0">, </span><span class="s1">require_hashes): 
        </span><span class="s5">&quot;&quot;&quot;Ensure that if a link can be found for this, that it is found. 
 
        Note that self.link may still be None - if Upgrade is False and the 
        requirement is already installed. 
 
        If require_hashes is True, don't use the wheel cache, because cached 
        wheels, always built locally, have different hashes than the files 
        downloaded from the index server and thus throw false hash mismatches. 
        Furthermore, cached wheels at present have undeterministic contents due 
        to file modification times. 
        &quot;&quot;&quot;</span><span class="s1"> 
        </span><span class="s0">if </span><span class="s1">self.link </span><span class="s0">is None</span><span class="s1">: 
            self.link = finder.find_requirement(self</span><span class="s0">, </span><span class="s1">upgrade) 
        </span><span class="s0">if </span><span class="s1">self._wheel_cache </span><span class="s0">is not None and not </span><span class="s1">require_hashes: 
            old_link = self.link 
            self.link = self._wheel_cache.cached_wheel(self.link</span><span class="s0">, </span><span class="s1">self.name) 
            </span><span class="s0">if </span><span class="s1">old_link != self.link: 
                logger.debug(</span><span class="s2">'Using cached wheel link: %s'</span><span class="s0">, </span><span class="s1">self.link) 
 
    @property 
    </span><span class="s0">def </span><span class="s1">specifier(self): 
        </span><span class="s0">return </span><span class="s1">self.req.specifier 
 
    @property 
    </span><span class="s0">def </span><span class="s1">is_pinned(self): 
        </span><span class="s5">&quot;&quot;&quot;Return whether I am pinned to an exact version. 
 
        For example, some-package==1.2 is pinned; some-package&gt;1.2 is not. 
        &quot;&quot;&quot;</span><span class="s1"> 
        specifiers = self.specifier 
        </span><span class="s0">return </span><span class="s1">(len(specifiers) == </span><span class="s3">1 </span><span class="s0">and</span><span class="s1"> 
                next(iter(specifiers)).operator </span><span class="s0">in </span><span class="s1">(</span><span class="s2">'=='</span><span class="s0">, </span><span class="s2">'==='</span><span class="s1">)) 
 
    </span><span class="s0">def </span><span class="s1">from_path(self): 
        </span><span class="s0">if </span><span class="s1">self.req </span><span class="s0">is None</span><span class="s1">: 
            </span><span class="s0">return None</span><span class="s1"> 
        s = str(self.req) 
        </span><span class="s0">if </span><span class="s1">self.comes_from: 
            </span><span class="s0">if </span><span class="s1">isinstance(self.comes_from</span><span class="s0">, </span><span class="s1">six.string_types): 
                comes_from = self.comes_from 
            </span><span class="s0">else</span><span class="s1">: 
                comes_from = self.comes_from.from_path() 
            </span><span class="s0">if </span><span class="s1">comes_from: 
                s += </span><span class="s2">'-&gt;' </span><span class="s1">+ comes_from 
        </span><span class="s0">return </span><span class="s1">s 
 
    </span><span class="s0">def </span><span class="s1">build_location(self</span><span class="s0">, </span><span class="s1">build_dir): 
        </span><span class="s0">if </span><span class="s1">self._temp_build_dir </span><span class="s0">is not None</span><span class="s1">: 
            </span><span class="s0">return </span><span class="s1">self._temp_build_dir 
        </span><span class="s0">if </span><span class="s1">self.req </span><span class="s0">is None</span><span class="s1">: 
            </span><span class="s4"># for requirement via a path to a directory: the name of the</span><span class="s1"> 
            </span><span class="s4"># package is not available yet so we create a temp directory</span><span class="s1"> 
            </span><span class="s4"># Once run_egg_info will have run, we'll be able</span><span class="s1"> 
            </span><span class="s4"># to fix it via _correct_build_location</span><span class="s1"> 
            </span><span class="s4"># Some systems have /tmp as a symlink which confuses custom</span><span class="s1"> 
            </span><span class="s4"># builds (such as numpy). Thus, we ensure that the real path</span><span class="s1"> 
            </span><span class="s4"># is returned.</span><span class="s1"> 
            self._temp_build_dir = os.path.realpath( 
                tempfile.mkdtemp(</span><span class="s2">'-build'</span><span class="s0">, </span><span class="s2">'pip-'</span><span class="s1">) 
            ) 
            self._ideal_build_dir = build_dir 
            </span><span class="s0">return </span><span class="s1">self._temp_build_dir 
        </span><span class="s0">if </span><span class="s1">self.editable: 
            name = self.name.lower() 
        </span><span class="s0">else</span><span class="s1">: 
            name = self.name 
        </span><span class="s4"># FIXME: Is there a better place to create the build_dir? (hg and bzr</span><span class="s1"> 
        </span><span class="s4"># need this)</span><span class="s1"> 
        </span><span class="s0">if not </span><span class="s1">os.path.exists(build_dir): 
            logger.debug(</span><span class="s2">'Creating directory %s'</span><span class="s0">, </span><span class="s1">build_dir) 
            _make_build_dir(build_dir) 
        </span><span class="s0">return </span><span class="s1">os.path.join(build_dir</span><span class="s0">, </span><span class="s1">name) 
 
    </span><span class="s0">def </span><span class="s1">_correct_build_location(self): 
        </span><span class="s5">&quot;&quot;&quot;Move self._temp_build_dir to self._ideal_build_dir/self.req.name 
 
        For some requirements (e.g. a path to a directory), the name of the 
        package is not available until we run egg_info, so the build_location 
        will return a temporary directory and store the _ideal_build_dir. 
 
        This is only called by self.egg_info_path to fix the temporary build 
        directory. 
        &quot;&quot;&quot;</span><span class="s1"> 
        </span><span class="s0">if </span><span class="s1">self.source_dir </span><span class="s0">is not None</span><span class="s1">: 
            </span><span class="s0">return</span><span class="s1"> 
        </span><span class="s0">assert </span><span class="s1">self.req </span><span class="s0">is not None</span><span class="s1"> 
        </span><span class="s0">assert </span><span class="s1">self._temp_build_dir 
        </span><span class="s0">assert </span><span class="s1">self._ideal_build_dir 
        old_location = self._temp_build_dir 
        self._temp_build_dir = </span><span class="s0">None</span><span class="s1"> 
        new_location = self.build_location(self._ideal_build_dir) 
        </span><span class="s0">if </span><span class="s1">os.path.exists(new_location): 
            </span><span class="s0">raise </span><span class="s1">InstallationError( 
                </span><span class="s2">'A package already exists in %s; please remove it to continue'</span><span class="s1"> 
                % display_path(new_location)) 
        logger.debug( 
            </span><span class="s2">'Moving package %s from %s to new location %s'</span><span class="s0">,</span><span class="s1"> 
            self</span><span class="s0">, </span><span class="s1">display_path(old_location)</span><span class="s0">, </span><span class="s1">display_path(new_location)</span><span class="s0">,</span><span class="s1"> 
        ) 
        shutil.move(old_location</span><span class="s0">, </span><span class="s1">new_location) 
        self._temp_build_dir = new_location 
        self._ideal_build_dir = </span><span class="s0">None</span><span class="s1"> 
        self.source_dir = new_location 
        self._egg_info_path = </span><span class="s0">None</span><span class="s1"> 
 
    @property 
    </span><span class="s0">def </span><span class="s1">name(self): 
        </span><span class="s0">if </span><span class="s1">self.req </span><span class="s0">is None</span><span class="s1">: 
            </span><span class="s0">return None</span><span class="s1"> 
        </span><span class="s0">return </span><span class="s1">native_str(pkg_resources.safe_name(self.req.name)) 
 
    @property 
    </span><span class="s0">def </span><span class="s1">setup_py_dir(self): 
        </span><span class="s0">return </span><span class="s1">os.path.join( 
            self.source_dir</span><span class="s0">,</span><span class="s1"> 
            self.link </span><span class="s0">and </span><span class="s1">self.link.subdirectory_fragment </span><span class="s0">or </span><span class="s2">''</span><span class="s1">) 
 
    @property 
    </span><span class="s0">def </span><span class="s1">setup_py(self): 
        </span><span class="s0">assert </span><span class="s1">self.source_dir</span><span class="s0">, </span><span class="s2">&quot;No source dir for %s&quot; </span><span class="s1">% self 
        </span><span class="s0">try</span><span class="s1">: 
            </span><span class="s0">import </span><span class="s1">setuptools  </span><span class="s4"># noqa</span><span class="s1"> 
        </span><span class="s0">except </span><span class="s1">ImportError: 
            </span><span class="s0">if </span><span class="s1">get_installed_version(</span><span class="s2">'setuptools'</span><span class="s1">) </span><span class="s0">is None</span><span class="s1">: 
                add_msg = </span><span class="s2">&quot;Please install setuptools.&quot;</span><span class="s1"> 
            </span><span class="s0">else</span><span class="s1">: 
                add_msg = traceback.format_exc() 
            </span><span class="s4"># Setuptools is not available</span><span class="s1"> 
            </span><span class="s0">raise </span><span class="s1">InstallationError( 
                </span><span class="s2">&quot;Could not import setuptools which is required to &quot;</span><span class="s1"> 
                </span><span class="s2">&quot;install from a source distribution.</span><span class="s0">\n</span><span class="s2">%s&quot; </span><span class="s1">% add_msg 
            ) 
 
        setup_py = os.path.join(self.setup_py_dir</span><span class="s0">, </span><span class="s2">'setup.py'</span><span class="s1">) 
 
        </span><span class="s4"># Python2 __file__ should not be unicode</span><span class="s1"> 
        </span><span class="s0">if </span><span class="s1">six.PY2 </span><span class="s0">and </span><span class="s1">isinstance(setup_py</span><span class="s0">, </span><span class="s1">six.text_type): 
            setup_py = setup_py.encode(sys.getfilesystemencoding()) 
 
        </span><span class="s0">return </span><span class="s1">setup_py 
 
    </span><span class="s0">def </span><span class="s1">run_egg_info(self): 
        </span><span class="s0">assert </span><span class="s1">self.source_dir 
        </span><span class="s0">if </span><span class="s1">self.name: 
            logger.debug( 
                </span><span class="s2">'Running setup.py (path:%s) egg_info for package %s'</span><span class="s0">,</span><span class="s1"> 
                self.setup_py</span><span class="s0">, </span><span class="s1">self.name</span><span class="s0">,</span><span class="s1"> 
            ) 
        </span><span class="s0">else</span><span class="s1">: 
            logger.debug( 
                </span><span class="s2">'Running setup.py (path:%s) egg_info for package from %s'</span><span class="s0">,</span><span class="s1"> 
                self.setup_py</span><span class="s0">, </span><span class="s1">self.link</span><span class="s0">,</span><span class="s1"> 
            ) 
 
        </span><span class="s0">with </span><span class="s1">indent_log(): 
            script = SETUPTOOLS_SHIM % self.setup_py 
            base_cmd = [sys.executable</span><span class="s0">, </span><span class="s2">'-c'</span><span class="s0">, </span><span class="s1">script] 
            </span><span class="s0">if </span><span class="s1">self.isolated: 
                base_cmd += [</span><span class="s2">&quot;--no-user-cfg&quot;</span><span class="s1">] 
            egg_info_cmd = base_cmd + [</span><span class="s2">'egg_info'</span><span class="s1">] 
            </span><span class="s4"># We can't put the .egg-info files at the root, because then the</span><span class="s1"> 
            </span><span class="s4"># source code will be mistaken for an installed egg, causing</span><span class="s1"> 
            </span><span class="s4"># problems</span><span class="s1"> 
            </span><span class="s0">if </span><span class="s1">self.editable: 
                egg_base_option = [] 
            </span><span class="s0">else</span><span class="s1">: 
                egg_info_dir = os.path.join(self.setup_py_dir</span><span class="s0">, </span><span class="s2">'pip-egg-info'</span><span class="s1">) 
                ensure_dir(egg_info_dir) 
                egg_base_option = [</span><span class="s2">'--egg-base'</span><span class="s0">, </span><span class="s2">'pip-egg-info'</span><span class="s1">] 
            call_subprocess( 
                egg_info_cmd + egg_base_option</span><span class="s0">,</span><span class="s1"> 
                cwd=self.setup_py_dir</span><span class="s0">,</span><span class="s1"> 
                show_stdout=</span><span class="s0">False,</span><span class="s1"> 
                command_desc=</span><span class="s2">'python setup.py egg_info'</span><span class="s1">) 
 
        </span><span class="s0">if not </span><span class="s1">self.req: 
            </span><span class="s0">if </span><span class="s1">isinstance(parse_version(self.pkg_info()[</span><span class="s2">&quot;Version&quot;</span><span class="s1">])</span><span class="s0">, </span><span class="s1">Version): 
                op = </span><span class="s2">&quot;==&quot;</span><span class="s1"> 
            </span><span class="s0">else</span><span class="s1">: 
                op = </span><span class="s2">&quot;===&quot;</span><span class="s1"> 
            self.req = Requirement( 
                </span><span class="s2">&quot;&quot;</span><span class="s1">.join([ 
                    self.pkg_info()[</span><span class="s2">&quot;Name&quot;</span><span class="s1">]</span><span class="s0">,</span><span class="s1"> 
                    op</span><span class="s0">,</span><span class="s1"> 
                    self.pkg_info()[</span><span class="s2">&quot;Version&quot;</span><span class="s1">]</span><span class="s0">,</span><span class="s1"> 
                ]) 
            ) 
            self._correct_build_location() 
        </span><span class="s0">else</span><span class="s1">: 
            metadata_name = canonicalize_name(self.pkg_info()[</span><span class="s2">&quot;Name&quot;</span><span class="s1">]) 
            </span><span class="s0">if </span><span class="s1">canonicalize_name(self.req.name) != metadata_name: 
                logger.warning( 
                    </span><span class="s2">'Running setup.py (path:%s) egg_info for package %s '</span><span class="s1"> 
                    </span><span class="s2">'produced metadata for project name %s. Fix your '</span><span class="s1"> 
                    </span><span class="s2">'#egg=%s fragments.'</span><span class="s0">,</span><span class="s1"> 
                    self.setup_py</span><span class="s0">, </span><span class="s1">self.name</span><span class="s0">, </span><span class="s1">metadata_name</span><span class="s0">, </span><span class="s1">self.name 
                ) 
                self.req = Requirement(metadata_name) 
 
    </span><span class="s0">def </span><span class="s1">egg_info_data(self</span><span class="s0">, </span><span class="s1">filename): 
        </span><span class="s0">if </span><span class="s1">self.satisfied_by </span><span class="s0">is not None</span><span class="s1">: 
            </span><span class="s0">if not </span><span class="s1">self.satisfied_by.has_metadata(filename): 
                </span><span class="s0">return None</span><span class="s1"> 
            </span><span class="s0">return </span><span class="s1">self.satisfied_by.get_metadata(filename) 
        </span><span class="s0">assert </span><span class="s1">self.source_dir 
        filename = self.egg_info_path(filename) 
        </span><span class="s0">if not </span><span class="s1">os.path.exists(filename): 
            </span><span class="s0">return None</span><span class="s1"> 
        data = read_text_file(filename) 
        </span><span class="s0">return </span><span class="s1">data 
 
    </span><span class="s0">def </span><span class="s1">egg_info_path(self</span><span class="s0">, </span><span class="s1">filename): 
        </span><span class="s0">if </span><span class="s1">self._egg_info_path </span><span class="s0">is None</span><span class="s1">: 
            </span><span class="s0">if </span><span class="s1">self.editable: 
                base = self.source_dir 
            </span><span class="s0">else</span><span class="s1">: 
                base = os.path.join(self.setup_py_dir</span><span class="s0">, </span><span class="s2">'pip-egg-info'</span><span class="s1">) 
            filenames = os.listdir(base) 
            </span><span class="s0">if </span><span class="s1">self.editable: 
                filenames = [] 
                </span><span class="s0">for </span><span class="s1">root</span><span class="s0">, </span><span class="s1">dirs</span><span class="s0">, </span><span class="s1">files </span><span class="s0">in </span><span class="s1">os.walk(base): 
                    </span><span class="s0">for </span><span class="s1">dir </span><span class="s0">in </span><span class="s1">vcs.dirnames: 
                        </span><span class="s0">if </span><span class="s1">dir </span><span class="s0">in </span><span class="s1">dirs: 
                            dirs.remove(dir) 
                    </span><span class="s4"># Iterate over a copy of ``dirs``, since mutating</span><span class="s1"> 
                    </span><span class="s4"># a list while iterating over it can cause trouble.</span><span class="s1"> 
                    </span><span class="s4"># (See https://github.com/pypa/pip/pull/462.)</span><span class="s1"> 
                    </span><span class="s0">for </span><span class="s1">dir </span><span class="s0">in </span><span class="s1">list(dirs): 
                        </span><span class="s4"># Don't search in anything that looks like a virtualenv</span><span class="s1"> 
                        </span><span class="s4"># environment</span><span class="s1"> 
                        </span><span class="s0">if </span><span class="s1">( 
                                os.path.lexists( 
                                    os.path.join(root</span><span class="s0">, </span><span class="s1">dir</span><span class="s0">, </span><span class="s2">'bin'</span><span class="s0">, </span><span class="s2">'python'</span><span class="s1">) 
                                ) </span><span class="s0">or</span><span class="s1"> 
                                os.path.exists( 
                                    os.path.join( 
                                        root</span><span class="s0">, </span><span class="s1">dir</span><span class="s0">, </span><span class="s2">'Scripts'</span><span class="s0">, </span><span class="s2">'Python.exe'</span><span class="s1"> 
                                    ) 
                                )): 
                            dirs.remove(dir) 
                        </span><span class="s4"># Also don't search through tests</span><span class="s1"> 
                        </span><span class="s0">elif </span><span class="s1">dir == </span><span class="s2">'test' </span><span class="s0">or </span><span class="s1">dir == </span><span class="s2">'tests'</span><span class="s1">: 
                            dirs.remove(dir) 
                    filenames.extend([os.path.join(root</span><span class="s0">, </span><span class="s1">dir) 
                                     </span><span class="s0">for </span><span class="s1">dir </span><span class="s0">in </span><span class="s1">dirs]) 
                filenames = [f </span><span class="s0">for </span><span class="s1">f </span><span class="s0">in </span><span class="s1">filenames </span><span class="s0">if </span><span class="s1">f.endswith(</span><span class="s2">'.egg-info'</span><span class="s1">)] 
 
            </span><span class="s0">if not </span><span class="s1">filenames: 
                </span><span class="s0">raise </span><span class="s1">InstallationError( 
                    </span><span class="s2">'No files/directories in %s (from %s)' </span><span class="s1">% (base</span><span class="s0">, </span><span class="s1">filename) 
                ) 
            </span><span class="s0">assert </span><span class="s1">filenames</span><span class="s0">, </span><span class="s1">\ 
                </span><span class="s2">&quot;No files/directories in %s (from %s)&quot; </span><span class="s1">% (base</span><span class="s0">, </span><span class="s1">filename) 
 
            </span><span class="s4"># if we have more than one match, we pick the toplevel one.  This</span><span class="s1"> 
            </span><span class="s4"># can easily be the case if there is a dist folder which contains</span><span class="s1"> 
            </span><span class="s4"># an extracted tarball for testing purposes.</span><span class="s1"> 
            </span><span class="s0">if </span><span class="s1">len(filenames) &gt; </span><span class="s3">1</span><span class="s1">: 
                filenames.sort( 
                    key=</span><span class="s0">lambda </span><span class="s1">x: x.count(os.path.sep) + 
                    (os.path.altsep </span><span class="s0">and </span><span class="s1">x.count(os.path.altsep) </span><span class="s0">or </span><span class="s3">0</span><span class="s1">) 
                ) 
            self._egg_info_path = os.path.join(base</span><span class="s0">, </span><span class="s1">filenames[</span><span class="s3">0</span><span class="s1">]) 
        </span><span class="s0">return </span><span class="s1">os.path.join(self._egg_info_path</span><span class="s0">, </span><span class="s1">filename) 
 
    </span><span class="s0">def </span><span class="s1">pkg_info(self): 
        p = FeedParser() 
        data = self.egg_info_data(</span><span class="s2">'PKG-INFO'</span><span class="s1">) 
        </span><span class="s0">if not </span><span class="s1">data: 
            logger.warning( 
                </span><span class="s2">'No PKG-INFO file found in %s'</span><span class="s0">,</span><span class="s1"> 
                display_path(self.egg_info_path(</span><span class="s2">'PKG-INFO'</span><span class="s1">))</span><span class="s0">,</span><span class="s1"> 
            ) 
        p.feed(data </span><span class="s0">or </span><span class="s2">''</span><span class="s1">) 
        </span><span class="s0">return </span><span class="s1">p.close() 
 
    _requirements_section_re = re.compile(</span><span class="s2">r'\[(.*?)\]'</span><span class="s1">) 
 
    @property 
    </span><span class="s0">def </span><span class="s1">installed_version(self): 
        </span><span class="s0">return </span><span class="s1">get_installed_version(self.name) 
 
    </span><span class="s0">def </span><span class="s1">assert_source_matches_version(self): 
        </span><span class="s0">assert </span><span class="s1">self.source_dir 
        version = self.pkg_info()[</span><span class="s2">'version'</span><span class="s1">] 
        </span><span class="s0">if </span><span class="s1">self.req.specifier </span><span class="s0">and </span><span class="s1">version </span><span class="s0">not in </span><span class="s1">self.req.specifier: 
            logger.warning( 
                </span><span class="s2">'Requested %s, but installing version %s'</span><span class="s0">,</span><span class="s1"> 
                self</span><span class="s0">,</span><span class="s1"> 
                self.installed_version</span><span class="s0">,</span><span class="s1"> 
            ) 
        </span><span class="s0">else</span><span class="s1">: 
            logger.debug( 
                </span><span class="s2">'Source in %s has version %s, which satisfies requirement %s'</span><span class="s0">,</span><span class="s1"> 
                display_path(self.source_dir)</span><span class="s0">,</span><span class="s1"> 
                version</span><span class="s0">,</span><span class="s1"> 
                self</span><span class="s0">,</span><span class="s1"> 
            ) 
 
    </span><span class="s0">def </span><span class="s1">update_editable(self</span><span class="s0">, </span><span class="s1">obtain=</span><span class="s0">True</span><span class="s1">): 
        </span><span class="s0">if not </span><span class="s1">self.link: 
            logger.debug( 
                </span><span class="s2">&quot;Cannot update repository at %s; repository location is &quot;</span><span class="s1"> 
                </span><span class="s2">&quot;unknown&quot;</span><span class="s0">,</span><span class="s1"> 
                self.source_dir</span><span class="s0">,</span><span class="s1"> 
            ) 
            </span><span class="s0">return</span><span class="s1"> 
        </span><span class="s0">assert </span><span class="s1">self.editable 
        </span><span class="s0">assert </span><span class="s1">self.source_dir 
        </span><span class="s0">if </span><span class="s1">self.link.scheme == </span><span class="s2">'file'</span><span class="s1">: 
            </span><span class="s4"># Static paths don't get updated</span><span class="s1"> 
            </span><span class="s0">return</span><span class="s1"> 
        </span><span class="s0">assert </span><span class="s2">'+' </span><span class="s0">in </span><span class="s1">self.link.url</span><span class="s0">, </span><span class="s2">&quot;bad url: %r&quot; </span><span class="s1">% self.link.url 
        </span><span class="s0">if not </span><span class="s1">self.update: 
            </span><span class="s0">return</span><span class="s1"> 
        vc_type</span><span class="s0">, </span><span class="s1">url = self.link.url.split(</span><span class="s2">'+'</span><span class="s0">, </span><span class="s3">1</span><span class="s1">) 
        backend = vcs.get_backend(vc_type) 
        </span><span class="s0">if </span><span class="s1">backend: 
            vcs_backend = backend(self.link.url) 
            </span><span class="s0">if </span><span class="s1">obtain: 
                vcs_backend.obtain(self.source_dir) 
            </span><span class="s0">else</span><span class="s1">: 
                vcs_backend.export(self.source_dir) 
        </span><span class="s0">else</span><span class="s1">: 
            </span><span class="s0">assert </span><span class="s3">0</span><span class="s0">, </span><span class="s1">( 
                </span><span class="s2">'Unexpected version control type (in %s): %s'</span><span class="s1"> 
                % (self.link</span><span class="s0">, </span><span class="s1">vc_type)) 
 
    </span><span class="s0">def </span><span class="s1">uninstall(self</span><span class="s0">, </span><span class="s1">auto_confirm=</span><span class="s0">False</span><span class="s1">): 
        </span><span class="s5">&quot;&quot;&quot; 
        Uninstall the distribution currently satisfying this requirement. 
 
        Prompts before removing or modifying files unless 
        ``auto_confirm`` is True. 
 
        Refuses to delete or modify files outside of ``sys.prefix`` - 
        thus uninstallation within a virtual environment can only 
        modify that virtual environment, even if the virtualenv is 
        linked to global site-packages. 
 
        &quot;&quot;&quot;</span><span class="s1"> 
        </span><span class="s0">if not </span><span class="s1">self.check_if_exists(): 
            </span><span class="s0">raise </span><span class="s1">UninstallationError( 
                </span><span class="s2">&quot;Cannot uninstall requirement %s, not installed&quot; </span><span class="s1">% (self.name</span><span class="s0">,</span><span class="s1">) 
            ) 
        dist = self.satisfied_by </span><span class="s0">or </span><span class="s1">self.conflicts_with 
 
        dist_path = normalize_path(dist.location) 
        </span><span class="s0">if not </span><span class="s1">dist_is_local(dist): 
            logger.info( 
                </span><span class="s2">&quot;Not uninstalling %s at %s, outside environment %s&quot;</span><span class="s0">,</span><span class="s1"> 
                dist.key</span><span class="s0">,</span><span class="s1"> 
                dist_path</span><span class="s0">,</span><span class="s1"> 
                sys.prefix</span><span class="s0">,</span><span class="s1"> 
            ) 
            self.nothing_to_uninstall = </span><span class="s0">True</span><span class="s1"> 
            </span><span class="s0">return</span><span class="s1"> 
 
        </span><span class="s0">if </span><span class="s1">dist_path </span><span class="s0">in </span><span class="s1">get_stdlib(): 
            logger.info( 
                </span><span class="s2">&quot;Not uninstalling %s at %s, as it is in the standard library.&quot;</span><span class="s0">,</span><span class="s1"> 
                dist.key</span><span class="s0">,</span><span class="s1"> 
                dist_path</span><span class="s0">,</span><span class="s1"> 
            ) 
            self.nothing_to_uninstall = </span><span class="s0">True</span><span class="s1"> 
            </span><span class="s0">return</span><span class="s1"> 
 
        paths_to_remove = UninstallPathSet(dist) 
        develop_egg_link = egg_link_path(dist) 
        develop_egg_link_egg_info = </span><span class="s2">'{0}.egg-info'</span><span class="s1">.format( 
            pkg_resources.to_filename(dist.project_name)) 
        egg_info_exists = dist.egg_info </span><span class="s0">and </span><span class="s1">os.path.exists(dist.egg_info) 
        </span><span class="s4"># Special case for distutils installed package</span><span class="s1"> 
        distutils_egg_info = getattr(dist._provider</span><span class="s0">, </span><span class="s2">'path'</span><span class="s0">, None</span><span class="s1">) 
 
        </span><span class="s4"># Uninstall cases order do matter as in the case of 2 installs of the</span><span class="s1"> 
        </span><span class="s4"># same package, pip needs to uninstall the currently detected version</span><span class="s1"> 
        </span><span class="s0">if </span><span class="s1">(egg_info_exists </span><span class="s0">and </span><span class="s1">dist.egg_info.endswith(</span><span class="s2">'.egg-info'</span><span class="s1">) </span><span class="s0">and</span><span class="s1"> 
                </span><span class="s0">not </span><span class="s1">dist.egg_info.endswith(develop_egg_link_egg_info)): 
            </span><span class="s4"># if dist.egg_info.endswith(develop_egg_link_egg_info), we</span><span class="s1"> 
            </span><span class="s4"># are in fact in the develop_egg_link case</span><span class="s1"> 
            paths_to_remove.add(dist.egg_info) 
            </span><span class="s0">if </span><span class="s1">dist.has_metadata(</span><span class="s2">'installed-files.txt'</span><span class="s1">): 
                </span><span class="s0">for </span><span class="s1">installed_file </span><span class="s0">in </span><span class="s1">dist.get_metadata( 
                        </span><span class="s2">'installed-files.txt'</span><span class="s1">).splitlines(): 
                    path = os.path.normpath( 
                        os.path.join(dist.egg_info</span><span class="s0">, </span><span class="s1">installed_file) 
                    ) 
                    paths_to_remove.add(path) 
            </span><span class="s4"># FIXME: need a test for this elif block</span><span class="s1"> 
            </span><span class="s4"># occurs with --single-version-externally-managed/--record outside</span><span class="s1"> 
            </span><span class="s4"># of pip</span><span class="s1"> 
            </span><span class="s0">elif </span><span class="s1">dist.has_metadata(</span><span class="s2">'top_level.txt'</span><span class="s1">): 
                </span><span class="s0">if </span><span class="s1">dist.has_metadata(</span><span class="s2">'namespace_packages.txt'</span><span class="s1">): 
                    namespaces = dist.get_metadata(</span><span class="s2">'namespace_packages.txt'</span><span class="s1">) 
                </span><span class="s0">else</span><span class="s1">: 
                    namespaces = [] 
                </span><span class="s0">for </span><span class="s1">top_level_pkg </span><span class="s0">in </span><span class="s1">[ 
                        p </span><span class="s0">for </span><span class="s1">p 
                        </span><span class="s0">in </span><span class="s1">dist.get_metadata(</span><span class="s2">'top_level.txt'</span><span class="s1">).splitlines() 
                        </span><span class="s0">if </span><span class="s1">p </span><span class="s0">and </span><span class="s1">p </span><span class="s0">not in </span><span class="s1">namespaces]: 
                    path = os.path.join(dist.location</span><span class="s0">, </span><span class="s1">top_level_pkg) 
                    paths_to_remove.add(path) 
                    paths_to_remove.add(path + </span><span class="s2">'.py'</span><span class="s1">) 
                    paths_to_remove.add(path + </span><span class="s2">'.pyc'</span><span class="s1">) 
                    paths_to_remove.add(path + </span><span class="s2">'.pyo'</span><span class="s1">) 
 
        </span><span class="s0">elif </span><span class="s1">distutils_egg_info: 
            warnings.warn( 
                </span><span class="s2">&quot;Uninstalling a distutils installed project ({0}) has been &quot;</span><span class="s1"> 
                </span><span class="s2">&quot;deprecated and will be removed in a future version. This is &quot;</span><span class="s1"> 
                </span><span class="s2">&quot;due to the fact that uninstalling a distutils project will &quot;</span><span class="s1"> 
                </span><span class="s2">&quot;only partially uninstall the project.&quot;</span><span class="s1">.format(self.name)</span><span class="s0">,</span><span class="s1"> 
                RemovedInPip10Warning</span><span class="s0">,</span><span class="s1"> 
            ) 
            paths_to_remove.add(distutils_egg_info) 
 
        </span><span class="s0">elif </span><span class="s1">dist.location.endswith(</span><span class="s2">'.egg'</span><span class="s1">): 
            </span><span class="s4"># package installed by easy_install</span><span class="s1"> 
            </span><span class="s4"># We cannot match on dist.egg_name because it can slightly vary</span><span class="s1"> 
            </span><span class="s4"># i.e. setuptools-0.6c11-py2.6.egg vs setuptools-0.6rc11-py2.6.egg</span><span class="s1"> 
            paths_to_remove.add(dist.location) 
            easy_install_egg = os.path.split(dist.location)[</span><span class="s3">1</span><span class="s1">] 
            easy_install_pth = os.path.join(os.path.dirname(dist.location)</span><span class="s0">,</span><span class="s1"> 
                                            </span><span class="s2">'easy-install.pth'</span><span class="s1">) 
            paths_to_remove.add_pth(easy_install_pth</span><span class="s0">, </span><span class="s2">'./' </span><span class="s1">+ easy_install_egg) 
 
        </span><span class="s0">elif </span><span class="s1">egg_info_exists </span><span class="s0">and </span><span class="s1">dist.egg_info.endswith(</span><span class="s2">'.dist-info'</span><span class="s1">): 
            </span><span class="s0">for </span><span class="s1">path </span><span class="s0">in </span><span class="s1">pip.wheel.uninstallation_paths(dist): 
                paths_to_remove.add(path) 
 
        </span><span class="s0">elif </span><span class="s1">develop_egg_link: 
            </span><span class="s4"># develop egg</span><span class="s1"> 
            </span><span class="s0">with </span><span class="s1">open(develop_egg_link</span><span class="s0">, </span><span class="s2">'r'</span><span class="s1">) </span><span class="s0">as </span><span class="s1">fh: 
                link_pointer = os.path.normcase(fh.readline().strip()) 
            </span><span class="s0">assert </span><span class="s1">(link_pointer == dist.location)</span><span class="s0">, </span><span class="s1">( 
                </span><span class="s2">'Egg-link %s does not match installed location of %s '</span><span class="s1"> 
                </span><span class="s2">'(at %s)' </span><span class="s1">% (link_pointer</span><span class="s0">, </span><span class="s1">self.name</span><span class="s0">, </span><span class="s1">dist.location) 
            ) 
            paths_to_remove.add(develop_egg_link) 
            easy_install_pth = os.path.join(os.path.dirname(develop_egg_link)</span><span class="s0">,</span><span class="s1"> 
                                            </span><span class="s2">'easy-install.pth'</span><span class="s1">) 
            paths_to_remove.add_pth(easy_install_pth</span><span class="s0">, </span><span class="s1">dist.location) 
 
        </span><span class="s0">else</span><span class="s1">: 
            logger.debug( 
                </span><span class="s2">'Not sure how to uninstall: %s - Check: %s'</span><span class="s0">,</span><span class="s1"> 
                dist</span><span class="s0">, </span><span class="s1">dist.location) 
 
        </span><span class="s4"># find distutils scripts= scripts</span><span class="s1"> 
        </span><span class="s0">if </span><span class="s1">dist.has_metadata(</span><span class="s2">'scripts'</span><span class="s1">) </span><span class="s0">and </span><span class="s1">dist.metadata_isdir(</span><span class="s2">'scripts'</span><span class="s1">): 
            </span><span class="s0">for </span><span class="s1">script </span><span class="s0">in </span><span class="s1">dist.metadata_listdir(</span><span class="s2">'scripts'</span><span class="s1">): 
                </span><span class="s0">if </span><span class="s1">dist_in_usersite(dist): 
                    bin_dir = bin_user 
                </span><span class="s0">else</span><span class="s1">: 
                    bin_dir = bin_py 
                paths_to_remove.add(os.path.join(bin_dir</span><span class="s0">, </span><span class="s1">script)) 
                </span><span class="s0">if </span><span class="s1">WINDOWS: 
                    paths_to_remove.add(os.path.join(bin_dir</span><span class="s0">, </span><span class="s1">script) + </span><span class="s2">'.bat'</span><span class="s1">) 
 
        </span><span class="s4"># find console_scripts</span><span class="s1"> 
        </span><span class="s0">if </span><span class="s1">dist.has_metadata(</span><span class="s2">'entry_points.txt'</span><span class="s1">): 
            </span><span class="s0">if </span><span class="s1">six.PY2: 
                options = {} 
            </span><span class="s0">else</span><span class="s1">: 
                options = {</span><span class="s2">&quot;delimiters&quot;</span><span class="s1">: (</span><span class="s2">'='</span><span class="s0">, </span><span class="s1">)} 
            config = configparser.SafeConfigParser(**options) 
            config.readfp( 
                FakeFile(dist.get_metadata_lines(</span><span class="s2">'entry_points.txt'</span><span class="s1">)) 
            ) 
            </span><span class="s0">if </span><span class="s1">config.has_section(</span><span class="s2">'console_scripts'</span><span class="s1">): 
                </span><span class="s0">for </span><span class="s1">name</span><span class="s0">, </span><span class="s1">value </span><span class="s0">in </span><span class="s1">config.items(</span><span class="s2">'console_scripts'</span><span class="s1">): 
                    </span><span class="s0">if </span><span class="s1">dist_in_usersite(dist): 
                        bin_dir = bin_user 
                    </span><span class="s0">else</span><span class="s1">: 
                        bin_dir = bin_py 
                    paths_to_remove.add(os.path.join(bin_dir</span><span class="s0">, </span><span class="s1">name)) 
                    </span><span class="s0">if </span><span class="s1">WINDOWS: 
                        paths_to_remove.add( 
                            os.path.join(bin_dir</span><span class="s0">, </span><span class="s1">name) + </span><span class="s2">'.exe'</span><span class="s1"> 
                        ) 
                        paths_to_remove.add( 
                            os.path.join(bin_dir</span><span class="s0">, </span><span class="s1">name) + </span><span class="s2">'.exe.manifest'</span><span class="s1"> 
                        ) 
                        paths_to_remove.add( 
                            os.path.join(bin_dir</span><span class="s0">, </span><span class="s1">name) + </span><span class="s2">'-script.py'</span><span class="s1"> 
                        ) 
 
        paths_to_remove.remove(auto_confirm) 
        self.uninstalled = paths_to_remove 
 
    </span><span class="s0">def </span><span class="s1">rollback_uninstall(self): 
        </span><span class="s0">if </span><span class="s1">self.uninstalled: 
            self.uninstalled.rollback() 
        </span><span class="s0">else</span><span class="s1">: 
            logger.error( 
                </span><span class="s2">&quot;Can't rollback %s, nothing uninstalled.&quot;</span><span class="s0">, </span><span class="s1">self.name</span><span class="s0">,</span><span class="s1"> 
            ) 
 
    </span><span class="s0">def </span><span class="s1">commit_uninstall(self): 
        </span><span class="s0">if </span><span class="s1">self.uninstalled: 
            self.uninstalled.commit() 
        </span><span class="s0">elif not </span><span class="s1">self.nothing_to_uninstall: 
            logger.error( 
                </span><span class="s2">&quot;Can't commit %s, nothing uninstalled.&quot;</span><span class="s0">, </span><span class="s1">self.name</span><span class="s0">,</span><span class="s1"> 
            ) 
 
    </span><span class="s0">def </span><span class="s1">archive(self</span><span class="s0">, </span><span class="s1">build_dir): 
        </span><span class="s0">assert </span><span class="s1">self.source_dir 
        create_archive = </span><span class="s0">True</span><span class="s1"> 
        archive_name = </span><span class="s2">'%s-%s.zip' </span><span class="s1">% (self.name</span><span class="s0">, </span><span class="s1">self.pkg_info()[</span><span class="s2">&quot;version&quot;</span><span class="s1">]) 
        archive_path = os.path.join(build_dir</span><span class="s0">, </span><span class="s1">archive_name) 
        </span><span class="s0">if </span><span class="s1">os.path.exists(archive_path): 
            response = ask_path_exists( 
                </span><span class="s2">'The file %s exists. (i)gnore, (w)ipe, (b)ackup, (a)bort ' </span><span class="s1">% 
                display_path(archive_path)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">'i'</span><span class="s0">, </span><span class="s2">'w'</span><span class="s0">, </span><span class="s2">'b'</span><span class="s0">, </span><span class="s2">'a'</span><span class="s1">)) 
            </span><span class="s0">if </span><span class="s1">response == </span><span class="s2">'i'</span><span class="s1">: 
                create_archive = </span><span class="s0">False</span><span class="s1"> 
            </span><span class="s0">elif </span><span class="s1">response == </span><span class="s2">'w'</span><span class="s1">: 
                logger.warning(</span><span class="s2">'Deleting %s'</span><span class="s0">, </span><span class="s1">display_path(archive_path)) 
                os.remove(archive_path) 
            </span><span class="s0">elif </span><span class="s1">response == </span><span class="s2">'b'</span><span class="s1">: 
                dest_file = backup_dir(archive_path) 
                logger.warning( 
                    </span><span class="s2">'Backing up %s to %s'</span><span class="s0">,</span><span class="s1"> 
                    display_path(archive_path)</span><span class="s0">,</span><span class="s1"> 
                    display_path(dest_file)</span><span class="s0">,</span><span class="s1"> 
                ) 
                shutil.move(archive_path</span><span class="s0">, </span><span class="s1">dest_file) 
            </span><span class="s0">elif </span><span class="s1">response == </span><span class="s2">'a'</span><span class="s1">: 
                sys.exit(-</span><span class="s3">1</span><span class="s1">) 
        </span><span class="s0">if </span><span class="s1">create_archive: 
            zip = zipfile.ZipFile( 
                archive_path</span><span class="s0">, </span><span class="s2">'w'</span><span class="s0">, </span><span class="s1">zipfile.ZIP_DEFLATED</span><span class="s0">,</span><span class="s1"> 
                allowZip64=</span><span class="s0">True</span><span class="s1"> 
            ) 
            dir = os.path.normcase(os.path.abspath(self.setup_py_dir)) 
            </span><span class="s0">for </span><span class="s1">dirpath</span><span class="s0">, </span><span class="s1">dirnames</span><span class="s0">, </span><span class="s1">filenames </span><span class="s0">in </span><span class="s1">os.walk(dir): 
                </span><span class="s0">if </span><span class="s2">'pip-egg-info' </span><span class="s0">in </span><span class="s1">dirnames: 
                    dirnames.remove(</span><span class="s2">'pip-egg-info'</span><span class="s1">) 
                </span><span class="s0">for </span><span class="s1">dirname </span><span class="s0">in </span><span class="s1">dirnames: 
                    dirname = os.path.join(dirpath</span><span class="s0">, </span><span class="s1">dirname) 
                    name = self._clean_zip_name(dirname</span><span class="s0">, </span><span class="s1">dir) 
                    zipdir = zipfile.ZipInfo(self.name + </span><span class="s2">'/' </span><span class="s1">+ name + </span><span class="s2">'/'</span><span class="s1">) 
                    zipdir.external_attr = </span><span class="s3">0x1ED </span><span class="s1">&lt;&lt; </span><span class="s3">16  </span><span class="s4"># 0o755</span><span class="s1"> 
                    zip.writestr(zipdir</span><span class="s0">, </span><span class="s2">''</span><span class="s1">) 
                </span><span class="s0">for </span><span class="s1">filename </span><span class="s0">in </span><span class="s1">filenames: 
                    </span><span class="s0">if </span><span class="s1">filename == PIP_DELETE_MARKER_FILENAME: 
                        </span><span class="s0">continue</span><span class="s1"> 
                    filename = os.path.join(dirpath</span><span class="s0">, </span><span class="s1">filename) 
                    name = self._clean_zip_name(filename</span><span class="s0">, </span><span class="s1">dir) 
                    zip.write(filename</span><span class="s0">, </span><span class="s1">self.name + </span><span class="s2">'/' </span><span class="s1">+ name) 
            zip.close() 
            logger.info(</span><span class="s2">'Saved %s'</span><span class="s0">, </span><span class="s1">display_path(archive_path)) 
 
    </span><span class="s0">def </span><span class="s1">_clean_zip_name(self</span><span class="s0">, </span><span class="s1">name</span><span class="s0">, </span><span class="s1">prefix): 
        </span><span class="s0">assert </span><span class="s1">name.startswith(prefix + os.path.sep)</span><span class="s0">, </span><span class="s1">( 
            </span><span class="s2">&quot;name %r doesn't start with prefix %r&quot; </span><span class="s1">% (name</span><span class="s0">, </span><span class="s1">prefix) 
        ) 
        name = name[len(prefix) + </span><span class="s3">1</span><span class="s1">:] 
        name = name.replace(os.path.sep</span><span class="s0">, </span><span class="s2">'/'</span><span class="s1">) 
        </span><span class="s0">return </span><span class="s1">name 
 
    </span><span class="s0">def </span><span class="s1">match_markers(self</span><span class="s0">, </span><span class="s1">extras_requested=</span><span class="s0">None</span><span class="s1">): 
        </span><span class="s0">if not </span><span class="s1">extras_requested: 
            </span><span class="s4"># Provide an extra to safely evaluate the markers</span><span class="s1"> 
            </span><span class="s4"># without matching any extra</span><span class="s1"> 
            extras_requested = (</span><span class="s2">''</span><span class="s0">,</span><span class="s1">) 
        </span><span class="s0">if </span><span class="s1">self.markers </span><span class="s0">is not None</span><span class="s1">: 
            </span><span class="s0">return </span><span class="s1">any( 
                self.markers.evaluate({</span><span class="s2">'extra'</span><span class="s1">: extra}) 
                </span><span class="s0">for </span><span class="s1">extra </span><span class="s0">in </span><span class="s1">extras_requested) 
        </span><span class="s0">else</span><span class="s1">: 
            </span><span class="s0">return True</span><span class="s1"> 
 
    </span><span class="s0">def </span><span class="s1">install(self</span><span class="s0">, </span><span class="s1">install_options</span><span class="s0">, </span><span class="s1">global_options=[]</span><span class="s0">, </span><span class="s1">root=</span><span class="s0">None,</span><span class="s1"> 
                prefix=</span><span class="s0">None</span><span class="s1">): 
        </span><span class="s0">if </span><span class="s1">self.editable: 
            self.install_editable( 
                install_options</span><span class="s0">, </span><span class="s1">global_options</span><span class="s0">, </span><span class="s1">prefix=prefix) 
            </span><span class="s0">return</span><span class="s1"> 
        </span><span class="s0">if </span><span class="s1">self.is_wheel: 
            version = pip.wheel.wheel_version(self.source_dir) 
            pip.wheel.check_compatibility(version</span><span class="s0">, </span><span class="s1">self.name) 
 
            self.move_wheel_files(self.source_dir</span><span class="s0">, </span><span class="s1">root=root</span><span class="s0">, </span><span class="s1">prefix=prefix) 
            self.install_succeeded = </span><span class="s0">True</span><span class="s1"> 
            </span><span class="s0">return</span><span class="s1"> 
 
        </span><span class="s4"># Extend the list of global and install options passed on to</span><span class="s1"> 
        </span><span class="s4"># the setup.py call with the ones from the requirements file.</span><span class="s1"> 
        </span><span class="s4"># Options specified in requirements file override those</span><span class="s1"> 
        </span><span class="s4"># specified on the command line, since the last option given</span><span class="s1"> 
        </span><span class="s4"># to setup.py is the one that is used.</span><span class="s1"> 
        global_options += self.options.get(</span><span class="s2">'global_options'</span><span class="s0">, </span><span class="s1">[]) 
        install_options += self.options.get(</span><span class="s2">'install_options'</span><span class="s0">, </span><span class="s1">[]) 
 
        </span><span class="s0">if </span><span class="s1">self.isolated: 
            global_options = list(global_options) + [</span><span class="s2">&quot;--no-user-cfg&quot;</span><span class="s1">] 
 
        temp_location = tempfile.mkdtemp(</span><span class="s2">'-record'</span><span class="s0">, </span><span class="s2">'pip-'</span><span class="s1">) 
        record_filename = os.path.join(temp_location</span><span class="s0">, </span><span class="s2">'install-record.txt'</span><span class="s1">) 
        </span><span class="s0">try</span><span class="s1">: 
            install_args = self.get_install_args( 
                global_options</span><span class="s0">, </span><span class="s1">record_filename</span><span class="s0">, </span><span class="s1">root</span><span class="s0">, </span><span class="s1">prefix) 
            msg = </span><span class="s2">'Running setup.py install for %s' </span><span class="s1">% (self.name</span><span class="s0">,</span><span class="s1">) 
            </span><span class="s0">with </span><span class="s1">open_spinner(msg) </span><span class="s0">as </span><span class="s1">spinner: 
                </span><span class="s0">with </span><span class="s1">indent_log(): 
                    call_subprocess( 
                        install_args + install_options</span><span class="s0">,</span><span class="s1"> 
                        cwd=self.setup_py_dir</span><span class="s0">,</span><span class="s1"> 
                        show_stdout=</span><span class="s0">False,</span><span class="s1"> 
                        spinner=spinner</span><span class="s0">,</span><span class="s1"> 
                    ) 
 
            </span><span class="s0">if not </span><span class="s1">os.path.exists(record_filename): 
                logger.debug(</span><span class="s2">'Record file %s not found'</span><span class="s0">, </span><span class="s1">record_filename) 
                </span><span class="s0">return</span><span class="s1"> 
            self.install_succeeded = </span><span class="s0">True</span><span class="s1"> 
            </span><span class="s0">if </span><span class="s1">self.as_egg: 
                </span><span class="s4"># there's no --always-unzip option we can pass to install</span><span class="s1"> 
                </span><span class="s4"># command so we unable to save the installed-files.txt</span><span class="s1"> 
                </span><span class="s0">return</span><span class="s1"> 
 
            </span><span class="s0">def </span><span class="s1">prepend_root(path): 
                </span><span class="s0">if </span><span class="s1">root </span><span class="s0">is None or not </span><span class="s1">os.path.isabs(path): 
                    </span><span class="s0">return </span><span class="s1">path 
                </span><span class="s0">else</span><span class="s1">: 
                    </span><span class="s0">return </span><span class="s1">change_root(root</span><span class="s0">, </span><span class="s1">path) 
 
            </span><span class="s0">with </span><span class="s1">open(record_filename) </span><span class="s0">as </span><span class="s1">f: 
                </span><span class="s0">for </span><span class="s1">line </span><span class="s0">in </span><span class="s1">f: 
                    directory = os.path.dirname(line) 
                    </span><span class="s0">if </span><span class="s1">directory.endswith(</span><span class="s2">'.egg-info'</span><span class="s1">): 
                        egg_info_dir = prepend_root(directory) 
                        </span><span class="s0">break</span><span class="s1"> 
                </span><span class="s0">else</span><span class="s1">: 
                    logger.warning( 
                        </span><span class="s2">'Could not find .egg-info directory in install record'</span><span class="s1"> 
                        </span><span class="s2">' for %s'</span><span class="s0">,</span><span class="s1"> 
                        self</span><span class="s0">,</span><span class="s1"> 
                    ) 
                    </span><span class="s4"># FIXME: put the record somewhere</span><span class="s1"> 
                    </span><span class="s4"># FIXME: should this be an error?</span><span class="s1"> 
                    </span><span class="s0">return</span><span class="s1"> 
            new_lines = [] 
            </span><span class="s0">with </span><span class="s1">open(record_filename) </span><span class="s0">as </span><span class="s1">f: 
                </span><span class="s0">for </span><span class="s1">line </span><span class="s0">in </span><span class="s1">f: 
                    filename = line.strip() 
                    </span><span class="s0">if </span><span class="s1">os.path.isdir(filename): 
                        filename += os.path.sep 
                    new_lines.append( 
                        os.path.relpath( 
                            prepend_root(filename)</span><span class="s0">, </span><span class="s1">egg_info_dir) 
                    ) 
            inst_files_path = os.path.join(egg_info_dir</span><span class="s0">, </span><span class="s2">'installed-files.txt'</span><span class="s1">) 
            </span><span class="s0">with </span><span class="s1">open(inst_files_path</span><span class="s0">, </span><span class="s2">'w'</span><span class="s1">) </span><span class="s0">as </span><span class="s1">f: 
                f.write(</span><span class="s2">'</span><span class="s0">\n</span><span class="s2">'</span><span class="s1">.join(new_lines) + </span><span class="s2">'</span><span class="s0">\n</span><span class="s2">'</span><span class="s1">) 
        </span><span class="s0">finally</span><span class="s1">: 
            </span><span class="s0">if </span><span class="s1">os.path.exists(record_filename): 
                os.remove(record_filename) 
            rmtree(temp_location) 
 
    </span><span class="s0">def </span><span class="s1">ensure_has_source_dir(self</span><span class="s0">, </span><span class="s1">parent_dir): 
        </span><span class="s5">&quot;&quot;&quot;Ensure that a source_dir is set. 
 
        This will create a temporary build dir if the name of the requirement 
        isn't known yet. 
 
        :param parent_dir: The ideal pip parent_dir for the source_dir. 
            Generally src_dir for editables and build_dir for sdists. 
        :return: self.source_dir 
        &quot;&quot;&quot;</span><span class="s1"> 
        </span><span class="s0">if </span><span class="s1">self.source_dir </span><span class="s0">is None</span><span class="s1">: 
            self.source_dir = self.build_location(parent_dir) 
        </span><span class="s0">return </span><span class="s1">self.source_dir 
 
    </span><span class="s0">def </span><span class="s1">get_install_args(self</span><span class="s0">, </span><span class="s1">global_options</span><span class="s0">, </span><span class="s1">record_filename</span><span class="s0">, </span><span class="s1">root</span><span class="s0">, </span><span class="s1">prefix): 
        install_args = [sys.executable</span><span class="s0">, </span><span class="s2">&quot;-u&quot;</span><span class="s1">] 
        install_args.append(</span><span class="s2">'-c'</span><span class="s1">) 
        install_args.append(SETUPTOOLS_SHIM % self.setup_py) 
        install_args += list(global_options) + \ 
            [</span><span class="s2">'install'</span><span class="s0">, </span><span class="s2">'--record'</span><span class="s0">, </span><span class="s1">record_filename] 
 
        </span><span class="s0">if not </span><span class="s1">self.as_egg: 
            install_args += [</span><span class="s2">'--single-version-externally-managed'</span><span class="s1">] 
 
        </span><span class="s0">if </span><span class="s1">root </span><span class="s0">is not None</span><span class="s1">: 
            install_args += [</span><span class="s2">'--root'</span><span class="s0">, </span><span class="s1">root] 
        </span><span class="s0">if </span><span class="s1">prefix </span><span class="s0">is not None</span><span class="s1">: 
            install_args += [</span><span class="s2">'--prefix'</span><span class="s0">, </span><span class="s1">prefix] 
 
        </span><span class="s0">if </span><span class="s1">self.pycompile: 
            install_args += [</span><span class="s2">&quot;--compile&quot;</span><span class="s1">] 
        </span><span class="s0">else</span><span class="s1">: 
            install_args += [</span><span class="s2">&quot;--no-compile&quot;</span><span class="s1">] 
 
        </span><span class="s0">if </span><span class="s1">running_under_virtualenv(): 
            py_ver_str = </span><span class="s2">'python' </span><span class="s1">+ sysconfig.get_python_version() 
            install_args += [</span><span class="s2">'--install-headers'</span><span class="s0">,</span><span class="s1"> 
                             os.path.join(sys.prefix</span><span class="s0">, </span><span class="s2">'include'</span><span class="s0">, </span><span class="s2">'site'</span><span class="s0">,</span><span class="s1"> 
                                          py_ver_str</span><span class="s0">, </span><span class="s1">self.name)] 
 
        </span><span class="s0">return </span><span class="s1">install_args 
 
    </span><span class="s0">def </span><span class="s1">remove_temporary_source(self): 
        </span><span class="s5">&quot;&quot;&quot;Remove the source files from this requirement, if they are marked 
        for deletion&quot;&quot;&quot;</span><span class="s1"> 
        </span><span class="s0">if </span><span class="s1">self.source_dir </span><span class="s0">and </span><span class="s1">os.path.exists( 
                os.path.join(self.source_dir</span><span class="s0">, </span><span class="s1">PIP_DELETE_MARKER_FILENAME)): 
            logger.debug(</span><span class="s2">'Removing source in %s'</span><span class="s0">, </span><span class="s1">self.source_dir) 
            rmtree(self.source_dir) 
        self.source_dir = </span><span class="s0">None</span><span class="s1"> 
        </span><span class="s0">if </span><span class="s1">self._temp_build_dir </span><span class="s0">and </span><span class="s1">os.path.exists(self._temp_build_dir): 
            rmtree(self._temp_build_dir) 
        self._temp_build_dir = </span><span class="s0">None</span><span class="s1"> 
 
    </span><span class="s0">def </span><span class="s1">install_editable(self</span><span class="s0">, </span><span class="s1">install_options</span><span class="s0">,</span><span class="s1"> 
                         global_options=()</span><span class="s0">, </span><span class="s1">prefix=</span><span class="s0">None</span><span class="s1">): 
        logger.info(</span><span class="s2">'Running setup.py develop for %s'</span><span class="s0">, </span><span class="s1">self.name) 
 
        </span><span class="s0">if </span><span class="s1">self.isolated: 
            global_options = list(global_options) + [</span><span class="s2">&quot;--no-user-cfg&quot;</span><span class="s1">] 
 
        </span><span class="s0">if </span><span class="s1">prefix: 
            prefix_param = [</span><span class="s2">'--prefix={0}'</span><span class="s1">.format(prefix)] 
            install_options = list(install_options) + prefix_param 
 
        </span><span class="s0">with </span><span class="s1">indent_log(): 
            </span><span class="s4"># FIXME: should we do --install-headers here too?</span><span class="s1"> 
            call_subprocess( 
                [ 
                    sys.executable</span><span class="s0">,</span><span class="s1"> 
                    </span><span class="s2">'-c'</span><span class="s0">,</span><span class="s1"> 
                    SETUPTOOLS_SHIM % self.setup_py 
                ] + 
                list(global_options) + 
                [</span><span class="s2">'develop'</span><span class="s0">, </span><span class="s2">'--no-deps'</span><span class="s1">] + 
                list(install_options)</span><span class="s0">,</span><span class="s1"> 
 
                cwd=self.setup_py_dir</span><span class="s0">,</span><span class="s1"> 
                show_stdout=</span><span class="s0">False</span><span class="s1">) 
 
        self.install_succeeded = </span><span class="s0">True</span><span class="s1"> 
 
    </span><span class="s0">def </span><span class="s1">check_if_exists(self): 
        </span><span class="s5">&quot;&quot;&quot;Find an installed distribution that satisfies or conflicts 
        with this requirement, and set self.satisfied_by or 
        self.conflicts_with appropriately. 
        &quot;&quot;&quot;</span><span class="s1"> 
        </span><span class="s0">if </span><span class="s1">self.req </span><span class="s0">is None</span><span class="s1">: 
            </span><span class="s0">return False</span><span class="s1"> 
        </span><span class="s0">try</span><span class="s1">: 
            </span><span class="s4"># get_distribution() will resolve the entire list of requirements</span><span class="s1"> 
            </span><span class="s4"># anyway, and we've already determined that we need the requirement</span><span class="s1"> 
            </span><span class="s4"># in question, so strip the marker so that we don't try to</span><span class="s1"> 
            </span><span class="s4"># evaluate it.</span><span class="s1"> 
            no_marker = Requirement(str(self.req)) 
            no_marker.marker = </span><span class="s0">None</span><span class="s1"> 
            self.satisfied_by = pkg_resources.get_distribution(str(no_marker)) 
            </span><span class="s0">if </span><span class="s1">self.editable </span><span class="s0">and </span><span class="s1">self.satisfied_by: 
                self.conflicts_with = self.satisfied_by 
                </span><span class="s4"># when installing editables, nothing pre-existing should ever</span><span class="s1"> 
                </span><span class="s4"># satisfy</span><span class="s1"> 
                self.satisfied_by = </span><span class="s0">None</span><span class="s1"> 
                </span><span class="s0">return True</span><span class="s1"> 
        </span><span class="s0">except </span><span class="s1">pkg_resources.DistributionNotFound: 
            </span><span class="s0">return False</span><span class="s1"> 
        </span><span class="s0">except </span><span class="s1">pkg_resources.VersionConflict: 
            existing_dist = pkg_resources.get_distribution( 
                self.req.name 
            ) 
            </span><span class="s0">if </span><span class="s1">self.use_user_site: 
                </span><span class="s0">if </span><span class="s1">dist_in_usersite(existing_dist): 
                    self.conflicts_with = existing_dist 
                </span><span class="s0">elif </span><span class="s1">(running_under_virtualenv() </span><span class="s0">and</span><span class="s1"> 
                        dist_in_site_packages(existing_dist)): 
                    </span><span class="s0">raise </span><span class="s1">InstallationError( 
                        </span><span class="s2">&quot;Will not install to the user site because it will &quot;</span><span class="s1"> 
                        </span><span class="s2">&quot;lack sys.path precedence to %s in %s&quot; </span><span class="s1">% 
                        (existing_dist.project_name</span><span class="s0">, </span><span class="s1">existing_dist.location) 
                    ) 
            </span><span class="s0">else</span><span class="s1">: 
                self.conflicts_with = existing_dist 
        </span><span class="s0">return True</span><span class="s1"> 
 
    @property 
    </span><span class="s0">def </span><span class="s1">is_wheel(self): 
        </span><span class="s0">return </span><span class="s1">self.link </span><span class="s0">and </span><span class="s1">self.link.is_wheel 
 
    </span><span class="s0">def </span><span class="s1">move_wheel_files(self</span><span class="s0">, </span><span class="s1">wheeldir</span><span class="s0">, </span><span class="s1">root=</span><span class="s0">None, </span><span class="s1">prefix=</span><span class="s0">None</span><span class="s1">): 
        move_wheel_files( 
            self.name</span><span class="s0">, </span><span class="s1">self.req</span><span class="s0">, </span><span class="s1">wheeldir</span><span class="s0">,</span><span class="s1"> 
            user=self.use_user_site</span><span class="s0">,</span><span class="s1"> 
            home=self.target_dir</span><span class="s0">,</span><span class="s1"> 
            root=root</span><span class="s0">,</span><span class="s1"> 
            prefix=prefix</span><span class="s0">,</span><span class="s1"> 
            pycompile=self.pycompile</span><span class="s0">,</span><span class="s1"> 
            isolated=self.isolated</span><span class="s0">,</span><span class="s1"> 
        ) 
 
    </span><span class="s0">def </span><span class="s1">get_dist(self): 
        </span><span class="s5">&quot;&quot;&quot;Return a pkg_resources.Distribution built from self.egg_info_path&quot;&quot;&quot;</span><span class="s1"> 
        egg_info = self.egg_info_path(</span><span class="s2">''</span><span class="s1">).rstrip(</span><span class="s2">'/'</span><span class="s1">) 
        base_dir = os.path.dirname(egg_info) 
        metadata = pkg_resources.PathMetadata(base_dir</span><span class="s0">, </span><span class="s1">egg_info) 
        dist_name = os.path.splitext(os.path.basename(egg_info))[</span><span class="s3">0</span><span class="s1">] 
        </span><span class="s0">return </span><span class="s1">pkg_resources.Distribution( 
            os.path.dirname(egg_info)</span><span class="s0">,</span><span class="s1"> 
            project_name=dist_name</span><span class="s0">,</span><span class="s1"> 
            metadata=metadata) 
 
    @property 
    </span><span class="s0">def </span><span class="s1">has_hash_options(self): 
        </span><span class="s5">&quot;&quot;&quot;Return whether any known-good hashes are specified as options. 
 
        These activate --require-hashes mode; hashes specified as part of a 
        URL do not. 
 
        &quot;&quot;&quot;</span><span class="s1"> 
        </span><span class="s0">return </span><span class="s1">bool(self.options.get(</span><span class="s2">'hashes'</span><span class="s0">, </span><span class="s1">{})) 
 
    </span><span class="s0">def </span><span class="s1">hashes(self</span><span class="s0">, </span><span class="s1">trust_internet=</span><span class="s0">True</span><span class="s1">): 
        </span><span class="s5">&quot;&quot;&quot;Return a hash-comparer that considers my option- and URL-based 
        hashes to be known-good. 
 
        Hashes in URLs--ones embedded in the requirements file, not ones 
        downloaded from an index server--are almost peers with ones from 
        flags. They satisfy --require-hashes (whether it was implicitly or 
        explicitly activated) but do not activate it. md5 and sha224 are not 
        allowed in flags, which should nudge people toward good algos. We 
        always OR all hashes together, even ones from URLs. 
 
        :param trust_internet: Whether to trust URL-based (#md5=...) hashes 
            downloaded from the internet, as by populate_link() 
 
        &quot;&quot;&quot;</span><span class="s1"> 
        good_hashes = self.options.get(</span><span class="s2">'hashes'</span><span class="s0">, </span><span class="s1">{}).copy() 
        link = self.link </span><span class="s0">if </span><span class="s1">trust_internet </span><span class="s0">else </span><span class="s1">self.original_link 
        </span><span class="s0">if </span><span class="s1">link </span><span class="s0">and </span><span class="s1">link.hash: 
            good_hashes.setdefault(link.hash_name</span><span class="s0">, </span><span class="s1">[]).append(link.hash) 
        </span><span class="s0">return </span><span class="s1">Hashes(good_hashes) 
 
 
</span><span class="s0">def </span><span class="s1">_strip_postfix(req): 
    </span><span class="s5">&quot;&quot;&quot; 
        Strip req postfix ( -dev, 0.2, etc ) 
    &quot;&quot;&quot;</span><span class="s1"> 
    </span><span class="s4"># FIXME: use package_to_requirement?</span><span class="s1"> 
    match = re.search(</span><span class="s2">r'^(.*?)(?:-dev|-\d.*)$'</span><span class="s0">, </span><span class="s1">req) 
    </span><span class="s0">if </span><span class="s1">match: 
        </span><span class="s4"># Strip off -dev, -0.2, etc.</span><span class="s1"> 
        req = match.group(</span><span class="s3">1</span><span class="s1">) 
    </span><span class="s0">return </span><span class="s1">req 
 
 
</span><span class="s0">def </span><span class="s1">parse_editable(editable_req</span><span class="s0">, </span><span class="s1">default_vcs=</span><span class="s0">None</span><span class="s1">): 
    </span><span class="s5">&quot;&quot;&quot;Parses an editable requirement into: 
        - a requirement name 
        - an URL 
        - extras 
        - editable options 
    Accepted requirements: 
        svn+http://blahblah@rev#egg=Foobar[baz]&amp;subdirectory=version_subdir 
        .[some_extra] 
    &quot;&quot;&quot;</span><span class="s1"> 
 
    </span><span class="s0">from </span><span class="s1">pip.index </span><span class="s0">import </span><span class="s1">Link 
 
    url = editable_req 
    extras = </span><span class="s0">None</span><span class="s1"> 
 
    </span><span class="s4"># If a file path is specified with extras, strip off the extras.</span><span class="s1"> 
    m = re.match(</span><span class="s2">r'^(.+)(\[[^\]]+\])$'</span><span class="s0">, </span><span class="s1">url) 
    </span><span class="s0">if </span><span class="s1">m: 
        url_no_extras = m.group(</span><span class="s3">1</span><span class="s1">) 
        extras = m.group(</span><span class="s3">2</span><span class="s1">) 
    </span><span class="s0">else</span><span class="s1">: 
        url_no_extras = url 
 
    </span><span class="s0">if </span><span class="s1">os.path.isdir(url_no_extras): 
        </span><span class="s0">if not </span><span class="s1">os.path.exists(os.path.join(url_no_extras</span><span class="s0">, </span><span class="s2">'setup.py'</span><span class="s1">)): 
            </span><span class="s0">raise </span><span class="s1">InstallationError( 
                </span><span class="s2">&quot;Directory %r is not installable. File 'setup.py' not found.&quot; </span><span class="s1">% 
                url_no_extras 
            ) 
        </span><span class="s4"># Treating it as code that has already been checked out</span><span class="s1"> 
        url_no_extras = path_to_url(url_no_extras) 
 
    </span><span class="s0">if </span><span class="s1">url_no_extras.lower().startswith(</span><span class="s2">'file:'</span><span class="s1">): 
        package_name = Link(url_no_extras).egg_fragment 
        </span><span class="s0">if </span><span class="s1">extras: 
            </span><span class="s0">return </span><span class="s1">( 
                package_name</span><span class="s0">,</span><span class="s1"> 
                url_no_extras</span><span class="s0">,</span><span class="s1"> 
                Requirement(</span><span class="s2">&quot;placeholder&quot; </span><span class="s1">+ extras.lower()).extras</span><span class="s0">,</span><span class="s1"> 
            ) 
        </span><span class="s0">else</span><span class="s1">: 
            </span><span class="s0">return </span><span class="s1">package_name</span><span class="s0">, </span><span class="s1">url_no_extras</span><span class="s0">, None</span><span class="s1"> 
 
    </span><span class="s0">for </span><span class="s1">version_control </span><span class="s0">in </span><span class="s1">vcs: 
        </span><span class="s0">if </span><span class="s1">url.lower().startswith(</span><span class="s2">'%s:' </span><span class="s1">% version_control): 
            url = </span><span class="s2">'%s+%s' </span><span class="s1">% (version_control</span><span class="s0">, </span><span class="s1">url) 
            </span><span class="s0">break</span><span class="s1"> 
 
    </span><span class="s0">if </span><span class="s2">'+' </span><span class="s0">not in </span><span class="s1">url: 
        </span><span class="s0">if </span><span class="s1">default_vcs: 
            warnings.warn( 
                </span><span class="s2">&quot;--default-vcs has been deprecated and will be removed in &quot;</span><span class="s1"> 
                </span><span class="s2">&quot;the future.&quot;</span><span class="s0">,</span><span class="s1"> 
                RemovedInPip10Warning</span><span class="s0">,</span><span class="s1"> 
            ) 
            url = default_vcs + </span><span class="s2">'+' </span><span class="s1">+ url 
        </span><span class="s0">else</span><span class="s1">: 
            </span><span class="s0">raise </span><span class="s1">InstallationError( 
                </span><span class="s2">'%s should either be a path to a local project or a VCS url '</span><span class="s1"> 
                </span><span class="s2">'beginning with svn+, git+, hg+, or bzr+' </span><span class="s1">% 
                editable_req 
            ) 
 
    vc_type = url.split(</span><span class="s2">'+'</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)[</span><span class="s3">0</span><span class="s1">].lower() 
 
    </span><span class="s0">if not </span><span class="s1">vcs.get_backend(vc_type): 
        error_message = </span><span class="s2">'For --editable=%s only ' </span><span class="s1">% editable_req + \ 
            </span><span class="s2">', '</span><span class="s1">.join([backend.name + </span><span class="s2">'+URL' </span><span class="s0">for </span><span class="s1">backend </span><span class="s0">in </span><span class="s1">vcs.backends]) + \ 
            </span><span class="s2">' is currently supported'</span><span class="s1"> 
        </span><span class="s0">raise </span><span class="s1">InstallationError(error_message) 
 
    package_name = Link(url).egg_fragment 
    </span><span class="s0">if not </span><span class="s1">package_name: 
        </span><span class="s0">raise </span><span class="s1">InstallationError( 
            </span><span class="s2">&quot;Could not detect requirement name, please specify one with #egg=&quot;</span><span class="s1"> 
        ) 
    </span><span class="s0">if not </span><span class="s1">package_name: 
        </span><span class="s0">raise </span><span class="s1">InstallationError( 
            </span><span class="s2">'--editable=%s is not the right format; it must have '</span><span class="s1"> 
            </span><span class="s2">'#egg=Package' </span><span class="s1">% editable_req 
        ) 
    </span><span class="s0">return </span><span class="s1">_strip_postfix(package_name)</span><span class="s0">, </span><span class="s1">url</span><span class="s0">, None</span><span class="s1"> 
</span></pre>
</body>
</html>