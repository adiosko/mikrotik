<html>
<head>
<title>universaldetector.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.ln { color: #606366; font-weight: normal; font-style: normal; }
.s0 { color: rgb(128,128,128); }
.s1 { color: rgb(169,183,198); }
.s2 { color: rgb(204,120,50); }
.s3 { color: rgb(104,151,187); }
.s4 { color: rgb(165,194,97); }
.s5 { color: rgb(106,135,89); }
</style>
</head>
<BODY BGCOLOR="#2b2b2b">
<TABLE CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<TR><TD><CENTER>
<FONT FACE="Arial, Helvetica" COLOR="#000000">
universaldetector.py</FONT>
</center></TD></TR></TABLE>
<pre>
<span class="s0">######################## BEGIN LICENSE BLOCK ########################</span><span class="s1"> 
</span><span class="s0"># The Original Code is Mozilla Universal charset detector code.</span><span class="s1"> 
</span><span class="s0">#</span><span class="s1"> 
</span><span class="s0"># The Initial Developer of the Original Code is</span><span class="s1"> 
</span><span class="s0"># Netscape Communications Corporation.</span><span class="s1"> 
</span><span class="s0"># Portions created by the Initial Developer are Copyright (C) 2001</span><span class="s1"> 
</span><span class="s0"># the Initial Developer. All Rights Reserved.</span><span class="s1"> 
</span><span class="s0">#</span><span class="s1"> 
</span><span class="s0"># Contributor(s):</span><span class="s1"> 
</span><span class="s0">#   Mark Pilgrim - port to Python</span><span class="s1"> 
</span><span class="s0">#   Shy Shalom - original C code</span><span class="s1"> 
</span><span class="s0">#</span><span class="s1"> 
</span><span class="s0"># This library is free software; you can redistribute it and/or</span><span class="s1"> 
</span><span class="s0"># modify it under the terms of the GNU Lesser General Public</span><span class="s1"> 
</span><span class="s0"># License as published by the Free Software Foundation; either</span><span class="s1"> 
</span><span class="s0"># version 2.1 of the License, or (at your option) any later version.</span><span class="s1"> 
</span><span class="s0">#</span><span class="s1"> 
</span><span class="s0"># This library is distributed in the hope that it will be useful,</span><span class="s1"> 
</span><span class="s0"># but WITHOUT ANY WARRANTY; without even the implied warranty of</span><span class="s1"> 
</span><span class="s0"># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span><span class="s1"> 
</span><span class="s0"># Lesser General Public License for more details.</span><span class="s1"> 
</span><span class="s0">#</span><span class="s1"> 
</span><span class="s0"># You should have received a copy of the GNU Lesser General Public</span><span class="s1"> 
</span><span class="s0"># License along with this library; if not, write to the Free Software</span><span class="s1"> 
</span><span class="s0"># Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA</span><span class="s1"> 
</span><span class="s0"># 02110-1301  USA</span><span class="s1"> 
</span><span class="s0">######################### END LICENSE BLOCK #########################</span><span class="s1"> 
 
</span><span class="s2">from </span><span class="s1">. </span><span class="s2">import </span><span class="s1">constants 
</span><span class="s2">import </span><span class="s1">sys 
</span><span class="s2">import </span><span class="s1">codecs 
</span><span class="s2">from </span><span class="s1">.latin1prober </span><span class="s2">import </span><span class="s1">Latin1Prober  </span><span class="s0"># windows-1252</span><span class="s1"> 
</span><span class="s2">from </span><span class="s1">.mbcsgroupprober </span><span class="s2">import </span><span class="s1">MBCSGroupProber  </span><span class="s0"># multi-byte character sets</span><span class="s1"> 
</span><span class="s2">from </span><span class="s1">.sbcsgroupprober </span><span class="s2">import </span><span class="s1">SBCSGroupProber  </span><span class="s0"># single-byte character sets</span><span class="s1"> 
</span><span class="s2">from </span><span class="s1">.escprober </span><span class="s2">import </span><span class="s1">EscCharSetProber  </span><span class="s0"># ISO-2122, etc.</span><span class="s1"> 
</span><span class="s2">import </span><span class="s1">re 
 
MINIMUM_THRESHOLD = </span><span class="s3">0.20</span><span class="s1"> 
ePureAscii = </span><span class="s3">0</span><span class="s1"> 
eEscAscii = </span><span class="s3">1</span><span class="s1"> 
eHighbyte = </span><span class="s3">2</span><span class="s1"> 
 
 
</span><span class="s2">class </span><span class="s1">UniversalDetector: 
    </span><span class="s2">def </span><span class="s1">__init__(self): 
        self._highBitDetector = re.compile(</span><span class="s4">b'[</span><span class="s2">\x80</span><span class="s4">-</span><span class="s2">\xFF</span><span class="s4">]'</span><span class="s1">) 
        self._escDetector = re.compile(</span><span class="s4">b'(</span><span class="s2">\033</span><span class="s4">|~{)'</span><span class="s1">) 
        self._mEscCharSetProber = </span><span class="s2">None</span><span class="s1"> 
        self._mCharSetProbers = [] 
        self.reset() 
 
    </span><span class="s2">def </span><span class="s1">reset(self): 
        self.result = {</span><span class="s5">'encoding'</span><span class="s1">: </span><span class="s2">None, </span><span class="s5">'confidence'</span><span class="s1">: </span><span class="s3">0.0</span><span class="s1">} 
        self.done = </span><span class="s2">False</span><span class="s1"> 
        self._mStart = </span><span class="s2">True</span><span class="s1"> 
        self._mGotData = </span><span class="s2">False</span><span class="s1"> 
        self._mInputState = ePureAscii 
        self._mLastChar = </span><span class="s4">b''</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">self._mEscCharSetProber: 
            self._mEscCharSetProber.reset() 
        </span><span class="s2">for </span><span class="s1">prober </span><span class="s2">in </span><span class="s1">self._mCharSetProbers: 
            prober.reset() 
 
    </span><span class="s2">def </span><span class="s1">feed(self</span><span class="s2">, </span><span class="s1">aBuf): 
        </span><span class="s2">if </span><span class="s1">self.done: 
            </span><span class="s2">return</span><span class="s1"> 
 
        aLen = len(aBuf) 
        </span><span class="s2">if not </span><span class="s1">aLen: 
            </span><span class="s2">return</span><span class="s1"> 
 
        </span><span class="s2">if not </span><span class="s1">self._mGotData: 
            </span><span class="s0"># If the data starts with BOM, we know it is UTF</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">aBuf[:</span><span class="s3">3</span><span class="s1">] == codecs.BOM_UTF8: 
                </span><span class="s0"># EF BB BF  UTF-8 with BOM</span><span class="s1"> 
                self.result = {</span><span class="s5">'encoding'</span><span class="s1">: </span><span class="s5">&quot;UTF-8-SIG&quot;</span><span class="s2">, </span><span class="s5">'confidence'</span><span class="s1">: </span><span class="s3">1.0</span><span class="s1">} 
            </span><span class="s2">elif </span><span class="s1">aBuf[:</span><span class="s3">4</span><span class="s1">] == codecs.BOM_UTF32_LE: 
                </span><span class="s0"># FF FE 00 00  UTF-32, little-endian BOM</span><span class="s1"> 
                self.result = {</span><span class="s5">'encoding'</span><span class="s1">: </span><span class="s5">&quot;UTF-32LE&quot;</span><span class="s2">, </span><span class="s5">'confidence'</span><span class="s1">: </span><span class="s3">1.0</span><span class="s1">} 
            </span><span class="s2">elif </span><span class="s1">aBuf[:</span><span class="s3">4</span><span class="s1">] == codecs.BOM_UTF32_BE: 
                </span><span class="s0"># 00 00 FE FF  UTF-32, big-endian BOM</span><span class="s1"> 
                self.result = {</span><span class="s5">'encoding'</span><span class="s1">: </span><span class="s5">&quot;UTF-32BE&quot;</span><span class="s2">, </span><span class="s5">'confidence'</span><span class="s1">: </span><span class="s3">1.0</span><span class="s1">} 
            </span><span class="s2">elif </span><span class="s1">aBuf[:</span><span class="s3">4</span><span class="s1">] == </span><span class="s4">b'</span><span class="s2">\xFE\xFF\x00\x00</span><span class="s4">'</span><span class="s1">: 
                </span><span class="s0"># FE FF 00 00  UCS-4, unusual octet order BOM (3412)</span><span class="s1"> 
                self.result = { 
                    </span><span class="s5">'encoding'</span><span class="s1">: </span><span class="s5">&quot;X-ISO-10646-UCS-4-3412&quot;</span><span class="s2">,</span><span class="s1"> 
                    </span><span class="s5">'confidence'</span><span class="s1">: </span><span class="s3">1.0</span><span class="s1"> 
                } 
            </span><span class="s2">elif </span><span class="s1">aBuf[:</span><span class="s3">4</span><span class="s1">] == </span><span class="s4">b'</span><span class="s2">\x00\x00\xFF\xFE</span><span class="s4">'</span><span class="s1">: 
                </span><span class="s0"># 00 00 FF FE  UCS-4, unusual octet order BOM (2143)</span><span class="s1"> 
                self.result = { 
                    </span><span class="s5">'encoding'</span><span class="s1">: </span><span class="s5">&quot;X-ISO-10646-UCS-4-2143&quot;</span><span class="s2">,</span><span class="s1"> 
                    </span><span class="s5">'confidence'</span><span class="s1">: </span><span class="s3">1.0</span><span class="s1"> 
                } 
            </span><span class="s2">elif </span><span class="s1">aBuf[:</span><span class="s3">2</span><span class="s1">] == codecs.BOM_LE: 
                </span><span class="s0"># FF FE  UTF-16, little endian BOM</span><span class="s1"> 
                self.result = {</span><span class="s5">'encoding'</span><span class="s1">: </span><span class="s5">&quot;UTF-16LE&quot;</span><span class="s2">, </span><span class="s5">'confidence'</span><span class="s1">: </span><span class="s3">1.0</span><span class="s1">} 
            </span><span class="s2">elif </span><span class="s1">aBuf[:</span><span class="s3">2</span><span class="s1">] == codecs.BOM_BE: 
                </span><span class="s0"># FE FF  UTF-16, big endian BOM</span><span class="s1"> 
                self.result = {</span><span class="s5">'encoding'</span><span class="s1">: </span><span class="s5">&quot;UTF-16BE&quot;</span><span class="s2">, </span><span class="s5">'confidence'</span><span class="s1">: </span><span class="s3">1.0</span><span class="s1">} 
 
        self._mGotData = </span><span class="s2">True</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">self.result[</span><span class="s5">'encoding'</span><span class="s1">] </span><span class="s2">and </span><span class="s1">(self.result[</span><span class="s5">'confidence'</span><span class="s1">] &gt; </span><span class="s3">0.0</span><span class="s1">): 
            self.done = </span><span class="s2">True</span><span class="s1"> 
            </span><span class="s2">return</span><span class="s1"> 
 
        </span><span class="s2">if </span><span class="s1">self._mInputState == ePureAscii: 
            </span><span class="s2">if </span><span class="s1">self._highBitDetector.search(aBuf): 
                self._mInputState = eHighbyte 
            </span><span class="s2">elif </span><span class="s1">((self._mInputState == ePureAscii) </span><span class="s2">and</span><span class="s1"> 
                    self._escDetector.search(self._mLastChar + aBuf)): 
                self._mInputState = eEscAscii 
 
        self._mLastChar = aBuf[-</span><span class="s3">1</span><span class="s1">:] 
 
        </span><span class="s2">if </span><span class="s1">self._mInputState == eEscAscii: 
            </span><span class="s2">if not </span><span class="s1">self._mEscCharSetProber: 
                self._mEscCharSetProber = EscCharSetProber() 
            </span><span class="s2">if </span><span class="s1">self._mEscCharSetProber.feed(aBuf) == constants.eFoundIt: 
                self.result = {</span><span class="s5">'encoding'</span><span class="s1">: self._mEscCharSetProber.get_charset_name()</span><span class="s2">,</span><span class="s1"> 
                               </span><span class="s5">'confidence'</span><span class="s1">: self._mEscCharSetProber.get_confidence()} 
                self.done = </span><span class="s2">True</span><span class="s1"> 
        </span><span class="s2">elif </span><span class="s1">self._mInputState == eHighbyte: 
            </span><span class="s2">if not </span><span class="s1">self._mCharSetProbers: 
                self._mCharSetProbers = [MBCSGroupProber()</span><span class="s2">, </span><span class="s1">SBCSGroupProber()</span><span class="s2">,</span><span class="s1"> 
                                         Latin1Prober()] 
            </span><span class="s2">for </span><span class="s1">prober </span><span class="s2">in </span><span class="s1">self._mCharSetProbers: 
                </span><span class="s2">if </span><span class="s1">prober.feed(aBuf) == constants.eFoundIt: 
                    self.result = {</span><span class="s5">'encoding'</span><span class="s1">: prober.get_charset_name()</span><span class="s2">,</span><span class="s1"> 
                                   </span><span class="s5">'confidence'</span><span class="s1">: prober.get_confidence()} 
                    self.done = </span><span class="s2">True</span><span class="s1"> 
                    </span><span class="s2">break</span><span class="s1"> 
 
    </span><span class="s2">def </span><span class="s1">close(self): 
        </span><span class="s2">if </span><span class="s1">self.done: 
            </span><span class="s2">return</span><span class="s1"> 
        </span><span class="s2">if not </span><span class="s1">self._mGotData: 
            </span><span class="s2">if </span><span class="s1">constants._debug: 
                sys.stderr.write(</span><span class="s5">'no data received!</span><span class="s2">\n</span><span class="s5">'</span><span class="s1">) 
            </span><span class="s2">return</span><span class="s1"> 
        self.done = </span><span class="s2">True</span><span class="s1"> 
 
        </span><span class="s2">if </span><span class="s1">self._mInputState == ePureAscii: 
            self.result = {</span><span class="s5">'encoding'</span><span class="s1">: </span><span class="s5">'ascii'</span><span class="s2">, </span><span class="s5">'confidence'</span><span class="s1">: </span><span class="s3">1.0</span><span class="s1">} 
            </span><span class="s2">return </span><span class="s1">self.result 
 
        </span><span class="s2">if </span><span class="s1">self._mInputState == eHighbyte: 
            proberConfidence = </span><span class="s2">None</span><span class="s1"> 
            maxProberConfidence = </span><span class="s3">0.0</span><span class="s1"> 
            maxProber = </span><span class="s2">None</span><span class="s1"> 
            </span><span class="s2">for </span><span class="s1">prober </span><span class="s2">in </span><span class="s1">self._mCharSetProbers: 
                </span><span class="s2">if not </span><span class="s1">prober: 
                    </span><span class="s2">continue</span><span class="s1"> 
                proberConfidence = prober.get_confidence() 
                </span><span class="s2">if </span><span class="s1">proberConfidence &gt; maxProberConfidence: 
                    maxProberConfidence = proberConfidence 
                    maxProber = prober 
            </span><span class="s2">if </span><span class="s1">maxProber </span><span class="s2">and </span><span class="s1">(maxProberConfidence &gt; MINIMUM_THRESHOLD): 
                self.result = {</span><span class="s5">'encoding'</span><span class="s1">: maxProber.get_charset_name()</span><span class="s2">,</span><span class="s1"> 
                               </span><span class="s5">'confidence'</span><span class="s1">: maxProber.get_confidence()} 
                </span><span class="s2">return </span><span class="s1">self.result 
 
        </span><span class="s2">if </span><span class="s1">constants._debug: 
            sys.stderr.write(</span><span class="s5">'no probers hit minimum threshhold</span><span class="s2">\n</span><span class="s5">'</span><span class="s1">) 
            </span><span class="s2">for </span><span class="s1">prober </span><span class="s2">in </span><span class="s1">self._mCharSetProbers[</span><span class="s3">0</span><span class="s1">].mProbers: 
                </span><span class="s2">if not </span><span class="s1">prober: 
                    </span><span class="s2">continue</span><span class="s1"> 
                sys.stderr.write(</span><span class="s5">'%s confidence = %s</span><span class="s2">\n</span><span class="s5">' </span><span class="s1">% 
                                 (prober.get_charset_name()</span><span class="s2">,</span><span class="s1"> 
                                  prober.get_confidence())) 
</span></pre>
</body>
</html>