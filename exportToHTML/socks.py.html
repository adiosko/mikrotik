<html>
<head>
<title>socks.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.ln { color: #606366; font-weight: normal; font-style: normal; }
.s0 { color: rgb(128,128,128); }
.s1 { color: rgb(169,183,198); }
.s2 { color: rgb(98,151,85); font-style: italic; }
.s3 { color: rgb(204,120,50); }
.s4 { color: rgb(106,135,89); }
.s5 { color: rgb(104,151,187); }
</style>
</head>
<BODY BGCOLOR="#2b2b2b">
<TABLE CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<TR><TD><CENTER>
<FONT FACE="Arial, Helvetica" COLOR="#000000">
socks.py</FONT>
</center></TD></TR></TABLE>
<pre>
<span class="s0"># -*- coding: utf-8 -*-</span><span class="s1"> 
</span><span class="s2">&quot;&quot;&quot; 
SOCKS support for urllib3 
~~~~~~~~~~~~~~~~~~~~~~~~~ 
 
This contrib module contains provisional support for SOCKS proxies from within 
urllib3. This module supports SOCKS4 (specifically the SOCKS4A variant) and 
SOCKS5. To enable its functionality, either install PySocks or install this 
module with the ``socks`` extra. 
 
Known Limitations: 
 
- Currently PySocks does not support contacting remote websites via literal 
  IPv6 addresses. Any such connection attempt will fail. 
- Currently PySocks does not support IPv6 connections to the SOCKS proxy. Any 
  such connection attempt will fail. 
&quot;&quot;&quot;</span><span class="s1"> 
</span><span class="s3">from </span><span class="s1">__future__ </span><span class="s3">import </span><span class="s1">absolute_import 
 
</span><span class="s3">try</span><span class="s1">: 
    </span><span class="s3">import </span><span class="s1">socks 
</span><span class="s3">except </span><span class="s1">ImportError: 
    </span><span class="s3">import </span><span class="s1">warnings 
    </span><span class="s3">from </span><span class="s1">..exceptions </span><span class="s3">import </span><span class="s1">DependencyWarning 
 
    warnings.warn(( 
        </span><span class="s4">'SOCKS support in urllib3 requires the installation of optional '</span><span class="s1"> 
        </span><span class="s4">'dependencies: specifically, PySocks.  For more information, see '</span><span class="s1"> 
        </span><span class="s4">'https://urllib3.readthedocs.io/en/latest/contrib.html#socks-proxies'</span><span class="s1"> 
        )</span><span class="s3">,</span><span class="s1"> 
        DependencyWarning 
    ) 
    </span><span class="s3">raise</span><span class="s1"> 
 
</span><span class="s3">from </span><span class="s1">socket </span><span class="s3">import </span><span class="s1">error </span><span class="s3">as </span><span class="s1">SocketError</span><span class="s3">, </span><span class="s1">timeout </span><span class="s3">as </span><span class="s1">SocketTimeout 
 
</span><span class="s3">from </span><span class="s1">..connection </span><span class="s3">import </span><span class="s1">( 
    HTTPConnection</span><span class="s3">, </span><span class="s1">HTTPSConnection 
) 
</span><span class="s3">from </span><span class="s1">..connectionpool </span><span class="s3">import </span><span class="s1">( 
    HTTPConnectionPool</span><span class="s3">, </span><span class="s1">HTTPSConnectionPool 
) 
</span><span class="s3">from </span><span class="s1">..exceptions </span><span class="s3">import </span><span class="s1">ConnectTimeoutError</span><span class="s3">, </span><span class="s1">NewConnectionError 
</span><span class="s3">from </span><span class="s1">..poolmanager </span><span class="s3">import </span><span class="s1">PoolManager 
</span><span class="s3">from </span><span class="s1">..util.url </span><span class="s3">import </span><span class="s1">parse_url 
 
</span><span class="s3">try</span><span class="s1">: 
    </span><span class="s3">import </span><span class="s1">ssl 
</span><span class="s3">except </span><span class="s1">ImportError: 
    ssl = </span><span class="s3">None</span><span class="s1"> 
 
 
</span><span class="s3">class </span><span class="s1">SOCKSConnection(HTTPConnection): 
    </span><span class="s2">&quot;&quot;&quot; 
    A plain-text HTTP connection that connects via a SOCKS proxy. 
    &quot;&quot;&quot;</span><span class="s1"> 
    </span><span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kwargs): 
        self._socks_options = kwargs.pop(</span><span class="s4">'_socks_options'</span><span class="s1">) 
        super(SOCKSConnection</span><span class="s3">, </span><span class="s1">self).__init__(*args</span><span class="s3">, </span><span class="s1">**kwargs) 
 
    </span><span class="s3">def </span><span class="s1">_new_conn(self): 
        </span><span class="s2">&quot;&quot;&quot; 
        Establish a new connection via the SOCKS proxy. 
        &quot;&quot;&quot;</span><span class="s1"> 
        extra_kw = {} 
        </span><span class="s3">if </span><span class="s1">self.source_address: 
            extra_kw[</span><span class="s4">'source_address'</span><span class="s1">] = self.source_address 
 
        </span><span class="s3">if </span><span class="s1">self.socket_options: 
            extra_kw[</span><span class="s4">'socket_options'</span><span class="s1">] = self.socket_options 
 
        </span><span class="s3">try</span><span class="s1">: 
            conn = socks.create_connection( 
                (self.host</span><span class="s3">, </span><span class="s1">self.port)</span><span class="s3">,</span><span class="s1"> 
                proxy_type=self._socks_options[</span><span class="s4">'socks_version'</span><span class="s1">]</span><span class="s3">,</span><span class="s1"> 
                proxy_addr=self._socks_options[</span><span class="s4">'proxy_host'</span><span class="s1">]</span><span class="s3">,</span><span class="s1"> 
                proxy_port=self._socks_options[</span><span class="s4">'proxy_port'</span><span class="s1">]</span><span class="s3">,</span><span class="s1"> 
                proxy_username=self._socks_options[</span><span class="s4">'username'</span><span class="s1">]</span><span class="s3">,</span><span class="s1"> 
                proxy_password=self._socks_options[</span><span class="s4">'password'</span><span class="s1">]</span><span class="s3">,</span><span class="s1"> 
                timeout=self.timeout</span><span class="s3">,</span><span class="s1"> 
                **extra_kw 
            ) 
 
        </span><span class="s3">except </span><span class="s1">SocketTimeout </span><span class="s3">as </span><span class="s1">e: 
            </span><span class="s3">raise </span><span class="s1">ConnectTimeoutError( 
                self</span><span class="s3">, </span><span class="s4">&quot;Connection to %s timed out. (connect timeout=%s)&quot; </span><span class="s1">% 
                (self.host</span><span class="s3">, </span><span class="s1">self.timeout)) 
 
        </span><span class="s3">except </span><span class="s1">socks.ProxyError </span><span class="s3">as </span><span class="s1">e: 
            </span><span class="s0"># This is fragile as hell, but it seems to be the only way to raise</span><span class="s1"> 
            </span><span class="s0"># useful errors here.</span><span class="s1"> 
            </span><span class="s3">if </span><span class="s1">e.socket_err: 
                error = e.socket_err 
                </span><span class="s3">if </span><span class="s1">isinstance(error</span><span class="s3">, </span><span class="s1">SocketTimeout): 
                    </span><span class="s3">raise </span><span class="s1">ConnectTimeoutError( 
                        self</span><span class="s3">,</span><span class="s1"> 
                        </span><span class="s4">&quot;Connection to %s timed out. (connect timeout=%s)&quot; </span><span class="s1">% 
                        (self.host</span><span class="s3">, </span><span class="s1">self.timeout) 
                    ) 
                </span><span class="s3">else</span><span class="s1">: 
                    </span><span class="s3">raise </span><span class="s1">NewConnectionError( 
                        self</span><span class="s3">,</span><span class="s1"> 
                        </span><span class="s4">&quot;Failed to establish a new connection: %s&quot; </span><span class="s1">% error 
                    ) 
            </span><span class="s3">else</span><span class="s1">: 
                </span><span class="s3">raise </span><span class="s1">NewConnectionError( 
                    self</span><span class="s3">,</span><span class="s1"> 
                    </span><span class="s4">&quot;Failed to establish a new connection: %s&quot; </span><span class="s1">% e 
                ) 
 
        </span><span class="s3">except </span><span class="s1">SocketError </span><span class="s3">as </span><span class="s1">e:  </span><span class="s0"># Defensive: PySocks should catch all these.</span><span class="s1"> 
            </span><span class="s3">raise </span><span class="s1">NewConnectionError( 
                self</span><span class="s3">, </span><span class="s4">&quot;Failed to establish a new connection: %s&quot; </span><span class="s1">% e) 
 
        </span><span class="s3">return </span><span class="s1">conn 
 
 
</span><span class="s0"># We don't need to duplicate the Verified/Unverified distinction from</span><span class="s1"> 
</span><span class="s0"># urllib3/connection.py here because the HTTPSConnection will already have been</span><span class="s1"> 
</span><span class="s0"># correctly set to either the Verified or Unverified form by that module. This</span><span class="s1"> 
</span><span class="s0"># means the SOCKSHTTPSConnection will automatically be the correct type.</span><span class="s1"> 
</span><span class="s3">class </span><span class="s1">SOCKSHTTPSConnection(SOCKSConnection</span><span class="s3">, </span><span class="s1">HTTPSConnection): 
    </span><span class="s3">pass</span><span class="s1"> 
 
 
</span><span class="s3">class </span><span class="s1">SOCKSHTTPConnectionPool(HTTPConnectionPool): 
    ConnectionCls = SOCKSConnection 
 
 
</span><span class="s3">class </span><span class="s1">SOCKSHTTPSConnectionPool(HTTPSConnectionPool): 
    ConnectionCls = SOCKSHTTPSConnection 
 
 
</span><span class="s3">class </span><span class="s1">SOCKSProxyManager(PoolManager): 
    </span><span class="s2">&quot;&quot;&quot; 
    A version of the urllib3 ProxyManager that routes connections via the 
    defined SOCKS proxy. 
    &quot;&quot;&quot;</span><span class="s1"> 
    pool_classes_by_scheme = { 
        </span><span class="s4">'http'</span><span class="s1">: SOCKSHTTPConnectionPool</span><span class="s3">,</span><span class="s1"> 
        </span><span class="s4">'https'</span><span class="s1">: SOCKSHTTPSConnectionPool</span><span class="s3">,</span><span class="s1"> 
    } 
 
    </span><span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">proxy_url</span><span class="s3">, </span><span class="s1">username=</span><span class="s3">None, </span><span class="s1">password=</span><span class="s3">None,</span><span class="s1"> 
                 num_pools=</span><span class="s5">10</span><span class="s3">, </span><span class="s1">headers=</span><span class="s3">None, </span><span class="s1">**connection_pool_kw): 
        parsed = parse_url(proxy_url) 
 
        </span><span class="s3">if </span><span class="s1">parsed.scheme == </span><span class="s4">'socks5'</span><span class="s1">: 
            socks_version = socks.PROXY_TYPE_SOCKS5 
        </span><span class="s3">elif </span><span class="s1">parsed.scheme == </span><span class="s4">'socks4'</span><span class="s1">: 
            socks_version = socks.PROXY_TYPE_SOCKS4 
        </span><span class="s3">else</span><span class="s1">: 
            </span><span class="s3">raise </span><span class="s1">ValueError( 
                </span><span class="s4">&quot;Unable to determine SOCKS version from %s&quot; </span><span class="s1">% proxy_url 
            ) 
 
        self.proxy_url = proxy_url 
 
        socks_options = { 
            </span><span class="s4">'socks_version'</span><span class="s1">: socks_version</span><span class="s3">,</span><span class="s1"> 
            </span><span class="s4">'proxy_host'</span><span class="s1">: parsed.host</span><span class="s3">,</span><span class="s1"> 
            </span><span class="s4">'proxy_port'</span><span class="s1">: parsed.port</span><span class="s3">,</span><span class="s1"> 
            </span><span class="s4">'username'</span><span class="s1">: username</span><span class="s3">,</span><span class="s1"> 
            </span><span class="s4">'password'</span><span class="s1">: password</span><span class="s3">,</span><span class="s1"> 
        } 
        connection_pool_kw[</span><span class="s4">'_socks_options'</span><span class="s1">] = socks_options 
 
        super(SOCKSProxyManager</span><span class="s3">, </span><span class="s1">self).__init__( 
            num_pools</span><span class="s3">, </span><span class="s1">headers</span><span class="s3">, </span><span class="s1">**connection_pool_kw 
        ) 
 
        self.pool_classes_by_scheme = SOCKSProxyManager.pool_classes_by_scheme 
</span></pre>
</body>
</html>