<html>
<head>
<title>models.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.ln { color: #606366; font-weight: normal; font-style: normal; }
.s0 { color: rgb(128,128,128); }
.s1 { color: rgb(169,183,198); }
.s2 { color: rgb(98,151,85); font-style: italic; }
.s3 { color: rgb(204,120,50); }
.s4 { color: rgb(104,151,187); }
.s5 { color: rgb(106,135,89); }
</style>
</head>
<BODY BGCOLOR="#2b2b2b">
<TABLE CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<TR><TD><CENTER>
<FONT FACE="Arial, Helvetica" COLOR="#000000">
models.py</FONT>
</center></TD></TR></TABLE>
<pre>
<span class="s0"># -*- coding: utf-8 -*-</span><span class="s1"> 
 
</span><span class="s2">&quot;&quot;&quot; 
requests.models 
~~~~~~~~~~~~~~~ 
 
This module contains the primary objects that power Requests. 
&quot;&quot;&quot;</span><span class="s1"> 
 
</span><span class="s3">import </span><span class="s1">collections 
</span><span class="s3">import </span><span class="s1">datetime 
 
</span><span class="s3">from </span><span class="s1">io </span><span class="s3">import </span><span class="s1">BytesIO</span><span class="s3">, </span><span class="s1">UnsupportedOperation 
</span><span class="s3">from </span><span class="s1">.hooks </span><span class="s3">import </span><span class="s1">default_hooks 
</span><span class="s3">from </span><span class="s1">.structures </span><span class="s3">import </span><span class="s1">CaseInsensitiveDict 
 
</span><span class="s3">from </span><span class="s1">.auth </span><span class="s3">import </span><span class="s1">HTTPBasicAuth 
</span><span class="s3">from </span><span class="s1">.cookies </span><span class="s3">import </span><span class="s1">cookiejar_from_dict</span><span class="s3">, </span><span class="s1">get_cookie_header</span><span class="s3">, </span><span class="s1">_copy_cookie_jar 
</span><span class="s3">from </span><span class="s1">.packages.urllib3.fields </span><span class="s3">import </span><span class="s1">RequestField 
</span><span class="s3">from </span><span class="s1">.packages.urllib3.filepost </span><span class="s3">import </span><span class="s1">encode_multipart_formdata 
</span><span class="s3">from </span><span class="s1">.packages.urllib3.util </span><span class="s3">import </span><span class="s1">parse_url 
</span><span class="s3">from </span><span class="s1">.packages.urllib3.exceptions </span><span class="s3">import </span><span class="s1">( 
    DecodeError</span><span class="s3">, </span><span class="s1">ReadTimeoutError</span><span class="s3">, </span><span class="s1">ProtocolError</span><span class="s3">, </span><span class="s1">LocationParseError) 
</span><span class="s3">from </span><span class="s1">.exceptions </span><span class="s3">import </span><span class="s1">( 
    HTTPError</span><span class="s3">, </span><span class="s1">MissingSchema</span><span class="s3">, </span><span class="s1">InvalidURL</span><span class="s3">, </span><span class="s1">ChunkedEncodingError</span><span class="s3">,</span><span class="s1"> 
    ContentDecodingError</span><span class="s3">, </span><span class="s1">ConnectionError</span><span class="s3">, </span><span class="s1">StreamConsumedError) 
</span><span class="s3">from </span><span class="s1">.utils </span><span class="s3">import </span><span class="s1">( 
    guess_filename</span><span class="s3">, </span><span class="s1">get_auth_from_url</span><span class="s3">, </span><span class="s1">requote_uri</span><span class="s3">,</span><span class="s1"> 
    stream_decode_response_unicode</span><span class="s3">, </span><span class="s1">to_key_val_list</span><span class="s3">, </span><span class="s1">parse_header_links</span><span class="s3">,</span><span class="s1"> 
    iter_slices</span><span class="s3">, </span><span class="s1">guess_json_utf</span><span class="s3">, </span><span class="s1">super_len</span><span class="s3">, </span><span class="s1">to_native_string</span><span class="s3">,</span><span class="s1"> 
    check_header_validity) 
</span><span class="s3">from </span><span class="s1">.compat </span><span class="s3">import </span><span class="s1">( 
    cookielib</span><span class="s3">, </span><span class="s1">urlunparse</span><span class="s3">, </span><span class="s1">urlsplit</span><span class="s3">, </span><span class="s1">urlencode</span><span class="s3">, </span><span class="s1">str</span><span class="s3">, </span><span class="s1">bytes</span><span class="s3">, </span><span class="s1">StringIO</span><span class="s3">,</span><span class="s1"> 
    is_py2</span><span class="s3">, </span><span class="s1">chardet</span><span class="s3">, </span><span class="s1">builtin_str</span><span class="s3">, </span><span class="s1">basestring) 
</span><span class="s3">from </span><span class="s1">.compat </span><span class="s3">import </span><span class="s1">json </span><span class="s3">as </span><span class="s1">complexjson 
</span><span class="s3">from </span><span class="s1">.status_codes </span><span class="s3">import </span><span class="s1">codes 
 
</span><span class="s0">#: The set of HTTP status codes that indicate an automatically</span><span class="s1"> 
</span><span class="s0">#: processable redirect.</span><span class="s1"> 
REDIRECT_STATI = ( 
    codes.moved</span><span class="s3">,               </span><span class="s0"># 301</span><span class="s1"> 
    codes.found</span><span class="s3">,               </span><span class="s0"># 302</span><span class="s1"> 
    codes.other</span><span class="s3">,               </span><span class="s0"># 303</span><span class="s1"> 
    codes.temporary_redirect</span><span class="s3">,  </span><span class="s0"># 307</span><span class="s1"> 
    codes.permanent_redirect</span><span class="s3">,  </span><span class="s0"># 308</span><span class="s1"> 
) 
 
DEFAULT_REDIRECT_LIMIT = </span><span class="s4">30</span><span class="s1"> 
CONTENT_CHUNK_SIZE = </span><span class="s4">10 </span><span class="s1">* </span><span class="s4">1024</span><span class="s1"> 
ITER_CHUNK_SIZE = </span><span class="s4">512</span><span class="s1"> 
 
 
</span><span class="s3">class </span><span class="s1">RequestEncodingMixin(object): 
    @property 
    </span><span class="s3">def </span><span class="s1">path_url(self): 
        </span><span class="s2">&quot;&quot;&quot;Build the path URL to use.&quot;&quot;&quot;</span><span class="s1"> 
 
        url = [] 
 
        p = urlsplit(self.url) 
 
        path = p.path 
        </span><span class="s3">if not </span><span class="s1">path: 
            path = </span><span class="s5">'/'</span><span class="s1"> 
 
        url.append(path) 
 
        query = p.query 
        </span><span class="s3">if </span><span class="s1">query: 
            url.append(</span><span class="s5">'?'</span><span class="s1">) 
            url.append(query) 
 
        </span><span class="s3">return </span><span class="s5">''</span><span class="s1">.join(url) 
 
    @staticmethod 
    </span><span class="s3">def </span><span class="s1">_encode_params(data): 
        </span><span class="s2">&quot;&quot;&quot;Encode parameters in a piece of data. 
 
        Will successfully encode parameters when passed as a dict or a list of 
        2-tuples. Order is retained if data is a list of 2-tuples but arbitrary 
        if parameters are supplied as a dict. 
        &quot;&quot;&quot;</span><span class="s1"> 
 
        </span><span class="s3">if </span><span class="s1">isinstance(data</span><span class="s3">, </span><span class="s1">(str</span><span class="s3">, </span><span class="s1">bytes)): 
            </span><span class="s3">return </span><span class="s1">data 
        </span><span class="s3">elif </span><span class="s1">hasattr(data</span><span class="s3">, </span><span class="s5">'read'</span><span class="s1">): 
            </span><span class="s3">return </span><span class="s1">data 
        </span><span class="s3">elif </span><span class="s1">hasattr(data</span><span class="s3">, </span><span class="s5">'__iter__'</span><span class="s1">): 
            result = [] 
            </span><span class="s3">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">vs </span><span class="s3">in </span><span class="s1">to_key_val_list(data): 
                </span><span class="s3">if </span><span class="s1">isinstance(vs</span><span class="s3">, </span><span class="s1">basestring) </span><span class="s3">or not </span><span class="s1">hasattr(vs</span><span class="s3">, </span><span class="s5">'__iter__'</span><span class="s1">): 
                    vs = [vs] 
                </span><span class="s3">for </span><span class="s1">v </span><span class="s3">in </span><span class="s1">vs: 
                    </span><span class="s3">if </span><span class="s1">v </span><span class="s3">is not None</span><span class="s1">: 
                        result.append( 
                            (k.encode(</span><span class="s5">'utf-8'</span><span class="s1">) </span><span class="s3">if </span><span class="s1">isinstance(k</span><span class="s3">, </span><span class="s1">str) </span><span class="s3">else </span><span class="s1">k</span><span class="s3">,</span><span class="s1"> 
                             v.encode(</span><span class="s5">'utf-8'</span><span class="s1">) </span><span class="s3">if </span><span class="s1">isinstance(v</span><span class="s3">, </span><span class="s1">str) </span><span class="s3">else </span><span class="s1">v)) 
            </span><span class="s3">return </span><span class="s1">urlencode(result</span><span class="s3">, </span><span class="s1">doseq=</span><span class="s3">True</span><span class="s1">) 
        </span><span class="s3">else</span><span class="s1">: 
            </span><span class="s3">return </span><span class="s1">data 
 
    @staticmethod 
    </span><span class="s3">def </span><span class="s1">_encode_files(files</span><span class="s3">, </span><span class="s1">data): 
        </span><span class="s2">&quot;&quot;&quot;Build the body for a multipart/form-data request. 
 
        Will successfully encode files when passed as a dict or a list of 
        tuples. Order is retained if data is a list of tuples but arbitrary 
        if parameters are supplied as a dict. 
        The tuples may be 2-tuples (filename, fileobj), 3-tuples (filename, fileobj, contentype) 
        or 4-tuples (filename, fileobj, contentype, custom_headers). 
        &quot;&quot;&quot;</span><span class="s1"> 
        </span><span class="s3">if </span><span class="s1">(</span><span class="s3">not </span><span class="s1">files): 
            </span><span class="s3">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;Files must be provided.&quot;</span><span class="s1">) 
        </span><span class="s3">elif </span><span class="s1">isinstance(data</span><span class="s3">, </span><span class="s1">basestring): 
            </span><span class="s3">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;Data must not be a string.&quot;</span><span class="s1">) 
 
        new_fields = [] 
        fields = to_key_val_list(data </span><span class="s3">or </span><span class="s1">{}) 
        files = to_key_val_list(files </span><span class="s3">or </span><span class="s1">{}) 
 
        </span><span class="s3">for </span><span class="s1">field</span><span class="s3">, </span><span class="s1">val </span><span class="s3">in </span><span class="s1">fields: 
            </span><span class="s3">if </span><span class="s1">isinstance(val</span><span class="s3">, </span><span class="s1">basestring) </span><span class="s3">or not </span><span class="s1">hasattr(val</span><span class="s3">, </span><span class="s5">'__iter__'</span><span class="s1">): 
                val = [val] 
            </span><span class="s3">for </span><span class="s1">v </span><span class="s3">in </span><span class="s1">val: 
                </span><span class="s3">if </span><span class="s1">v </span><span class="s3">is not None</span><span class="s1">: 
                    </span><span class="s0"># Don't call str() on bytestrings: in Py3 it all goes wrong.</span><span class="s1"> 
                    </span><span class="s3">if not </span><span class="s1">isinstance(v</span><span class="s3">, </span><span class="s1">bytes): 
                        v = str(v) 
 
                    new_fields.append( 
                        (field.decode(</span><span class="s5">'utf-8'</span><span class="s1">) </span><span class="s3">if </span><span class="s1">isinstance(field</span><span class="s3">, </span><span class="s1">bytes) </span><span class="s3">else </span><span class="s1">field</span><span class="s3">,</span><span class="s1"> 
                         v.encode(</span><span class="s5">'utf-8'</span><span class="s1">) </span><span class="s3">if </span><span class="s1">isinstance(v</span><span class="s3">, </span><span class="s1">str) </span><span class="s3">else </span><span class="s1">v)) 
 
        </span><span class="s3">for </span><span class="s1">(k</span><span class="s3">, </span><span class="s1">v) </span><span class="s3">in </span><span class="s1">files: 
            </span><span class="s0"># support for explicit filename</span><span class="s1"> 
            ft = </span><span class="s3">None</span><span class="s1"> 
            fh = </span><span class="s3">None</span><span class="s1"> 
            </span><span class="s3">if </span><span class="s1">isinstance(v</span><span class="s3">, </span><span class="s1">(tuple</span><span class="s3">, </span><span class="s1">list)): 
                </span><span class="s3">if </span><span class="s1">len(v) == </span><span class="s4">2</span><span class="s1">: 
                    fn</span><span class="s3">, </span><span class="s1">fp = v 
                </span><span class="s3">elif </span><span class="s1">len(v) == </span><span class="s4">3</span><span class="s1">: 
                    fn</span><span class="s3">, </span><span class="s1">fp</span><span class="s3">, </span><span class="s1">ft = v 
                </span><span class="s3">else</span><span class="s1">: 
                    fn</span><span class="s3">, </span><span class="s1">fp</span><span class="s3">, </span><span class="s1">ft</span><span class="s3">, </span><span class="s1">fh = v 
            </span><span class="s3">else</span><span class="s1">: 
                fn = guess_filename(v) </span><span class="s3">or </span><span class="s1">k 
                fp = v 
 
            </span><span class="s3">if </span><span class="s1">isinstance(fp</span><span class="s3">, </span><span class="s1">(str</span><span class="s3">, </span><span class="s1">bytes</span><span class="s3">, </span><span class="s1">bytearray)): 
                fdata = fp 
            </span><span class="s3">else</span><span class="s1">: 
                fdata = fp.read() 
 
            rf = RequestField(name=k</span><span class="s3">, </span><span class="s1">data=fdata</span><span class="s3">, </span><span class="s1">filename=fn</span><span class="s3">, </span><span class="s1">headers=fh) 
            rf.make_multipart(content_type=ft) 
            new_fields.append(rf) 
 
        body</span><span class="s3">, </span><span class="s1">content_type = encode_multipart_formdata(new_fields) 
 
        </span><span class="s3">return </span><span class="s1">body</span><span class="s3">, </span><span class="s1">content_type 
 
 
</span><span class="s3">class </span><span class="s1">RequestHooksMixin(object): 
    </span><span class="s3">def </span><span class="s1">register_hook(self</span><span class="s3">, </span><span class="s1">event</span><span class="s3">, </span><span class="s1">hook): 
        </span><span class="s2">&quot;&quot;&quot;Properly register a hook.&quot;&quot;&quot;</span><span class="s1"> 
 
        </span><span class="s3">if </span><span class="s1">event </span><span class="s3">not in </span><span class="s1">self.hooks: 
            </span><span class="s3">raise </span><span class="s1">ValueError(</span><span class="s5">'Unsupported event specified, with event name &quot;%s&quot;' </span><span class="s1">% (event)) 
 
        </span><span class="s3">if </span><span class="s1">isinstance(hook</span><span class="s3">, </span><span class="s1">collections.Callable): 
            self.hooks[event].append(hook) 
        </span><span class="s3">elif </span><span class="s1">hasattr(hook</span><span class="s3">, </span><span class="s5">'__iter__'</span><span class="s1">): 
            self.hooks[event].extend(h </span><span class="s3">for </span><span class="s1">h </span><span class="s3">in </span><span class="s1">hook </span><span class="s3">if </span><span class="s1">isinstance(h</span><span class="s3">, </span><span class="s1">collections.Callable)) 
 
    </span><span class="s3">def </span><span class="s1">deregister_hook(self</span><span class="s3">, </span><span class="s1">event</span><span class="s3">, </span><span class="s1">hook): 
        </span><span class="s2">&quot;&quot;&quot;Deregister a previously registered hook. 
        Returns True if the hook existed, False if not. 
        &quot;&quot;&quot;</span><span class="s1"> 
 
        </span><span class="s3">try</span><span class="s1">: 
            self.hooks[event].remove(hook) 
            </span><span class="s3">return True</span><span class="s1"> 
        </span><span class="s3">except </span><span class="s1">ValueError: 
            </span><span class="s3">return False</span><span class="s1"> 
 
 
</span><span class="s3">class </span><span class="s1">Request(RequestHooksMixin): 
    </span><span class="s2">&quot;&quot;&quot;A user-created :class:`Request &lt;Request&gt;` object. 
 
    Used to prepare a :class:`PreparedRequest &lt;PreparedRequest&gt;`, which is sent to the server. 
 
    :param method: HTTP method to use. 
    :param url: URL to send. 
    :param headers: dictionary of headers to send. 
    :param files: dictionary of {filename: fileobject} files to multipart upload. 
    :param data: the body to attach to the request. If a dictionary is provided, form-encoding will take place. 
    :param json: json for the body to attach to the request (if files or data is not specified). 
    :param params: dictionary of URL parameters to append to the URL. 
    :param auth: Auth handler or (user, pass) tuple. 
    :param cookies: dictionary or CookieJar of cookies to attach to this request. 
    :param hooks: dictionary of callback hooks, for internal usage. 
 
    Usage:: 
 
      &gt;&gt;&gt; import requests 
      &gt;&gt;&gt; req = requests.Request('GET', 'http://httpbin.org/get') 
      &gt;&gt;&gt; req.prepare() 
      &lt;PreparedRequest [GET]&gt; 
    &quot;&quot;&quot;</span><span class="s1"> 
 
    </span><span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">method=</span><span class="s3">None, </span><span class="s1">url=</span><span class="s3">None, </span><span class="s1">headers=</span><span class="s3">None, </span><span class="s1">files=</span><span class="s3">None,</span><span class="s1"> 
        data=</span><span class="s3">None, </span><span class="s1">params=</span><span class="s3">None, </span><span class="s1">auth=</span><span class="s3">None, </span><span class="s1">cookies=</span><span class="s3">None, </span><span class="s1">hooks=</span><span class="s3">None, </span><span class="s1">json=</span><span class="s3">None</span><span class="s1">): 
 
        </span><span class="s0"># Default empty dicts for dict params.</span><span class="s1"> 
        data = [] </span><span class="s3">if </span><span class="s1">data </span><span class="s3">is None else </span><span class="s1">data 
        files = [] </span><span class="s3">if </span><span class="s1">files </span><span class="s3">is None else </span><span class="s1">files 
        headers = {} </span><span class="s3">if </span><span class="s1">headers </span><span class="s3">is None else </span><span class="s1">headers 
        params = {} </span><span class="s3">if </span><span class="s1">params </span><span class="s3">is None else </span><span class="s1">params 
        hooks = {} </span><span class="s3">if </span><span class="s1">hooks </span><span class="s3">is None else </span><span class="s1">hooks 
 
        self.hooks = default_hooks() 
        </span><span class="s3">for </span><span class="s1">(k</span><span class="s3">, </span><span class="s1">v) </span><span class="s3">in </span><span class="s1">list(hooks.items()): 
            self.register_hook(event=k</span><span class="s3">, </span><span class="s1">hook=v) 
 
        self.method = method 
        self.url = url 
        self.headers = headers 
        self.files = files 
        self.data = data 
        self.json = json 
        self.params = params 
        self.auth = auth 
        self.cookies = cookies 
 
    </span><span class="s3">def </span><span class="s1">__repr__(self): 
        </span><span class="s3">return </span><span class="s5">'&lt;Request [%s]&gt;' </span><span class="s1">% (self.method) 
 
    </span><span class="s3">def </span><span class="s1">prepare(self): 
        </span><span class="s2">&quot;&quot;&quot;Constructs a :class:`PreparedRequest &lt;PreparedRequest&gt;` for transmission and returns it.&quot;&quot;&quot;</span><span class="s1"> 
        p = PreparedRequest() 
        p.prepare( 
            method=self.method</span><span class="s3">,</span><span class="s1"> 
            url=self.url</span><span class="s3">,</span><span class="s1"> 
            headers=self.headers</span><span class="s3">,</span><span class="s1"> 
            files=self.files</span><span class="s3">,</span><span class="s1"> 
            data=self.data</span><span class="s3">,</span><span class="s1"> 
            json=self.json</span><span class="s3">,</span><span class="s1"> 
            params=self.params</span><span class="s3">,</span><span class="s1"> 
            auth=self.auth</span><span class="s3">,</span><span class="s1"> 
            cookies=self.cookies</span><span class="s3">,</span><span class="s1"> 
            hooks=self.hooks</span><span class="s3">,</span><span class="s1"> 
        ) 
        </span><span class="s3">return </span><span class="s1">p 
 
 
</span><span class="s3">class </span><span class="s1">PreparedRequest(RequestEncodingMixin</span><span class="s3">, </span><span class="s1">RequestHooksMixin): 
    </span><span class="s2">&quot;&quot;&quot;The fully mutable :class:`PreparedRequest &lt;PreparedRequest&gt;` object, 
    containing the exact bytes that will be sent to the server. 
 
    Generated from either a :class:`Request &lt;Request&gt;` object or manually. 
 
    Usage:: 
 
      &gt;&gt;&gt; import requests 
      &gt;&gt;&gt; req = requests.Request('GET', 'http://httpbin.org/get') 
      &gt;&gt;&gt; r = req.prepare() 
      &lt;PreparedRequest [GET]&gt; 
 
      &gt;&gt;&gt; s = requests.Session() 
      &gt;&gt;&gt; s.send(r) 
      &lt;Response [200]&gt; 
    &quot;&quot;&quot;</span><span class="s1"> 
 
    </span><span class="s3">def </span><span class="s1">__init__(self): 
        </span><span class="s0">#: HTTP verb to send to the server.</span><span class="s1"> 
        self.method = </span><span class="s3">None</span><span class="s1"> 
        </span><span class="s0">#: HTTP URL to send the request to.</span><span class="s1"> 
        self.url = </span><span class="s3">None</span><span class="s1"> 
        </span><span class="s0">#: dictionary of HTTP headers.</span><span class="s1"> 
        self.headers = </span><span class="s3">None</span><span class="s1"> 
        </span><span class="s0"># The `CookieJar` used to create the Cookie header will be stored here</span><span class="s1"> 
        </span><span class="s0"># after prepare_cookies is called</span><span class="s1"> 
        self._cookies = </span><span class="s3">None</span><span class="s1"> 
        </span><span class="s0">#: request body to send to the server.</span><span class="s1"> 
        self.body = </span><span class="s3">None</span><span class="s1"> 
        </span><span class="s0">#: dictionary of callback hooks, for internal usage.</span><span class="s1"> 
        self.hooks = default_hooks() 
 
    </span><span class="s3">def </span><span class="s1">prepare(self</span><span class="s3">, </span><span class="s1">method=</span><span class="s3">None, </span><span class="s1">url=</span><span class="s3">None, </span><span class="s1">headers=</span><span class="s3">None, </span><span class="s1">files=</span><span class="s3">None,</span><span class="s1"> 
        data=</span><span class="s3">None, </span><span class="s1">params=</span><span class="s3">None, </span><span class="s1">auth=</span><span class="s3">None, </span><span class="s1">cookies=</span><span class="s3">None, </span><span class="s1">hooks=</span><span class="s3">None, </span><span class="s1">json=</span><span class="s3">None</span><span class="s1">): 
        </span><span class="s2">&quot;&quot;&quot;Prepares the entire request with the given parameters.&quot;&quot;&quot;</span><span class="s1"> 
 
        self.prepare_method(method) 
        self.prepare_url(url</span><span class="s3">, </span><span class="s1">params) 
        self.prepare_headers(headers) 
        self.prepare_cookies(cookies) 
        self.prepare_body(data</span><span class="s3">, </span><span class="s1">files</span><span class="s3">, </span><span class="s1">json) 
        self.prepare_auth(auth</span><span class="s3">, </span><span class="s1">url) 
 
        </span><span class="s0"># Note that prepare_auth must be last to enable authentication schemes</span><span class="s1"> 
        </span><span class="s0"># such as OAuth to work on a fully prepared request.</span><span class="s1"> 
 
        </span><span class="s0"># This MUST go after prepare_auth. Authenticators could add a hook</span><span class="s1"> 
        self.prepare_hooks(hooks) 
 
    </span><span class="s3">def </span><span class="s1">__repr__(self): 
        </span><span class="s3">return </span><span class="s5">'&lt;PreparedRequest [%s]&gt;' </span><span class="s1">% (self.method) 
 
    </span><span class="s3">def </span><span class="s1">copy(self): 
        p = PreparedRequest() 
        p.method = self.method 
        p.url = self.url 
        p.headers = self.headers.copy() </span><span class="s3">if </span><span class="s1">self.headers </span><span class="s3">is not None else None</span><span class="s1"> 
        p._cookies = _copy_cookie_jar(self._cookies) 
        p.body = self.body 
        p.hooks = self.hooks 
        </span><span class="s3">return </span><span class="s1">p 
 
    </span><span class="s3">def </span><span class="s1">prepare_method(self</span><span class="s3">, </span><span class="s1">method): 
        </span><span class="s2">&quot;&quot;&quot;Prepares the given HTTP method.&quot;&quot;&quot;</span><span class="s1"> 
        self.method = method 
        </span><span class="s3">if </span><span class="s1">self.method </span><span class="s3">is not None</span><span class="s1">: 
            self.method = to_native_string(self.method.upper()) 
 
    </span><span class="s3">def </span><span class="s1">prepare_url(self</span><span class="s3">, </span><span class="s1">url</span><span class="s3">, </span><span class="s1">params): 
        </span><span class="s2">&quot;&quot;&quot;Prepares the given HTTP URL.&quot;&quot;&quot;</span><span class="s1"> 
        </span><span class="s0">#: Accept objects that have string representations.</span><span class="s1"> 
        </span><span class="s0">#: We're unable to blindly call unicode/str functions</span><span class="s1"> 
        </span><span class="s0">#: as this will include the bytestring indicator (b'')</span><span class="s1"> 
        </span><span class="s0">#: on python 3.x.</span><span class="s1"> 
        </span><span class="s0">#: https://github.com/kennethreitz/requests/pull/2238</span><span class="s1"> 
        </span><span class="s3">if </span><span class="s1">isinstance(url</span><span class="s3">, </span><span class="s1">bytes): 
            url = url.decode(</span><span class="s5">'utf8'</span><span class="s1">) 
        </span><span class="s3">else</span><span class="s1">: 
            url = unicode(url) </span><span class="s3">if </span><span class="s1">is_py2 </span><span class="s3">else </span><span class="s1">str(url) 
 
        </span><span class="s0"># Don't do any URL preparation for non-HTTP schemes like `mailto`,</span><span class="s1"> 
        </span><span class="s0"># `data` etc to work around exceptions from `url_parse`, which</span><span class="s1"> 
        </span><span class="s0"># handles RFC 3986 only.</span><span class="s1"> 
        </span><span class="s3">if </span><span class="s5">':' </span><span class="s3">in </span><span class="s1">url </span><span class="s3">and not </span><span class="s1">url.lower().startswith(</span><span class="s5">'http'</span><span class="s1">): 
            self.url = url 
            </span><span class="s3">return</span><span class="s1"> 
 
        </span><span class="s0"># Support for unicode domain names and paths.</span><span class="s1"> 
        </span><span class="s3">try</span><span class="s1">: 
            scheme</span><span class="s3">, </span><span class="s1">auth</span><span class="s3">, </span><span class="s1">host</span><span class="s3">, </span><span class="s1">port</span><span class="s3">, </span><span class="s1">path</span><span class="s3">, </span><span class="s1">query</span><span class="s3">, </span><span class="s1">fragment = parse_url(url) 
        </span><span class="s3">except </span><span class="s1">LocationParseError </span><span class="s3">as </span><span class="s1">e: 
            </span><span class="s3">raise </span><span class="s1">InvalidURL(*e.args) 
 
        </span><span class="s3">if not </span><span class="s1">scheme: 
            error = (</span><span class="s5">&quot;Invalid URL {0!r}: No schema supplied. Perhaps you meant http://{0}?&quot;</span><span class="s1">) 
            error = error.format(to_native_string(url</span><span class="s3">, </span><span class="s5">'utf8'</span><span class="s1">)) 
 
            </span><span class="s3">raise </span><span class="s1">MissingSchema(error) 
 
        </span><span class="s3">if not </span><span class="s1">host: 
            </span><span class="s3">raise </span><span class="s1">InvalidURL(</span><span class="s5">&quot;Invalid URL %r: No host supplied&quot; </span><span class="s1">% url) 
 
        </span><span class="s0"># Only want to apply IDNA to the hostname</span><span class="s1"> 
        </span><span class="s3">try</span><span class="s1">: 
            host = host.encode(</span><span class="s5">'idna'</span><span class="s1">).decode(</span><span class="s5">'utf-8'</span><span class="s1">) 
        </span><span class="s3">except </span><span class="s1">UnicodeError: 
            </span><span class="s3">raise </span><span class="s1">InvalidURL(</span><span class="s5">'URL has an invalid label.'</span><span class="s1">) 
 
        </span><span class="s0"># Carefully reconstruct the network location</span><span class="s1"> 
        netloc = auth </span><span class="s3">or </span><span class="s5">''</span><span class="s1"> 
        </span><span class="s3">if </span><span class="s1">netloc: 
            netloc += </span><span class="s5">'@'</span><span class="s1"> 
        netloc += host 
        </span><span class="s3">if </span><span class="s1">port: 
            netloc += </span><span class="s5">':' </span><span class="s1">+ str(port) 
 
        </span><span class="s0"># Bare domains aren't valid URLs.</span><span class="s1"> 
        </span><span class="s3">if not </span><span class="s1">path: 
            path = </span><span class="s5">'/'</span><span class="s1"> 
 
        </span><span class="s3">if </span><span class="s1">is_py2: 
            </span><span class="s3">if </span><span class="s1">isinstance(scheme</span><span class="s3">, </span><span class="s1">str): 
                scheme = scheme.encode(</span><span class="s5">'utf-8'</span><span class="s1">) 
            </span><span class="s3">if </span><span class="s1">isinstance(netloc</span><span class="s3">, </span><span class="s1">str): 
                netloc = netloc.encode(</span><span class="s5">'utf-8'</span><span class="s1">) 
            </span><span class="s3">if </span><span class="s1">isinstance(path</span><span class="s3">, </span><span class="s1">str): 
                path = path.encode(</span><span class="s5">'utf-8'</span><span class="s1">) 
            </span><span class="s3">if </span><span class="s1">isinstance(query</span><span class="s3">, </span><span class="s1">str): 
                query = query.encode(</span><span class="s5">'utf-8'</span><span class="s1">) 
            </span><span class="s3">if </span><span class="s1">isinstance(fragment</span><span class="s3">, </span><span class="s1">str): 
                fragment = fragment.encode(</span><span class="s5">'utf-8'</span><span class="s1">) 
 
        </span><span class="s3">if </span><span class="s1">isinstance(params</span><span class="s3">, </span><span class="s1">(str</span><span class="s3">, </span><span class="s1">bytes)): 
            params = to_native_string(params) 
 
        enc_params = self._encode_params(params) 
        </span><span class="s3">if </span><span class="s1">enc_params: 
            </span><span class="s3">if </span><span class="s1">query: 
                query = </span><span class="s5">'%s&amp;%s' </span><span class="s1">% (query</span><span class="s3">, </span><span class="s1">enc_params) 
            </span><span class="s3">else</span><span class="s1">: 
                query = enc_params 
 
        url = requote_uri(urlunparse([scheme</span><span class="s3">, </span><span class="s1">netloc</span><span class="s3">, </span><span class="s1">path</span><span class="s3">, None, </span><span class="s1">query</span><span class="s3">, </span><span class="s1">fragment])) 
        self.url = url 
 
    </span><span class="s3">def </span><span class="s1">prepare_headers(self</span><span class="s3">, </span><span class="s1">headers): 
        </span><span class="s2">&quot;&quot;&quot;Prepares the given HTTP headers.&quot;&quot;&quot;</span><span class="s1"> 
 
        self.headers = CaseInsensitiveDict() 
        </span><span class="s3">if </span><span class="s1">headers: 
            </span><span class="s3">for </span><span class="s1">header </span><span class="s3">in </span><span class="s1">headers.items(): 
                </span><span class="s0"># Raise exception on invalid header value.</span><span class="s1"> 
                check_header_validity(header) 
                name</span><span class="s3">, </span><span class="s1">value = header 
                self.headers[to_native_string(name)] = value 
 
    </span><span class="s3">def </span><span class="s1">prepare_body(self</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">files</span><span class="s3">, </span><span class="s1">json=</span><span class="s3">None</span><span class="s1">): 
        </span><span class="s2">&quot;&quot;&quot;Prepares the given HTTP body data.&quot;&quot;&quot;</span><span class="s1"> 
 
        </span><span class="s0"># Check if file, fo, generator, iterator.</span><span class="s1"> 
        </span><span class="s0"># If not, run through normal process.</span><span class="s1"> 
 
        </span><span class="s0"># Nottin' on you.</span><span class="s1"> 
        body = </span><span class="s3">None</span><span class="s1"> 
        content_type = </span><span class="s3">None</span><span class="s1"> 
        length = </span><span class="s3">None</span><span class="s1"> 
 
        </span><span class="s3">if not </span><span class="s1">data </span><span class="s3">and </span><span class="s1">json </span><span class="s3">is not None</span><span class="s1">: 
            </span><span class="s0"># urllib3 requires a bytes-like body. Python 2's json.dumps</span><span class="s1"> 
            </span><span class="s0"># provides this natively, but Python 3 gives a Unicode string.</span><span class="s1"> 
            content_type = </span><span class="s5">'application/json'</span><span class="s1"> 
            body = complexjson.dumps(json) 
            </span><span class="s3">if not </span><span class="s1">isinstance(body</span><span class="s3">, </span><span class="s1">bytes): 
                body = body.encode(</span><span class="s5">'utf-8'</span><span class="s1">) 
 
        is_stream = all([ 
            hasattr(data</span><span class="s3">, </span><span class="s5">'__iter__'</span><span class="s1">)</span><span class="s3">,</span><span class="s1"> 
            </span><span class="s3">not </span><span class="s1">isinstance(data</span><span class="s3">, </span><span class="s1">(basestring</span><span class="s3">, </span><span class="s1">list</span><span class="s3">, </span><span class="s1">tuple</span><span class="s3">, </span><span class="s1">dict)) 
        ]) 
 
        </span><span class="s3">try</span><span class="s1">: 
            length = super_len(data) 
        </span><span class="s3">except </span><span class="s1">(TypeError</span><span class="s3">, </span><span class="s1">AttributeError</span><span class="s3">, </span><span class="s1">UnsupportedOperation): 
            length = </span><span class="s3">None</span><span class="s1"> 
 
        </span><span class="s3">if </span><span class="s1">is_stream: 
            body = data 
 
            </span><span class="s3">if </span><span class="s1">files: 
                </span><span class="s3">raise </span><span class="s1">NotImplementedError(</span><span class="s5">'Streamed bodies and files are mutually exclusive.'</span><span class="s1">) 
 
            </span><span class="s3">if </span><span class="s1">length: 
                self.headers[</span><span class="s5">'Content-Length'</span><span class="s1">] = builtin_str(length) 
            </span><span class="s3">else</span><span class="s1">: 
                self.headers[</span><span class="s5">'Transfer-Encoding'</span><span class="s1">] = </span><span class="s5">'chunked'</span><span class="s1"> 
        </span><span class="s3">else</span><span class="s1">: 
            </span><span class="s0"># Multi-part file uploads.</span><span class="s1"> 
            </span><span class="s3">if </span><span class="s1">files: 
                (body</span><span class="s3">, </span><span class="s1">content_type) = self._encode_files(files</span><span class="s3">, </span><span class="s1">data) 
            </span><span class="s3">else</span><span class="s1">: 
                </span><span class="s3">if </span><span class="s1">data: 
                    body = self._encode_params(data) 
                    </span><span class="s3">if </span><span class="s1">isinstance(data</span><span class="s3">, </span><span class="s1">basestring) </span><span class="s3">or </span><span class="s1">hasattr(data</span><span class="s3">, </span><span class="s5">'read'</span><span class="s1">): 
                        content_type = </span><span class="s3">None</span><span class="s1"> 
                    </span><span class="s3">else</span><span class="s1">: 
                        content_type = </span><span class="s5">'application/x-www-form-urlencoded'</span><span class="s1"> 
 
            self.prepare_content_length(body) 
 
            </span><span class="s0"># Add content-type if it wasn't explicitly provided.</span><span class="s1"> 
            </span><span class="s3">if </span><span class="s1">content_type </span><span class="s3">and </span><span class="s1">(</span><span class="s5">'content-type' </span><span class="s3">not in </span><span class="s1">self.headers): 
                self.headers[</span><span class="s5">'Content-Type'</span><span class="s1">] = content_type 
 
        self.body = body 
 
    </span><span class="s3">def </span><span class="s1">prepare_content_length(self</span><span class="s3">, </span><span class="s1">body): 
        </span><span class="s3">if </span><span class="s1">hasattr(body</span><span class="s3">, </span><span class="s5">'seek'</span><span class="s1">) </span><span class="s3">and </span><span class="s1">hasattr(body</span><span class="s3">, </span><span class="s5">'tell'</span><span class="s1">): 
            curr_pos = body.tell() 
            body.seek(</span><span class="s4">0</span><span class="s3">, </span><span class="s4">2</span><span class="s1">) 
            end_pos = body.tell() 
            self.headers[</span><span class="s5">'Content-Length'</span><span class="s1">] = builtin_str(max(</span><span class="s4">0</span><span class="s3">, </span><span class="s1">end_pos - curr_pos)) 
            body.seek(curr_pos</span><span class="s3">, </span><span class="s4">0</span><span class="s1">) 
        </span><span class="s3">elif </span><span class="s1">body </span><span class="s3">is not None</span><span class="s1">: 
            l = super_len(body) 
            </span><span class="s3">if </span><span class="s1">l: 
                self.headers[</span><span class="s5">'Content-Length'</span><span class="s1">] = builtin_str(l) 
        </span><span class="s3">elif </span><span class="s1">(self.method </span><span class="s3">not in </span><span class="s1">(</span><span class="s5">'GET'</span><span class="s3">, </span><span class="s5">'HEAD'</span><span class="s1">)) </span><span class="s3">and </span><span class="s1">(self.headers.get(</span><span class="s5">'Content-Length'</span><span class="s1">) </span><span class="s3">is None</span><span class="s1">): 
            self.headers[</span><span class="s5">'Content-Length'</span><span class="s1">] = </span><span class="s5">'0'</span><span class="s1"> 
 
    </span><span class="s3">def </span><span class="s1">prepare_auth(self</span><span class="s3">, </span><span class="s1">auth</span><span class="s3">, </span><span class="s1">url=</span><span class="s5">''</span><span class="s1">): 
        </span><span class="s2">&quot;&quot;&quot;Prepares the given HTTP auth data.&quot;&quot;&quot;</span><span class="s1"> 
 
        </span><span class="s0"># If no Auth is explicitly provided, extract it from the URL first.</span><span class="s1"> 
        </span><span class="s3">if </span><span class="s1">auth </span><span class="s3">is None</span><span class="s1">: 
            url_auth = get_auth_from_url(self.url) 
            auth = url_auth </span><span class="s3">if </span><span class="s1">any(url_auth) </span><span class="s3">else None</span><span class="s1"> 
 
        </span><span class="s3">if </span><span class="s1">auth: 
            </span><span class="s3">if </span><span class="s1">isinstance(auth</span><span class="s3">, </span><span class="s1">tuple) </span><span class="s3">and </span><span class="s1">len(auth) == </span><span class="s4">2</span><span class="s1">: 
                </span><span class="s0"># special-case basic HTTP auth</span><span class="s1"> 
                auth = HTTPBasicAuth(*auth) 
 
            </span><span class="s0"># Allow auth to make its changes.</span><span class="s1"> 
            r = auth(self) 
 
            </span><span class="s0"># Update self to reflect the auth changes.</span><span class="s1"> 
            self.__dict__.update(r.__dict__) 
 
            </span><span class="s0"># Recompute Content-Length</span><span class="s1"> 
            self.prepare_content_length(self.body) 
 
    </span><span class="s3">def </span><span class="s1">prepare_cookies(self</span><span class="s3">, </span><span class="s1">cookies): 
        </span><span class="s2">&quot;&quot;&quot;Prepares the given HTTP cookie data. 
 
        This function eventually generates a ``Cookie`` header from the 
        given cookies using cookielib. Due to cookielib's design, the header 
        will not be regenerated if it already exists, meaning this function 
        can only be called once for the life of the 
        :class:`PreparedRequest &lt;PreparedRequest&gt;` object. Any subsequent calls 
        to ``prepare_cookies`` will have no actual effect, unless the &quot;Cookie&quot; 
        header is removed beforehand. 
        &quot;&quot;&quot;</span><span class="s1"> 
        </span><span class="s3">if </span><span class="s1">isinstance(cookies</span><span class="s3">, </span><span class="s1">cookielib.CookieJar): 
            self._cookies = cookies 
        </span><span class="s3">else</span><span class="s1">: 
            self._cookies = cookiejar_from_dict(cookies) 
 
        cookie_header = get_cookie_header(self._cookies</span><span class="s3">, </span><span class="s1">self) 
        </span><span class="s3">if </span><span class="s1">cookie_header </span><span class="s3">is not None</span><span class="s1">: 
            self.headers[</span><span class="s5">'Cookie'</span><span class="s1">] = cookie_header 
 
    </span><span class="s3">def </span><span class="s1">prepare_hooks(self</span><span class="s3">, </span><span class="s1">hooks): 
        </span><span class="s2">&quot;&quot;&quot;Prepares the given hooks.&quot;&quot;&quot;</span><span class="s1"> 
        </span><span class="s0"># hooks can be passed as None to the prepare method and to this</span><span class="s1"> 
        </span><span class="s0"># method. To prevent iterating over None, simply use an empty list</span><span class="s1"> 
        </span><span class="s0"># if hooks is False-y</span><span class="s1"> 
        hooks = hooks </span><span class="s3">or </span><span class="s1">[] 
        </span><span class="s3">for </span><span class="s1">event </span><span class="s3">in </span><span class="s1">hooks: 
            self.register_hook(event</span><span class="s3">, </span><span class="s1">hooks[event]) 
 
 
</span><span class="s3">class </span><span class="s1">Response(object): 
    </span><span class="s2">&quot;&quot;&quot;The :class:`Response &lt;Response&gt;` object, which contains a 
    server's response to an HTTP request. 
    &quot;&quot;&quot;</span><span class="s1"> 
 
    __attrs__ = [ 
        </span><span class="s5">'_content'</span><span class="s3">, </span><span class="s5">'status_code'</span><span class="s3">, </span><span class="s5">'headers'</span><span class="s3">, </span><span class="s5">'url'</span><span class="s3">, </span><span class="s5">'history'</span><span class="s3">,</span><span class="s1"> 
        </span><span class="s5">'encoding'</span><span class="s3">, </span><span class="s5">'reason'</span><span class="s3">, </span><span class="s5">'cookies'</span><span class="s3">, </span><span class="s5">'elapsed'</span><span class="s3">, </span><span class="s5">'request'</span><span class="s1"> 
    ] 
 
    </span><span class="s3">def </span><span class="s1">__init__(self): 
        super(Response</span><span class="s3">, </span><span class="s1">self).__init__() 
 
        self._content = </span><span class="s3">False</span><span class="s1"> 
        self._content_consumed = </span><span class="s3">False</span><span class="s1"> 
 
        </span><span class="s0">#: Integer Code of responded HTTP Status, e.g. 404 or 200.</span><span class="s1"> 
        self.status_code = </span><span class="s3">None</span><span class="s1"> 
 
        </span><span class="s0">#: Case-insensitive Dictionary of Response Headers.</span><span class="s1"> 
        </span><span class="s0">#: For example, ``headers['content-encoding']`` will return the</span><span class="s1"> 
        </span><span class="s0">#: value of a ``'Content-Encoding'`` response header.</span><span class="s1"> 
        self.headers = CaseInsensitiveDict() 
 
        </span><span class="s0">#: File-like object representation of response (for advanced usage).</span><span class="s1"> 
        </span><span class="s0">#: Use of ``raw`` requires that ``stream=True`` be set on the request.</span><span class="s1"> 
        </span><span class="s0"># This requirement does not apply for use internally to Requests.</span><span class="s1"> 
        self.raw = </span><span class="s3">None</span><span class="s1"> 
 
        </span><span class="s0">#: Final URL location of Response.</span><span class="s1"> 
        self.url = </span><span class="s3">None</span><span class="s1"> 
 
        </span><span class="s0">#: Encoding to decode with when accessing r.text.</span><span class="s1"> 
        self.encoding = </span><span class="s3">None</span><span class="s1"> 
 
        </span><span class="s0">#: A list of :class:`Response &lt;Response&gt;` objects from</span><span class="s1"> 
        </span><span class="s0">#: the history of the Request. Any redirect responses will end</span><span class="s1"> 
        </span><span class="s0">#: up here. The list is sorted from the oldest to the most recent request.</span><span class="s1"> 
        self.history = [] 
 
        </span><span class="s0">#: Textual reason of responded HTTP Status, e.g. &quot;Not Found&quot; or &quot;OK&quot;.</span><span class="s1"> 
        self.reason = </span><span class="s3">None</span><span class="s1"> 
 
        </span><span class="s0">#: A CookieJar of Cookies the server sent back.</span><span class="s1"> 
        self.cookies = cookiejar_from_dict({}) 
 
        </span><span class="s0">#: The amount of time elapsed between sending the request</span><span class="s1"> 
        </span><span class="s0">#: and the arrival of the response (as a timedelta).</span><span class="s1"> 
        </span><span class="s0">#: This property specifically measures the time taken between sending</span><span class="s1"> 
        </span><span class="s0">#: the first byte of the request and finishing parsing the headers. It</span><span class="s1"> 
        </span><span class="s0">#: is therefore unaffected by consuming the response content or the</span><span class="s1"> 
        </span><span class="s0">#: value of the ``stream`` keyword argument.</span><span class="s1"> 
        self.elapsed = datetime.timedelta(</span><span class="s4">0</span><span class="s1">) 
 
        </span><span class="s0">#: The :class:`PreparedRequest &lt;PreparedRequest&gt;` object to which this</span><span class="s1"> 
        </span><span class="s0">#: is a response.</span><span class="s1"> 
        self.request = </span><span class="s3">None</span><span class="s1"> 
 
    </span><span class="s3">def </span><span class="s1">__getstate__(self): 
        </span><span class="s0"># Consume everything; accessing the content attribute makes</span><span class="s1"> 
        </span><span class="s0"># sure the content has been fully read.</span><span class="s1"> 
        </span><span class="s3">if not </span><span class="s1">self._content_consumed: 
            self.content 
 
        </span><span class="s3">return </span><span class="s1">dict( 
            (attr</span><span class="s3">, </span><span class="s1">getattr(self</span><span class="s3">, </span><span class="s1">attr</span><span class="s3">, None</span><span class="s1">)) 
            </span><span class="s3">for </span><span class="s1">attr </span><span class="s3">in </span><span class="s1">self.__attrs__ 
        ) 
 
    </span><span class="s3">def </span><span class="s1">__setstate__(self</span><span class="s3">, </span><span class="s1">state): 
        </span><span class="s3">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">value </span><span class="s3">in </span><span class="s1">state.items(): 
            setattr(self</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">value) 
 
        </span><span class="s0"># pickled objects do not have .raw</span><span class="s1"> 
        setattr(self</span><span class="s3">, </span><span class="s5">'_content_consumed'</span><span class="s3">, True</span><span class="s1">) 
        setattr(self</span><span class="s3">, </span><span class="s5">'raw'</span><span class="s3">, None</span><span class="s1">) 
 
    </span><span class="s3">def </span><span class="s1">__repr__(self): 
        </span><span class="s3">return </span><span class="s5">'&lt;Response [%s]&gt;' </span><span class="s1">% (self.status_code) 
 
    </span><span class="s3">def </span><span class="s1">__bool__(self): 
        </span><span class="s2">&quot;&quot;&quot;Returns true if :attr:`status_code` is 'OK'.&quot;&quot;&quot;</span><span class="s1"> 
        </span><span class="s3">return </span><span class="s1">self.ok 
 
    </span><span class="s3">def </span><span class="s1">__nonzero__(self): 
        </span><span class="s2">&quot;&quot;&quot;Returns true if :attr:`status_code` is 'OK'.&quot;&quot;&quot;</span><span class="s1"> 
        </span><span class="s3">return </span><span class="s1">self.ok 
 
    </span><span class="s3">def </span><span class="s1">__iter__(self): 
        </span><span class="s2">&quot;&quot;&quot;Allows you to use a response as an iterator.&quot;&quot;&quot;</span><span class="s1"> 
        </span><span class="s3">return </span><span class="s1">self.iter_content(</span><span class="s4">128</span><span class="s1">) 
 
    @property 
    </span><span class="s3">def </span><span class="s1">ok(self): 
        </span><span class="s3">try</span><span class="s1">: 
            self.raise_for_status() 
        </span><span class="s3">except </span><span class="s1">HTTPError: 
            </span><span class="s3">return False</span><span class="s1"> 
        </span><span class="s3">return True</span><span class="s1"> 
 
    @property 
    </span><span class="s3">def </span><span class="s1">is_redirect(self): 
        </span><span class="s2">&quot;&quot;&quot;True if this Response is a well-formed HTTP redirect that could have 
        been processed automatically (by :meth:`Session.resolve_redirects`). 
        &quot;&quot;&quot;</span><span class="s1"> 
        </span><span class="s3">return </span><span class="s1">(</span><span class="s5">'location' </span><span class="s3">in </span><span class="s1">self.headers </span><span class="s3">and </span><span class="s1">self.status_code </span><span class="s3">in </span><span class="s1">REDIRECT_STATI) 
 
    @property 
    </span><span class="s3">def </span><span class="s1">is_permanent_redirect(self): 
        </span><span class="s2">&quot;&quot;&quot;True if this Response one of the permanent versions of redirect&quot;&quot;&quot;</span><span class="s1"> 
        </span><span class="s3">return </span><span class="s1">(</span><span class="s5">'location' </span><span class="s3">in </span><span class="s1">self.headers </span><span class="s3">and </span><span class="s1">self.status_code </span><span class="s3">in </span><span class="s1">(codes.moved_permanently</span><span class="s3">, </span><span class="s1">codes.permanent_redirect)) 
 
    @property 
    </span><span class="s3">def </span><span class="s1">apparent_encoding(self): 
        </span><span class="s2">&quot;&quot;&quot;The apparent encoding, provided by the chardet library&quot;&quot;&quot;</span><span class="s1"> 
        </span><span class="s3">return </span><span class="s1">chardet.detect(self.content)[</span><span class="s5">'encoding'</span><span class="s1">] 
 
    </span><span class="s3">def </span><span class="s1">iter_content(self</span><span class="s3">, </span><span class="s1">chunk_size=</span><span class="s4">1</span><span class="s3">, </span><span class="s1">decode_unicode=</span><span class="s3">False</span><span class="s1">): 
        </span><span class="s2">&quot;&quot;&quot;Iterates over the response data.  When stream=True is set on the 
        request, this avoids reading the content at once into memory for 
        large responses.  The chunk size is the number of bytes it should 
        read into memory.  This is not necessarily the length of each item 
        returned as decoding can take place. 
 
        chunk_size must be of type int or None. A value of None will 
        function differently depending on the value of `stream`. 
        stream=True will read data as it arrives in whatever size the 
        chunks are received. If stream=False, data is returned as 
        a single chunk. 
 
        If decode_unicode is True, content will be decoded using the best 
        available encoding based on the response. 
        &quot;&quot;&quot;</span><span class="s1"> 
 
        </span><span class="s3">def </span><span class="s1">generate(): 
            </span><span class="s0"># Special case for urllib3.</span><span class="s1"> 
            </span><span class="s3">if </span><span class="s1">hasattr(self.raw</span><span class="s3">, </span><span class="s5">'stream'</span><span class="s1">): 
                </span><span class="s3">try</span><span class="s1">: 
                    </span><span class="s3">for </span><span class="s1">chunk </span><span class="s3">in </span><span class="s1">self.raw.stream(chunk_size</span><span class="s3">, </span><span class="s1">decode_content=</span><span class="s3">True</span><span class="s1">): 
                        </span><span class="s3">yield </span><span class="s1">chunk 
                </span><span class="s3">except </span><span class="s1">ProtocolError </span><span class="s3">as </span><span class="s1">e: 
                    </span><span class="s3">raise </span><span class="s1">ChunkedEncodingError(e) 
                </span><span class="s3">except </span><span class="s1">DecodeError </span><span class="s3">as </span><span class="s1">e: 
                    </span><span class="s3">raise </span><span class="s1">ContentDecodingError(e) 
                </span><span class="s3">except </span><span class="s1">ReadTimeoutError </span><span class="s3">as </span><span class="s1">e: 
                    </span><span class="s3">raise </span><span class="s1">ConnectionError(e) 
            </span><span class="s3">else</span><span class="s1">: 
                </span><span class="s0"># Standard file-like object.</span><span class="s1"> 
                </span><span class="s3">while True</span><span class="s1">: 
                    chunk = self.raw.read(chunk_size) 
                    </span><span class="s3">if not </span><span class="s1">chunk: 
                        </span><span class="s3">break</span><span class="s1"> 
                    </span><span class="s3">yield </span><span class="s1">chunk 
 
            self._content_consumed = </span><span class="s3">True</span><span class="s1"> 
 
        </span><span class="s3">if </span><span class="s1">self._content_consumed </span><span class="s3">and </span><span class="s1">isinstance(self._content</span><span class="s3">, </span><span class="s1">bool): 
            </span><span class="s3">raise </span><span class="s1">StreamConsumedError() 
        </span><span class="s3">elif </span><span class="s1">chunk_size </span><span class="s3">is not None and not </span><span class="s1">isinstance(chunk_size</span><span class="s3">, </span><span class="s1">int): 
            </span><span class="s3">raise </span><span class="s1">TypeError(</span><span class="s5">&quot;chunk_size must be an int, it is instead a %s.&quot; </span><span class="s1">% type(chunk_size)) 
        </span><span class="s0"># simulate reading small chunks of the content</span><span class="s1"> 
        reused_chunks = iter_slices(self._content</span><span class="s3">, </span><span class="s1">chunk_size) 
 
        stream_chunks = generate() 
 
        chunks = reused_chunks </span><span class="s3">if </span><span class="s1">self._content_consumed </span><span class="s3">else </span><span class="s1">stream_chunks 
 
        </span><span class="s3">if </span><span class="s1">decode_unicode: 
            chunks = stream_decode_response_unicode(chunks</span><span class="s3">, </span><span class="s1">self) 
 
        </span><span class="s3">return </span><span class="s1">chunks 
 
    </span><span class="s3">def </span><span class="s1">iter_lines(self</span><span class="s3">, </span><span class="s1">chunk_size=ITER_CHUNK_SIZE</span><span class="s3">, </span><span class="s1">decode_unicode=</span><span class="s3">None, </span><span class="s1">delimiter=</span><span class="s3">None</span><span class="s1">): 
        </span><span class="s2">&quot;&quot;&quot;Iterates over the response data, one line at a time.  When 
        stream=True is set on the request, this avoids reading the 
        content at once into memory for large responses. 
 
        .. note:: This method is not reentrant safe. 
        &quot;&quot;&quot;</span><span class="s1"> 
 
        pending = </span><span class="s3">None</span><span class="s1"> 
 
        </span><span class="s3">for </span><span class="s1">chunk </span><span class="s3">in </span><span class="s1">self.iter_content(chunk_size=chunk_size</span><span class="s3">, </span><span class="s1">decode_unicode=decode_unicode): 
 
            </span><span class="s3">if </span><span class="s1">pending </span><span class="s3">is not None</span><span class="s1">: 
                chunk = pending + chunk 
 
            </span><span class="s3">if </span><span class="s1">delimiter: 
                lines = chunk.split(delimiter) 
            </span><span class="s3">else</span><span class="s1">: 
                lines = chunk.splitlines() 
 
            </span><span class="s3">if </span><span class="s1">lines </span><span class="s3">and </span><span class="s1">lines[-</span><span class="s4">1</span><span class="s1">] </span><span class="s3">and </span><span class="s1">chunk </span><span class="s3">and </span><span class="s1">lines[-</span><span class="s4">1</span><span class="s1">][-</span><span class="s4">1</span><span class="s1">] == chunk[-</span><span class="s4">1</span><span class="s1">]: 
                pending = lines.pop() 
            </span><span class="s3">else</span><span class="s1">: 
                pending = </span><span class="s3">None</span><span class="s1"> 
 
            </span><span class="s3">for </span><span class="s1">line </span><span class="s3">in </span><span class="s1">lines: 
                </span><span class="s3">yield </span><span class="s1">line 
 
        </span><span class="s3">if </span><span class="s1">pending </span><span class="s3">is not None</span><span class="s1">: 
            </span><span class="s3">yield </span><span class="s1">pending 
 
    @property 
    </span><span class="s3">def </span><span class="s1">content(self): 
        </span><span class="s2">&quot;&quot;&quot;Content of the response, in bytes.&quot;&quot;&quot;</span><span class="s1"> 
 
        </span><span class="s3">if </span><span class="s1">self._content </span><span class="s3">is False</span><span class="s1">: 
            </span><span class="s0"># Read the contents.</span><span class="s1"> 
            </span><span class="s3">try</span><span class="s1">: 
                </span><span class="s3">if </span><span class="s1">self._content_consumed: 
                    </span><span class="s3">raise </span><span class="s1">RuntimeError( 
                        </span><span class="s5">'The content for this response was already consumed'</span><span class="s1">) 
 
                </span><span class="s3">if </span><span class="s1">self.status_code == </span><span class="s4">0</span><span class="s1">: 
                    self._content = </span><span class="s3">None</span><span class="s1"> 
                </span><span class="s3">else</span><span class="s1">: 
                    self._content = bytes().join(self.iter_content(CONTENT_CHUNK_SIZE)) </span><span class="s3">or </span><span class="s1">bytes() 
 
            </span><span class="s3">except </span><span class="s1">AttributeError: 
                self._content = </span><span class="s3">None</span><span class="s1"> 
 
        self._content_consumed = </span><span class="s3">True</span><span class="s1"> 
        </span><span class="s0"># don't need to release the connection; that's been handled by urllib3</span><span class="s1"> 
        </span><span class="s0"># since we exhausted the data.</span><span class="s1"> 
        </span><span class="s3">return </span><span class="s1">self._content 
 
    @property 
    </span><span class="s3">def </span><span class="s1">text(self): 
        </span><span class="s2">&quot;&quot;&quot;Content of the response, in unicode. 
 
        If Response.encoding is None, encoding will be guessed using 
        ``chardet``. 
 
        The encoding of the response content is determined based solely on HTTP 
        headers, following RFC 2616 to the letter. If you can take advantage of 
        non-HTTP knowledge to make a better guess at the encoding, you should 
        set ``r.encoding`` appropriately before accessing this property. 
        &quot;&quot;&quot;</span><span class="s1"> 
 
        </span><span class="s0"># Try charset from content-type</span><span class="s1"> 
        content = </span><span class="s3">None</span><span class="s1"> 
        encoding = self.encoding 
 
        </span><span class="s3">if not </span><span class="s1">self.content: 
            </span><span class="s3">return </span><span class="s1">str(</span><span class="s5">''</span><span class="s1">) 
 
        </span><span class="s0"># Fallback to auto-detected encoding.</span><span class="s1"> 
        </span><span class="s3">if </span><span class="s1">self.encoding </span><span class="s3">is None</span><span class="s1">: 
            encoding = self.apparent_encoding 
 
        </span><span class="s0"># Decode unicode from given encoding.</span><span class="s1"> 
        </span><span class="s3">try</span><span class="s1">: 
            content = str(self.content</span><span class="s3">, </span><span class="s1">encoding</span><span class="s3">, </span><span class="s1">errors=</span><span class="s5">'replace'</span><span class="s1">) 
        </span><span class="s3">except </span><span class="s1">(LookupError</span><span class="s3">, </span><span class="s1">TypeError): 
            </span><span class="s0"># A LookupError is raised if the encoding was not found which could</span><span class="s1"> 
            </span><span class="s0"># indicate a misspelling or similar mistake.</span><span class="s1"> 
            </span><span class="s0">#</span><span class="s1"> 
            </span><span class="s0"># A TypeError can be raised if encoding is None</span><span class="s1"> 
            </span><span class="s0">#</span><span class="s1"> 
            </span><span class="s0"># So we try blindly encoding.</span><span class="s1"> 
            content = str(self.content</span><span class="s3">, </span><span class="s1">errors=</span><span class="s5">'replace'</span><span class="s1">) 
 
        </span><span class="s3">return </span><span class="s1">content 
 
    </span><span class="s3">def </span><span class="s1">json(self</span><span class="s3">, </span><span class="s1">**kwargs): 
        </span><span class="s2">&quot;&quot;&quot;Returns the json-encoded content of a response, if any. 
 
        :param \*\*kwargs: Optional arguments that ``json.loads`` takes. 
        &quot;&quot;&quot;</span><span class="s1"> 
 
        </span><span class="s3">if not </span><span class="s1">self.encoding </span><span class="s3">and </span><span class="s1">self.content </span><span class="s3">and </span><span class="s1">len(self.content) &gt; </span><span class="s4">3</span><span class="s1">: 
            </span><span class="s0"># No encoding set. JSON RFC 4627 section 3 states we should expect</span><span class="s1"> 
            </span><span class="s0"># UTF-8, -16 or -32. Detect which one to use; If the detection or</span><span class="s1"> 
            </span><span class="s0"># decoding fails, fall back to `self.text` (using chardet to make</span><span class="s1"> 
            </span><span class="s0"># a best guess).</span><span class="s1"> 
            encoding = guess_json_utf(self.content) 
            </span><span class="s3">if </span><span class="s1">encoding </span><span class="s3">is not None</span><span class="s1">: 
                </span><span class="s3">try</span><span class="s1">: 
                    </span><span class="s3">return </span><span class="s1">complexjson.loads( 
                        self.content.decode(encoding)</span><span class="s3">, </span><span class="s1">**kwargs 
                    ) 
                </span><span class="s3">except </span><span class="s1">UnicodeDecodeError: 
                    </span><span class="s0"># Wrong UTF codec detected; usually because it's not UTF-8</span><span class="s1"> 
                    </span><span class="s0"># but some other 8-bit codec.  This is an RFC violation,</span><span class="s1"> 
                    </span><span class="s0"># and the server didn't bother to tell us what codec *was*</span><span class="s1"> 
                    </span><span class="s0"># used.</span><span class="s1"> 
                    </span><span class="s3">pass</span><span class="s1"> 
        </span><span class="s3">return </span><span class="s1">complexjson.loads(self.text</span><span class="s3">, </span><span class="s1">**kwargs) 
 
    @property 
    </span><span class="s3">def </span><span class="s1">links(self): 
        </span><span class="s2">&quot;&quot;&quot;Returns the parsed header links of the response, if any.&quot;&quot;&quot;</span><span class="s1"> 
 
        header = self.headers.get(</span><span class="s5">'link'</span><span class="s1">) 
 
        </span><span class="s0"># l = MultiDict()</span><span class="s1"> 
        l = {} 
 
        </span><span class="s3">if </span><span class="s1">header: 
            links = parse_header_links(header) 
 
            </span><span class="s3">for </span><span class="s1">link </span><span class="s3">in </span><span class="s1">links: 
                key = link.get(</span><span class="s5">'rel'</span><span class="s1">) </span><span class="s3">or </span><span class="s1">link.get(</span><span class="s5">'url'</span><span class="s1">) 
                l[key] = link 
 
        </span><span class="s3">return </span><span class="s1">l 
 
    </span><span class="s3">def </span><span class="s1">raise_for_status(self): 
        </span><span class="s2">&quot;&quot;&quot;Raises stored :class:`HTTPError`, if one occurred.&quot;&quot;&quot;</span><span class="s1"> 
 
        http_error_msg = </span><span class="s5">''</span><span class="s1"> 
        </span><span class="s3">if </span><span class="s1">isinstance(self.reason</span><span class="s3">, </span><span class="s1">bytes): 
            reason = self.reason.decode(</span><span class="s5">'utf-8'</span><span class="s3">, </span><span class="s5">'ignore'</span><span class="s1">) 
        </span><span class="s3">else</span><span class="s1">: 
            reason = self.reason 
 
        </span><span class="s3">if </span><span class="s4">400 </span><span class="s1">&lt;= self.status_code &lt; </span><span class="s4">500</span><span class="s1">: 
            http_error_msg = </span><span class="s5">u'%s Client Error: %s for url: %s' </span><span class="s1">% (self.status_code</span><span class="s3">, </span><span class="s1">reason</span><span class="s3">, </span><span class="s1">self.url) 
 
        </span><span class="s3">elif </span><span class="s4">500 </span><span class="s1">&lt;= self.status_code &lt; </span><span class="s4">600</span><span class="s1">: 
            http_error_msg = </span><span class="s5">u'%s Server Error: %s for url: %s' </span><span class="s1">% (self.status_code</span><span class="s3">, </span><span class="s1">reason</span><span class="s3">, </span><span class="s1">self.url) 
 
        </span><span class="s3">if </span><span class="s1">http_error_msg: 
            </span><span class="s3">raise </span><span class="s1">HTTPError(http_error_msg</span><span class="s3">, </span><span class="s1">response=self) 
 
    </span><span class="s3">def </span><span class="s1">close(self): 
        </span><span class="s2">&quot;&quot;&quot;Releases the connection back to the pool. Once this method has been 
        called the underlying ``raw`` object must not be accessed again. 
 
        *Note: Should not normally need to be called explicitly.* 
        &quot;&quot;&quot;</span><span class="s1"> 
        </span><span class="s3">if not </span><span class="s1">self._content_consumed: 
            self.raw.close() 
 
        </span><span class="s3">return </span><span class="s1">self.raw.release_conn() 
</span></pre>
</body>
</html>