<html>
<head>
<title>codecs.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.ln { color: #606366; font-weight: normal; font-style: normal; }
.s0 { color: rgb(106,135,89); }
.s1 { color: rgb(128,128,128); }
.s2 { color: rgb(169,183,198); }
.s3 { color: rgb(204,120,50); }
.s4 { color: rgb(165,194,97); }
.s5 { color: rgb(98,151,85); font-style: italic; }
.s6 { color: rgb(104,151,187); }
</style>
</head>
<BODY BGCOLOR="#2b2b2b">
<TABLE CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<TR><TD><CENTER>
<FONT FACE="Arial, Helvetica" COLOR="#000000">
codecs.py</FONT>
</center></TD></TR></TABLE>
<pre>
<span class="s0">&quot;&quot;&quot; codecs -- Python Codec Registry, API and helpers. 
 
 
Written by Marc-Andre Lemburg (mal@lemburg.com). 
 
(c) Copyright CNRI, All Rights Reserved. NO WARRANTY. 
 
&quot;&quot;&quot;</span><span class="s1">#&quot;</span><span class="s2"> 
 
</span><span class="s3">import </span><span class="s2">builtins</span><span class="s3">, </span><span class="s2">sys 
 
</span><span class="s1">### Registry and builtin stateless codec functions</span><span class="s2"> 
 
</span><span class="s3">try</span><span class="s2">: 
    </span><span class="s3">from </span><span class="s2">_codecs </span><span class="s3">import </span><span class="s2">* 
</span><span class="s3">except </span><span class="s2">ImportError </span><span class="s3">as </span><span class="s2">why: 
    </span><span class="s3">raise </span><span class="s2">SystemError(</span><span class="s0">'Failed to load the builtin codecs: %s' </span><span class="s2">% why) 
 
__all__ = [</span><span class="s0">&quot;register&quot;</span><span class="s3">, </span><span class="s0">&quot;lookup&quot;</span><span class="s3">, </span><span class="s0">&quot;open&quot;</span><span class="s3">, </span><span class="s0">&quot;EncodedFile&quot;</span><span class="s3">, </span><span class="s0">&quot;BOM&quot;</span><span class="s3">, </span><span class="s0">&quot;BOM_BE&quot;</span><span class="s3">,</span><span class="s2"> 
           </span><span class="s0">&quot;BOM_LE&quot;</span><span class="s3">, </span><span class="s0">&quot;BOM32_BE&quot;</span><span class="s3">, </span><span class="s0">&quot;BOM32_LE&quot;</span><span class="s3">, </span><span class="s0">&quot;BOM64_BE&quot;</span><span class="s3">, </span><span class="s0">&quot;BOM64_LE&quot;</span><span class="s3">,</span><span class="s2"> 
           </span><span class="s0">&quot;BOM_UTF8&quot;</span><span class="s3">, </span><span class="s0">&quot;BOM_UTF16&quot;</span><span class="s3">, </span><span class="s0">&quot;BOM_UTF16_LE&quot;</span><span class="s3">, </span><span class="s0">&quot;BOM_UTF16_BE&quot;</span><span class="s3">,</span><span class="s2"> 
           </span><span class="s0">&quot;BOM_UTF32&quot;</span><span class="s3">, </span><span class="s0">&quot;BOM_UTF32_LE&quot;</span><span class="s3">, </span><span class="s0">&quot;BOM_UTF32_BE&quot;</span><span class="s3">,</span><span class="s2"> 
           </span><span class="s0">&quot;CodecInfo&quot;</span><span class="s3">, </span><span class="s0">&quot;Codec&quot;</span><span class="s3">, </span><span class="s0">&quot;IncrementalEncoder&quot;</span><span class="s3">, </span><span class="s0">&quot;IncrementalDecoder&quot;</span><span class="s3">,</span><span class="s2"> 
           </span><span class="s0">&quot;StreamReader&quot;</span><span class="s3">, </span><span class="s0">&quot;StreamWriter&quot;</span><span class="s3">,</span><span class="s2"> 
           </span><span class="s0">&quot;StreamReaderWriter&quot;</span><span class="s3">, </span><span class="s0">&quot;StreamRecoder&quot;</span><span class="s3">,</span><span class="s2"> 
           </span><span class="s0">&quot;getencoder&quot;</span><span class="s3">, </span><span class="s0">&quot;getdecoder&quot;</span><span class="s3">, </span><span class="s0">&quot;getincrementalencoder&quot;</span><span class="s3">,</span><span class="s2"> 
           </span><span class="s0">&quot;getincrementaldecoder&quot;</span><span class="s3">, </span><span class="s0">&quot;getreader&quot;</span><span class="s3">, </span><span class="s0">&quot;getwriter&quot;</span><span class="s3">,</span><span class="s2"> 
           </span><span class="s0">&quot;encode&quot;</span><span class="s3">, </span><span class="s0">&quot;decode&quot;</span><span class="s3">, </span><span class="s0">&quot;iterencode&quot;</span><span class="s3">, </span><span class="s0">&quot;iterdecode&quot;</span><span class="s3">,</span><span class="s2"> 
           </span><span class="s0">&quot;strict_errors&quot;</span><span class="s3">, </span><span class="s0">&quot;ignore_errors&quot;</span><span class="s3">, </span><span class="s0">&quot;replace_errors&quot;</span><span class="s3">,</span><span class="s2"> 
           </span><span class="s0">&quot;xmlcharrefreplace_errors&quot;</span><span class="s3">,</span><span class="s2"> 
           </span><span class="s0">&quot;backslashreplace_errors&quot;</span><span class="s3">, </span><span class="s0">&quot;namereplace_errors&quot;</span><span class="s3">,</span><span class="s2"> 
           </span><span class="s0">&quot;register_error&quot;</span><span class="s3">, </span><span class="s0">&quot;lookup_error&quot;</span><span class="s2">] 
 
</span><span class="s1">### Constants</span><span class="s2"> 
 
</span><span class="s1">#</span><span class="s2"> 
</span><span class="s1"># Byte Order Mark (BOM = ZERO WIDTH NO-BREAK SPACE = U+FEFF)</span><span class="s2"> 
</span><span class="s1"># and its possible byte string values</span><span class="s2"> 
</span><span class="s1"># for UTF8/UTF16/UTF32 output and little/big endian machines</span><span class="s2"> 
</span><span class="s1">#</span><span class="s2"> 
 
</span><span class="s1"># UTF-8</span><span class="s2"> 
BOM_UTF8 = </span><span class="s4">b'</span><span class="s3">\xef\xbb\xbf</span><span class="s4">'</span><span class="s2"> 
 
</span><span class="s1"># UTF-16, little endian</span><span class="s2"> 
BOM_LE = BOM_UTF16_LE = </span><span class="s4">b'</span><span class="s3">\xff\xfe</span><span class="s4">'</span><span class="s2"> 
 
</span><span class="s1"># UTF-16, big endian</span><span class="s2"> 
BOM_BE = BOM_UTF16_BE = </span><span class="s4">b'</span><span class="s3">\xfe\xff</span><span class="s4">'</span><span class="s2"> 
 
</span><span class="s1"># UTF-32, little endian</span><span class="s2"> 
BOM_UTF32_LE = </span><span class="s4">b'</span><span class="s3">\xff\xfe\x00\x00</span><span class="s4">'</span><span class="s2"> 
 
</span><span class="s1"># UTF-32, big endian</span><span class="s2"> 
BOM_UTF32_BE = </span><span class="s4">b'</span><span class="s3">\x00\x00\xfe\xff</span><span class="s4">'</span><span class="s2"> 
 
</span><span class="s3">if </span><span class="s2">sys.byteorder == </span><span class="s0">'little'</span><span class="s2">: 
 
    </span><span class="s1"># UTF-16, native endianness</span><span class="s2"> 
    BOM = BOM_UTF16 = BOM_UTF16_LE 
 
    </span><span class="s1"># UTF-32, native endianness</span><span class="s2"> 
    BOM_UTF32 = BOM_UTF32_LE 
 
</span><span class="s3">else</span><span class="s2">: 
 
    </span><span class="s1"># UTF-16, native endianness</span><span class="s2"> 
    BOM = BOM_UTF16 = BOM_UTF16_BE 
 
    </span><span class="s1"># UTF-32, native endianness</span><span class="s2"> 
    BOM_UTF32 = BOM_UTF32_BE 
 
</span><span class="s1"># Old broken names (don't use in new code)</span><span class="s2"> 
BOM32_LE = BOM_UTF16_LE 
BOM32_BE = BOM_UTF16_BE 
BOM64_LE = BOM_UTF32_LE 
BOM64_BE = BOM_UTF32_BE 
 
 
</span><span class="s1">### Codec base classes (defining the API)</span><span class="s2"> 
 
</span><span class="s3">class </span><span class="s2">CodecInfo(tuple): 
    </span><span class="s5">&quot;&quot;&quot;Codec details when looking up the codec registry&quot;&quot;&quot;</span><span class="s2"> 
 
    </span><span class="s1"># Private API to allow Python 3.4 to blacklist the known non-Unicode</span><span class="s2"> 
    </span><span class="s1"># codecs in the standard library. A more general mechanism to</span><span class="s2"> 
    </span><span class="s1"># reliably distinguish test encodings from other codecs will hopefully</span><span class="s2"> 
    </span><span class="s1"># be defined for Python 3.5</span><span class="s2"> 
    </span><span class="s1">#</span><span class="s2"> 
    </span><span class="s1"># See http://bugs.python.org/issue19619</span><span class="s2"> 
    _is_text_encoding = </span><span class="s3">True </span><span class="s1"># Assume codecs are text encodings by default</span><span class="s2"> 
 
    </span><span class="s3">def </span><span class="s2">__new__(cls</span><span class="s3">, </span><span class="s2">encode</span><span class="s3">, </span><span class="s2">decode</span><span class="s3">, </span><span class="s2">streamreader=</span><span class="s3">None, </span><span class="s2">streamwriter=</span><span class="s3">None,</span><span class="s2"> 
        incrementalencoder=</span><span class="s3">None, </span><span class="s2">incrementaldecoder=</span><span class="s3">None, </span><span class="s2">name=</span><span class="s3">None,</span><span class="s2"> 
        *</span><span class="s3">, </span><span class="s2">_is_text_encoding=</span><span class="s3">None</span><span class="s2">): 
        self = tuple.__new__(cls</span><span class="s3">, </span><span class="s2">(encode</span><span class="s3">, </span><span class="s2">decode</span><span class="s3">, </span><span class="s2">streamreader</span><span class="s3">, </span><span class="s2">streamwriter)) 
        self.name = name 
        self.encode = encode 
        self.decode = decode 
        self.incrementalencoder = incrementalencoder 
        self.incrementaldecoder = incrementaldecoder 
        self.streamwriter = streamwriter 
        self.streamreader = streamreader 
        </span><span class="s3">if </span><span class="s2">_is_text_encoding </span><span class="s3">is not None</span><span class="s2">: 
            self._is_text_encoding = _is_text_encoding 
        </span><span class="s3">return </span><span class="s2">self 
 
    </span><span class="s3">def </span><span class="s2">__repr__(self): 
        </span><span class="s3">return </span><span class="s0">&quot;&lt;%s.%s object for encoding %s at %#x&gt;&quot; </span><span class="s2">% \ 
                (self.__class__.__module__</span><span class="s3">, </span><span class="s2">self.__class__.__qualname__</span><span class="s3">,</span><span class="s2"> 
                 self.name</span><span class="s3">, </span><span class="s2">id(self)) 
 
</span><span class="s3">class </span><span class="s2">Codec: 
 
    </span><span class="s5">&quot;&quot;&quot; Defines the interface for stateless encoders/decoders. 
 
        The .encode()/.decode() methods may use different error 
        handling schemes by providing the errors argument. These 
        string values are predefined: 
 
         'strict' - raise a ValueError error (or a subclass) 
         'ignore' - ignore the character and continue with the next 
         'replace' - replace with a suitable replacement character; 
                    Python will use the official U+FFFD REPLACEMENT 
                    CHARACTER for the builtin Unicode codecs on 
                    decoding and '?' on encoding. 
         'surrogateescape' - replace with private code points U+DCnn. 
         'xmlcharrefreplace' - Replace with the appropriate XML 
                               character reference (only for encoding). 
         'backslashreplace'  - Replace with backslashed escape sequences. 
         'namereplace'       - Replace with \\N{...} escape sequences 
                               (only for encoding). 
 
        The set of allowed values can be extended via register_error. 
 
    &quot;&quot;&quot;</span><span class="s2"> 
    </span><span class="s3">def </span><span class="s2">encode(self</span><span class="s3">, </span><span class="s2">input</span><span class="s3">, </span><span class="s2">errors=</span><span class="s0">'strict'</span><span class="s2">): 
 
        </span><span class="s5">&quot;&quot;&quot; Encodes the object input and returns a tuple (output 
            object, length consumed). 
 
            errors defines the error handling to apply. It defaults to 
            'strict' handling. 
 
            The method may not store state in the Codec instance. Use 
            StreamWriter for codecs which have to keep state in order to 
            make encoding efficient. 
 
            The encoder must be able to handle zero length input and 
            return an empty object of the output object type in this 
            situation. 
 
        &quot;&quot;&quot;</span><span class="s2"> 
        </span><span class="s3">raise </span><span class="s2">NotImplementedError 
 
    </span><span class="s3">def </span><span class="s2">decode(self</span><span class="s3">, </span><span class="s2">input</span><span class="s3">, </span><span class="s2">errors=</span><span class="s0">'strict'</span><span class="s2">): 
 
        </span><span class="s5">&quot;&quot;&quot; Decodes the object input and returns a tuple (output 
            object, length consumed). 
 
            input must be an object which provides the bf_getreadbuf 
            buffer slot. Python strings, buffer objects and memory 
            mapped files are examples of objects providing this slot. 
 
            errors defines the error handling to apply. It defaults to 
            'strict' handling. 
 
            The method may not store state in the Codec instance. Use 
            StreamReader for codecs which have to keep state in order to 
            make decoding efficient. 
 
            The decoder must be able to handle zero length input and 
            return an empty object of the output object type in this 
            situation. 
 
        &quot;&quot;&quot;</span><span class="s2"> 
        </span><span class="s3">raise </span><span class="s2">NotImplementedError 
 
</span><span class="s3">class </span><span class="s2">IncrementalEncoder(object): 
    </span><span class="s5">&quot;&quot;&quot; 
    An IncrementalEncoder encodes an input in multiple steps. The input can 
    be passed piece by piece to the encode() method. The IncrementalEncoder 
    remembers the state of the encoding process between calls to encode(). 
    &quot;&quot;&quot;</span><span class="s2"> 
    </span><span class="s3">def </span><span class="s2">__init__(self</span><span class="s3">, </span><span class="s2">errors=</span><span class="s0">'strict'</span><span class="s2">): 
        </span><span class="s5">&quot;&quot;&quot; 
        Creates an IncrementalEncoder instance. 
 
        The IncrementalEncoder may use different error handling schemes by 
        providing the errors keyword argument. See the module docstring 
        for a list of possible values. 
        &quot;&quot;&quot;</span><span class="s2"> 
        self.errors = errors 
        self.buffer = </span><span class="s0">&quot;&quot;</span><span class="s2"> 
 
    </span><span class="s3">def </span><span class="s2">encode(self</span><span class="s3">, </span><span class="s2">input</span><span class="s3">, </span><span class="s2">final=</span><span class="s3">False</span><span class="s2">): 
        </span><span class="s5">&quot;&quot;&quot; 
        Encodes input and returns the resulting object. 
        &quot;&quot;&quot;</span><span class="s2"> 
        </span><span class="s3">raise </span><span class="s2">NotImplementedError 
 
    </span><span class="s3">def </span><span class="s2">reset(self): 
        </span><span class="s5">&quot;&quot;&quot; 
        Resets the encoder to the initial state. 
        &quot;&quot;&quot;</span><span class="s2"> 
 
    </span><span class="s3">def </span><span class="s2">getstate(self): 
        </span><span class="s5">&quot;&quot;&quot; 
        Return the current state of the encoder. 
        &quot;&quot;&quot;</span><span class="s2"> 
        </span><span class="s3">return </span><span class="s6">0</span><span class="s2"> 
 
    </span><span class="s3">def </span><span class="s2">setstate(self</span><span class="s3">, </span><span class="s2">state): 
        </span><span class="s5">&quot;&quot;&quot; 
        Set the current state of the encoder. state must have been 
        returned by getstate(). 
        &quot;&quot;&quot;</span><span class="s2"> 
 
</span><span class="s3">class </span><span class="s2">BufferedIncrementalEncoder(IncrementalEncoder): 
    </span><span class="s5">&quot;&quot;&quot; 
    This subclass of IncrementalEncoder can be used as the baseclass for an 
    incremental encoder if the encoder must keep some of the output in a 
    buffer between calls to encode(). 
    &quot;&quot;&quot;</span><span class="s2"> 
    </span><span class="s3">def </span><span class="s2">__init__(self</span><span class="s3">, </span><span class="s2">errors=</span><span class="s0">'strict'</span><span class="s2">): 
        IncrementalEncoder.__init__(self</span><span class="s3">, </span><span class="s2">errors) 
        </span><span class="s1"># unencoded input that is kept between calls to encode()</span><span class="s2"> 
        self.buffer = </span><span class="s0">&quot;&quot;</span><span class="s2"> 
 
    </span><span class="s3">def </span><span class="s2">_buffer_encode(self</span><span class="s3">, </span><span class="s2">input</span><span class="s3">, </span><span class="s2">errors</span><span class="s3">, </span><span class="s2">final): 
        </span><span class="s1"># Overwrite this method in subclasses: It must encode input</span><span class="s2"> 
        </span><span class="s1"># and return an (output, length consumed) tuple</span><span class="s2"> 
        </span><span class="s3">raise </span><span class="s2">NotImplementedError 
 
    </span><span class="s3">def </span><span class="s2">encode(self</span><span class="s3">, </span><span class="s2">input</span><span class="s3">, </span><span class="s2">final=</span><span class="s3">False</span><span class="s2">): 
        </span><span class="s1"># encode input (taking the buffer into account)</span><span class="s2"> 
        data = self.buffer + input 
        (result</span><span class="s3">, </span><span class="s2">consumed) = self._buffer_encode(data</span><span class="s3">, </span><span class="s2">self.errors</span><span class="s3">, </span><span class="s2">final) 
        </span><span class="s1"># keep unencoded input until the next call</span><span class="s2"> 
        self.buffer = data[consumed:] 
        </span><span class="s3">return </span><span class="s2">result 
 
    </span><span class="s3">def </span><span class="s2">reset(self): 
        IncrementalEncoder.reset(self) 
        self.buffer = </span><span class="s0">&quot;&quot;</span><span class="s2"> 
 
    </span><span class="s3">def </span><span class="s2">getstate(self): 
        </span><span class="s3">return </span><span class="s2">self.buffer </span><span class="s3">or </span><span class="s6">0</span><span class="s2"> 
 
    </span><span class="s3">def </span><span class="s2">setstate(self</span><span class="s3">, </span><span class="s2">state): 
        self.buffer = state </span><span class="s3">or </span><span class="s0">&quot;&quot;</span><span class="s2"> 
 
</span><span class="s3">class </span><span class="s2">IncrementalDecoder(object): 
    </span><span class="s5">&quot;&quot;&quot; 
    An IncrementalDecoder decodes an input in multiple steps. The input can 
    be passed piece by piece to the decode() method. The IncrementalDecoder 
    remembers the state of the decoding process between calls to decode(). 
    &quot;&quot;&quot;</span><span class="s2"> 
    </span><span class="s3">def </span><span class="s2">__init__(self</span><span class="s3">, </span><span class="s2">errors=</span><span class="s0">'strict'</span><span class="s2">): 
        </span><span class="s5">&quot;&quot;&quot; 
        Create an IncrementalDecoder instance. 
 
        The IncrementalDecoder may use different error handling schemes by 
        providing the errors keyword argument. See the module docstring 
        for a list of possible values. 
        &quot;&quot;&quot;</span><span class="s2"> 
        self.errors = errors 
 
    </span><span class="s3">def </span><span class="s2">decode(self</span><span class="s3">, </span><span class="s2">input</span><span class="s3">, </span><span class="s2">final=</span><span class="s3">False</span><span class="s2">): 
        </span><span class="s5">&quot;&quot;&quot; 
        Decode input and returns the resulting object. 
        &quot;&quot;&quot;</span><span class="s2"> 
        </span><span class="s3">raise </span><span class="s2">NotImplementedError 
 
    </span><span class="s3">def </span><span class="s2">reset(self): 
        </span><span class="s5">&quot;&quot;&quot; 
        Reset the decoder to the initial state. 
        &quot;&quot;&quot;</span><span class="s2"> 
 
    </span><span class="s3">def </span><span class="s2">getstate(self): 
        </span><span class="s5">&quot;&quot;&quot; 
        Return the current state of the decoder. 
 
        This must be a (buffered_input, additional_state_info) tuple. 
        buffered_input must be a bytes object containing bytes that 
        were passed to decode() that have not yet been converted. 
        additional_state_info must be a non-negative integer 
        representing the state of the decoder WITHOUT yet having 
        processed the contents of buffered_input.  In the initial state 
        and after reset(), getstate() must return (b&quot;&quot;, 0). 
        &quot;&quot;&quot;</span><span class="s2"> 
        </span><span class="s3">return </span><span class="s2">(</span><span class="s4">b&quot;&quot;</span><span class="s3">, </span><span class="s6">0</span><span class="s2">) 
 
    </span><span class="s3">def </span><span class="s2">setstate(self</span><span class="s3">, </span><span class="s2">state): 
        </span><span class="s5">&quot;&quot;&quot; 
        Set the current state of the decoder. 
 
        state must have been returned by getstate().  The effect of 
        setstate((b&quot;&quot;, 0)) must be equivalent to reset(). 
        &quot;&quot;&quot;</span><span class="s2"> 
 
</span><span class="s3">class </span><span class="s2">BufferedIncrementalDecoder(IncrementalDecoder): 
    </span><span class="s5">&quot;&quot;&quot; 
    This subclass of IncrementalDecoder can be used as the baseclass for an 
    incremental decoder if the decoder must be able to handle incomplete 
    byte sequences. 
    &quot;&quot;&quot;</span><span class="s2"> 
    </span><span class="s3">def </span><span class="s2">__init__(self</span><span class="s3">, </span><span class="s2">errors=</span><span class="s0">'strict'</span><span class="s2">): 
        IncrementalDecoder.__init__(self</span><span class="s3">, </span><span class="s2">errors) 
        </span><span class="s1"># undecoded input that is kept between calls to decode()</span><span class="s2"> 
        self.buffer = </span><span class="s4">b&quot;&quot;</span><span class="s2"> 
 
    </span><span class="s3">def </span><span class="s2">_buffer_decode(self</span><span class="s3">, </span><span class="s2">input</span><span class="s3">, </span><span class="s2">errors</span><span class="s3">, </span><span class="s2">final): 
        </span><span class="s1"># Overwrite this method in subclasses: It must decode input</span><span class="s2"> 
        </span><span class="s1"># and return an (output, length consumed) tuple</span><span class="s2"> 
        </span><span class="s3">raise </span><span class="s2">NotImplementedError 
 
    </span><span class="s3">def </span><span class="s2">decode(self</span><span class="s3">, </span><span class="s2">input</span><span class="s3">, </span><span class="s2">final=</span><span class="s3">False</span><span class="s2">): 
        </span><span class="s1"># decode input (taking the buffer into account)</span><span class="s2"> 
        data = self.buffer + input 
        (result</span><span class="s3">, </span><span class="s2">consumed) = self._buffer_decode(data</span><span class="s3">, </span><span class="s2">self.errors</span><span class="s3">, </span><span class="s2">final) 
        </span><span class="s1"># keep undecoded input until the next call</span><span class="s2"> 
        self.buffer = data[consumed:] 
        </span><span class="s3">return </span><span class="s2">result 
 
    </span><span class="s3">def </span><span class="s2">reset(self): 
        IncrementalDecoder.reset(self) 
        self.buffer = </span><span class="s4">b&quot;&quot;</span><span class="s2"> 
 
    </span><span class="s3">def </span><span class="s2">getstate(self): 
        </span><span class="s1"># additional state info is always 0</span><span class="s2"> 
        </span><span class="s3">return </span><span class="s2">(self.buffer</span><span class="s3">, </span><span class="s6">0</span><span class="s2">) 
 
    </span><span class="s3">def </span><span class="s2">setstate(self</span><span class="s3">, </span><span class="s2">state): 
        </span><span class="s1"># ignore additional state info</span><span class="s2"> 
        self.buffer = state[</span><span class="s6">0</span><span class="s2">] 
 
</span><span class="s1">#</span><span class="s2"> 
</span><span class="s1"># The StreamWriter and StreamReader class provide generic working</span><span class="s2"> 
</span><span class="s1"># interfaces which can be used to implement new encoding submodules</span><span class="s2"> 
</span><span class="s1"># very easily. See encodings/utf_8.py for an example on how this is</span><span class="s2"> 
</span><span class="s1"># done.</span><span class="s2"> 
</span><span class="s1">#</span><span class="s2"> 
 
</span><span class="s3">class </span><span class="s2">StreamWriter(Codec): 
 
    </span><span class="s3">def </span><span class="s2">__init__(self</span><span class="s3">, </span><span class="s2">stream</span><span class="s3">, </span><span class="s2">errors=</span><span class="s0">'strict'</span><span class="s2">): 
 
        </span><span class="s5">&quot;&quot;&quot; Creates a StreamWriter instance. 
 
            stream must be a file-like object open for writing. 
 
            The StreamWriter may use different error handling 
            schemes by providing the errors keyword argument. These 
            parameters are predefined: 
 
             'strict' - raise a ValueError (or a subclass) 
             'ignore' - ignore the character and continue with the next 
             'replace'- replace with a suitable replacement character 
             'xmlcharrefreplace' - Replace with the appropriate XML 
                                   character reference. 
             'backslashreplace'  - Replace with backslashed escape 
                                   sequences. 
             'namereplace'       - Replace with \\N{...} escape sequences. 
 
            The set of allowed parameter values can be extended via 
            register_error. 
        &quot;&quot;&quot;</span><span class="s2"> 
        self.stream = stream 
        self.errors = errors 
 
    </span><span class="s3">def </span><span class="s2">write(self</span><span class="s3">, </span><span class="s2">object): 
 
        </span><span class="s5">&quot;&quot;&quot; Writes the object's contents encoded to self.stream. 
        &quot;&quot;&quot;</span><span class="s2"> 
        data</span><span class="s3">, </span><span class="s2">consumed = self.encode(object</span><span class="s3">, </span><span class="s2">self.errors) 
        self.stream.write(data) 
 
    </span><span class="s3">def </span><span class="s2">writelines(self</span><span class="s3">, </span><span class="s2">list): 
 
        </span><span class="s5">&quot;&quot;&quot; Writes the concatenated list of strings to the stream 
            using .write(). 
        &quot;&quot;&quot;</span><span class="s2"> 
        self.write(</span><span class="s0">''</span><span class="s2">.join(list)) 
 
    </span><span class="s3">def </span><span class="s2">reset(self): 
 
        </span><span class="s5">&quot;&quot;&quot; Flushes and resets the codec buffers used for keeping state. 
 
            Calling this method should ensure that the data on the 
            output is put into a clean state, that allows appending 
            of new fresh data without having to rescan the whole 
            stream to recover state. 
 
        &quot;&quot;&quot;</span><span class="s2"> 
        </span><span class="s3">pass</span><span class="s2"> 
 
    </span><span class="s3">def </span><span class="s2">seek(self</span><span class="s3">, </span><span class="s2">offset</span><span class="s3">, </span><span class="s2">whence=</span><span class="s6">0</span><span class="s2">): 
        self.stream.seek(offset</span><span class="s3">, </span><span class="s2">whence) 
        </span><span class="s3">if </span><span class="s2">whence == </span><span class="s6">0 </span><span class="s3">and </span><span class="s2">offset == </span><span class="s6">0</span><span class="s2">: 
            self.reset() 
 
    </span><span class="s3">def </span><span class="s2">__getattr__(self</span><span class="s3">, </span><span class="s2">name</span><span class="s3">,</span><span class="s2"> 
                    getattr=getattr): 
 
        </span><span class="s5">&quot;&quot;&quot; Inherit all other methods from the underlying stream. 
        &quot;&quot;&quot;</span><span class="s2"> 
        </span><span class="s3">return </span><span class="s2">getattr(self.stream</span><span class="s3">, </span><span class="s2">name) 
 
    </span><span class="s3">def </span><span class="s2">__enter__(self): 
        </span><span class="s3">return </span><span class="s2">self 
 
    </span><span class="s3">def </span><span class="s2">__exit__(self</span><span class="s3">, </span><span class="s2">type</span><span class="s3">, </span><span class="s2">value</span><span class="s3">, </span><span class="s2">tb): 
        self.stream.close() 
 
</span><span class="s1">###</span><span class="s2"> 
 
</span><span class="s3">class </span><span class="s2">StreamReader(Codec): 
 
    charbuffertype = str 
 
    </span><span class="s3">def </span><span class="s2">__init__(self</span><span class="s3">, </span><span class="s2">stream</span><span class="s3">, </span><span class="s2">errors=</span><span class="s0">'strict'</span><span class="s2">): 
 
        </span><span class="s5">&quot;&quot;&quot; Creates a StreamReader instance. 
 
            stream must be a file-like object open for reading. 
 
            The StreamReader may use different error handling 
            schemes by providing the errors keyword argument. These 
            parameters are predefined: 
 
             'strict' - raise a ValueError (or a subclass) 
             'ignore' - ignore the character and continue with the next 
             'replace'- replace with a suitable replacement character 
             'backslashreplace' - Replace with backslashed escape sequences; 
 
            The set of allowed parameter values can be extended via 
            register_error. 
        &quot;&quot;&quot;</span><span class="s2"> 
        self.stream = stream 
        self.errors = errors 
        self.bytebuffer = </span><span class="s4">b&quot;&quot;</span><span class="s2"> 
        self._empty_charbuffer = self.charbuffertype() 
        self.charbuffer = self._empty_charbuffer 
        self.linebuffer = </span><span class="s3">None</span><span class="s2"> 
 
    </span><span class="s3">def </span><span class="s2">decode(self</span><span class="s3">, </span><span class="s2">input</span><span class="s3">, </span><span class="s2">errors=</span><span class="s0">'strict'</span><span class="s2">): 
        </span><span class="s3">raise </span><span class="s2">NotImplementedError 
 
    </span><span class="s3">def </span><span class="s2">read(self</span><span class="s3">, </span><span class="s2">size=-</span><span class="s6">1</span><span class="s3">, </span><span class="s2">chars=-</span><span class="s6">1</span><span class="s3">, </span><span class="s2">firstline=</span><span class="s3">False</span><span class="s2">): 
 
        </span><span class="s5">&quot;&quot;&quot; Decodes data from the stream self.stream and returns the 
            resulting object. 
 
            chars indicates the number of decoded code points or bytes to 
            return. read() will never return more data than requested, 
            but it might return less, if there is not enough available. 
 
            size indicates the approximate maximum number of decoded 
            bytes or code points to read for decoding. The decoder 
            can modify this setting as appropriate. The default value 
            -1 indicates to read and decode as much as possible.  size 
            is intended to prevent having to decode huge files in one 
            step. 
 
            If firstline is true, and a UnicodeDecodeError happens 
            after the first line terminator in the input only the first line 
            will be returned, the rest of the input will be kept until the 
            next call to read(). 
 
            The method should use a greedy read strategy, meaning that 
            it should read as much data as is allowed within the 
            definition of the encoding and the given size, e.g.  if 
            optional encoding endings or state markers are available 
            on the stream, these should be read too. 
        &quot;&quot;&quot;</span><span class="s2"> 
        </span><span class="s1"># If we have lines cached, first merge them back into characters</span><span class="s2"> 
        </span><span class="s3">if </span><span class="s2">self.linebuffer: 
            self.charbuffer = self._empty_charbuffer.join(self.linebuffer) 
            self.linebuffer = </span><span class="s3">None</span><span class="s2"> 
 
        </span><span class="s1"># read until we get the required number of characters (if available)</span><span class="s2"> 
        </span><span class="s3">while True</span><span class="s2">: 
            </span><span class="s1"># can the request be satisfied from the character buffer?</span><span class="s2"> 
            </span><span class="s3">if </span><span class="s2">chars &gt;= </span><span class="s6">0</span><span class="s2">: 
                </span><span class="s3">if </span><span class="s2">len(self.charbuffer) &gt;= chars: 
                    </span><span class="s3">break</span><span class="s2"> 
            </span><span class="s3">elif </span><span class="s2">size &gt;= </span><span class="s6">0</span><span class="s2">: 
                </span><span class="s3">if </span><span class="s2">len(self.charbuffer) &gt;= size: 
                    </span><span class="s3">break</span><span class="s2"> 
            </span><span class="s1"># we need more data</span><span class="s2"> 
            </span><span class="s3">if </span><span class="s2">size &lt; </span><span class="s6">0</span><span class="s2">: 
                newdata = self.stream.read() 
            </span><span class="s3">else</span><span class="s2">: 
                newdata = self.stream.read(size) 
            </span><span class="s1"># decode bytes (those remaining from the last call included)</span><span class="s2"> 
            data = self.bytebuffer + newdata 
            </span><span class="s3">if not </span><span class="s2">data: 
                </span><span class="s3">break</span><span class="s2"> 
            </span><span class="s3">try</span><span class="s2">: 
                newchars</span><span class="s3">, </span><span class="s2">decodedbytes = self.decode(data</span><span class="s3">, </span><span class="s2">self.errors) 
            </span><span class="s3">except </span><span class="s2">UnicodeDecodeError </span><span class="s3">as </span><span class="s2">exc: 
                </span><span class="s3">if </span><span class="s2">firstline: 
                    newchars</span><span class="s3">, </span><span class="s2">decodedbytes = \ 
                        self.decode(data[:exc.start]</span><span class="s3">, </span><span class="s2">self.errors) 
                    lines = newchars.splitlines(keepends=</span><span class="s3">True</span><span class="s2">) 
                    </span><span class="s3">if </span><span class="s2">len(lines)&lt;=</span><span class="s6">1</span><span class="s2">: 
                        </span><span class="s3">raise</span><span class="s2"> 
                </span><span class="s3">else</span><span class="s2">: 
                    </span><span class="s3">raise</span><span class="s2"> 
            </span><span class="s1"># keep undecoded bytes until the next call</span><span class="s2"> 
            self.bytebuffer = data[decodedbytes:] 
            </span><span class="s1"># put new characters in the character buffer</span><span class="s2"> 
            self.charbuffer += newchars 
            </span><span class="s1"># there was no data available</span><span class="s2"> 
            </span><span class="s3">if not </span><span class="s2">newdata: 
                </span><span class="s3">break</span><span class="s2"> 
        </span><span class="s3">if </span><span class="s2">chars &lt; </span><span class="s6">0</span><span class="s2">: 
            </span><span class="s1"># Return everything we've got</span><span class="s2"> 
            result = self.charbuffer 
            self.charbuffer = self._empty_charbuffer 
        </span><span class="s3">else</span><span class="s2">: 
            </span><span class="s1"># Return the first chars characters</span><span class="s2"> 
            result = self.charbuffer[:chars] 
            self.charbuffer = self.charbuffer[chars:] 
        </span><span class="s3">return </span><span class="s2">result 
 
    </span><span class="s3">def </span><span class="s2">readline(self</span><span class="s3">, </span><span class="s2">size=</span><span class="s3">None, </span><span class="s2">keepends=</span><span class="s3">True</span><span class="s2">): 
 
        </span><span class="s5">&quot;&quot;&quot; Read one line from the input stream and return the 
            decoded data. 
 
            size, if given, is passed as size argument to the 
            read() method. 
 
        &quot;&quot;&quot;</span><span class="s2"> 
        </span><span class="s1"># If we have lines cached from an earlier read, return</span><span class="s2"> 
        </span><span class="s1"># them unconditionally</span><span class="s2"> 
        </span><span class="s3">if </span><span class="s2">self.linebuffer: 
            line = self.linebuffer[</span><span class="s6">0</span><span class="s2">] 
            </span><span class="s3">del </span><span class="s2">self.linebuffer[</span><span class="s6">0</span><span class="s2">] 
            </span><span class="s3">if </span><span class="s2">len(self.linebuffer) == </span><span class="s6">1</span><span class="s2">: 
                </span><span class="s1"># revert to charbuffer mode; we might need more data</span><span class="s2"> 
                </span><span class="s1"># next time</span><span class="s2"> 
                self.charbuffer = self.linebuffer[</span><span class="s6">0</span><span class="s2">] 
                self.linebuffer = </span><span class="s3">None</span><span class="s2"> 
            </span><span class="s3">if not </span><span class="s2">keepends: 
                line = line.splitlines(keepends=</span><span class="s3">False</span><span class="s2">)[</span><span class="s6">0</span><span class="s2">] 
            </span><span class="s3">return </span><span class="s2">line 
 
        readsize = size </span><span class="s3">or </span><span class="s6">72</span><span class="s2"> 
        line = self._empty_charbuffer 
        </span><span class="s1"># If size is given, we call read() only once</span><span class="s2"> 
        </span><span class="s3">while True</span><span class="s2">: 
            data = self.read(readsize</span><span class="s3">, </span><span class="s2">firstline=</span><span class="s3">True</span><span class="s2">) 
            </span><span class="s3">if </span><span class="s2">data: 
                </span><span class="s1"># If we're at a &quot;\r&quot; read one extra character (which might</span><span class="s2"> 
                </span><span class="s1"># be a &quot;\n&quot;) to get a proper line ending. If the stream is</span><span class="s2"> 
                </span><span class="s1"># temporarily exhausted we return the wrong line ending.</span><span class="s2"> 
                </span><span class="s3">if </span><span class="s2">(isinstance(data</span><span class="s3">, </span><span class="s2">str) </span><span class="s3">and </span><span class="s2">data.endswith(</span><span class="s0">&quot;</span><span class="s3">\r</span><span class="s0">&quot;</span><span class="s2">)) </span><span class="s3">or </span><span class="s2">\ 
                   (isinstance(data</span><span class="s3">, </span><span class="s2">bytes) </span><span class="s3">and </span><span class="s2">data.endswith(</span><span class="s4">b&quot;</span><span class="s3">\r</span><span class="s4">&quot;</span><span class="s2">)): 
                    data += self.read(size=</span><span class="s6">1</span><span class="s3">, </span><span class="s2">chars=</span><span class="s6">1</span><span class="s2">) 
 
            line += data 
            lines = line.splitlines(keepends=</span><span class="s3">True</span><span class="s2">) 
            </span><span class="s3">if </span><span class="s2">lines: 
                </span><span class="s3">if </span><span class="s2">len(lines) &gt; </span><span class="s6">1</span><span class="s2">: 
                    </span><span class="s1"># More than one line result; the first line is a full line</span><span class="s2"> 
                    </span><span class="s1"># to return</span><span class="s2"> 
                    line = lines[</span><span class="s6">0</span><span class="s2">] 
                    </span><span class="s3">del </span><span class="s2">lines[</span><span class="s6">0</span><span class="s2">] 
                    </span><span class="s3">if </span><span class="s2">len(lines) &gt; </span><span class="s6">1</span><span class="s2">: 
                        </span><span class="s1"># cache the remaining lines</span><span class="s2"> 
                        lines[-</span><span class="s6">1</span><span class="s2">] += self.charbuffer 
                        self.linebuffer = lines 
                        self.charbuffer = </span><span class="s3">None</span><span class="s2"> 
                    </span><span class="s3">else</span><span class="s2">: 
                        </span><span class="s1"># only one remaining line, put it back into charbuffer</span><span class="s2"> 
                        self.charbuffer = lines[</span><span class="s6">0</span><span class="s2">] + self.charbuffer 
                    </span><span class="s3">if not </span><span class="s2">keepends: 
                        line = line.splitlines(keepends=</span><span class="s3">False</span><span class="s2">)[</span><span class="s6">0</span><span class="s2">] 
                    </span><span class="s3">break</span><span class="s2"> 
                line0withend = lines[</span><span class="s6">0</span><span class="s2">] 
                line0withoutend = lines[</span><span class="s6">0</span><span class="s2">].splitlines(keepends=</span><span class="s3">False</span><span class="s2">)[</span><span class="s6">0</span><span class="s2">] 
                </span><span class="s3">if </span><span class="s2">line0withend != line0withoutend: </span><span class="s1"># We really have a line end</span><span class="s2"> 
                    </span><span class="s1"># Put the rest back together and keep it until the next call</span><span class="s2"> 
                    self.charbuffer = self._empty_charbuffer.join(lines[</span><span class="s6">1</span><span class="s2">:]) + \ 
                                      self.charbuffer 
                    </span><span class="s3">if </span><span class="s2">keepends: 
                        line = line0withend 
                    </span><span class="s3">else</span><span class="s2">: 
                        line = line0withoutend 
                    </span><span class="s3">break</span><span class="s2"> 
            </span><span class="s1"># we didn't get anything or this was our only try</span><span class="s2"> 
            </span><span class="s3">if not </span><span class="s2">data </span><span class="s3">or </span><span class="s2">size </span><span class="s3">is not None</span><span class="s2">: 
                </span><span class="s3">if </span><span class="s2">line </span><span class="s3">and not </span><span class="s2">keepends: 
                    line = line.splitlines(keepends=</span><span class="s3">False</span><span class="s2">)[</span><span class="s6">0</span><span class="s2">] 
                </span><span class="s3">break</span><span class="s2"> 
            </span><span class="s3">if </span><span class="s2">readsize &lt; </span><span class="s6">8000</span><span class="s2">: 
                readsize *= </span><span class="s6">2</span><span class="s2"> 
        </span><span class="s3">return </span><span class="s2">line 
 
    </span><span class="s3">def </span><span class="s2">readlines(self</span><span class="s3">, </span><span class="s2">sizehint=</span><span class="s3">None, </span><span class="s2">keepends=</span><span class="s3">True</span><span class="s2">): 
 
        </span><span class="s5">&quot;&quot;&quot; Read all lines available on the input stream 
            and return them as a list. 
 
            Line breaks are implemented using the codec's decoder 
            method and are included in the list entries. 
 
            sizehint, if given, is ignored since there is no efficient 
            way to finding the true end-of-line. 
 
        &quot;&quot;&quot;</span><span class="s2"> 
        data = self.read() 
        </span><span class="s3">return </span><span class="s2">data.splitlines(keepends) 
 
    </span><span class="s3">def </span><span class="s2">reset(self): 
 
        </span><span class="s5">&quot;&quot;&quot; Resets the codec buffers used for keeping state. 
 
            Note that no stream repositioning should take place. 
            This method is primarily intended to be able to recover 
            from decoding errors. 
 
        &quot;&quot;&quot;</span><span class="s2"> 
        self.bytebuffer = </span><span class="s4">b&quot;&quot;</span><span class="s2"> 
        self.charbuffer = self._empty_charbuffer 
        self.linebuffer = </span><span class="s3">None</span><span class="s2"> 
 
    </span><span class="s3">def </span><span class="s2">seek(self</span><span class="s3">, </span><span class="s2">offset</span><span class="s3">, </span><span class="s2">whence=</span><span class="s6">0</span><span class="s2">): 
        </span><span class="s5">&quot;&quot;&quot; Set the input stream's current position. 
 
            Resets the codec buffers used for keeping state. 
        &quot;&quot;&quot;</span><span class="s2"> 
        self.stream.seek(offset</span><span class="s3">, </span><span class="s2">whence) 
        self.reset() 
 
    </span><span class="s3">def </span><span class="s2">__next__(self): 
 
        </span><span class="s5">&quot;&quot;&quot; Return the next decoded line from the input stream.&quot;&quot;&quot;</span><span class="s2"> 
        line = self.readline() 
        </span><span class="s3">if </span><span class="s2">line: 
            </span><span class="s3">return </span><span class="s2">line 
        </span><span class="s3">raise </span><span class="s2">StopIteration 
 
    </span><span class="s3">def </span><span class="s2">__iter__(self): 
        </span><span class="s3">return </span><span class="s2">self 
 
    </span><span class="s3">def </span><span class="s2">__getattr__(self</span><span class="s3">, </span><span class="s2">name</span><span class="s3">,</span><span class="s2"> 
                    getattr=getattr): 
 
        </span><span class="s5">&quot;&quot;&quot; Inherit all other methods from the underlying stream. 
        &quot;&quot;&quot;</span><span class="s2"> 
        </span><span class="s3">return </span><span class="s2">getattr(self.stream</span><span class="s3">, </span><span class="s2">name) 
 
    </span><span class="s3">def </span><span class="s2">__enter__(self): 
        </span><span class="s3">return </span><span class="s2">self 
 
    </span><span class="s3">def </span><span class="s2">__exit__(self</span><span class="s3">, </span><span class="s2">type</span><span class="s3">, </span><span class="s2">value</span><span class="s3">, </span><span class="s2">tb): 
        self.stream.close() 
 
</span><span class="s1">###</span><span class="s2"> 
 
</span><span class="s3">class </span><span class="s2">StreamReaderWriter: 
 
    </span><span class="s5">&quot;&quot;&quot; StreamReaderWriter instances allow wrapping streams which 
        work in both read and write modes. 
 
        The design is such that one can use the factory functions 
        returned by the codec.lookup() function to construct the 
        instance. 
 
    &quot;&quot;&quot;</span><span class="s2"> 
    </span><span class="s1"># Optional attributes set by the file wrappers below</span><span class="s2"> 
    encoding = </span><span class="s0">'unknown'</span><span class="s2"> 
 
    </span><span class="s3">def </span><span class="s2">__init__(self</span><span class="s3">, </span><span class="s2">stream</span><span class="s3">, </span><span class="s2">Reader</span><span class="s3">, </span><span class="s2">Writer</span><span class="s3">, </span><span class="s2">errors=</span><span class="s0">'strict'</span><span class="s2">): 
 
        </span><span class="s5">&quot;&quot;&quot; Creates a StreamReaderWriter instance. 
 
            stream must be a Stream-like object. 
 
            Reader, Writer must be factory functions or classes 
            providing the StreamReader, StreamWriter interface resp. 
 
            Error handling is done in the same way as defined for the 
            StreamWriter/Readers. 
 
        &quot;&quot;&quot;</span><span class="s2"> 
        self.stream = stream 
        self.reader = Reader(stream</span><span class="s3">, </span><span class="s2">errors) 
        self.writer = Writer(stream</span><span class="s3">, </span><span class="s2">errors) 
        self.errors = errors 
 
    </span><span class="s3">def </span><span class="s2">read(self</span><span class="s3">, </span><span class="s2">size=-</span><span class="s6">1</span><span class="s2">): 
 
        </span><span class="s3">return </span><span class="s2">self.reader.read(size) 
 
    </span><span class="s3">def </span><span class="s2">readline(self</span><span class="s3">, </span><span class="s2">size=</span><span class="s3">None</span><span class="s2">): 
 
        </span><span class="s3">return </span><span class="s2">self.reader.readline(size) 
 
    </span><span class="s3">def </span><span class="s2">readlines(self</span><span class="s3">, </span><span class="s2">sizehint=</span><span class="s3">None</span><span class="s2">): 
 
        </span><span class="s3">return </span><span class="s2">self.reader.readlines(sizehint) 
 
    </span><span class="s3">def </span><span class="s2">__next__(self): 
 
        </span><span class="s5">&quot;&quot;&quot; Return the next decoded line from the input stream.&quot;&quot;&quot;</span><span class="s2"> 
        </span><span class="s3">return </span><span class="s2">next(self.reader) 
 
    </span><span class="s3">def </span><span class="s2">__iter__(self): 
        </span><span class="s3">return </span><span class="s2">self 
 
    </span><span class="s3">def </span><span class="s2">write(self</span><span class="s3">, </span><span class="s2">data): 
 
        </span><span class="s3">return </span><span class="s2">self.writer.write(data) 
 
    </span><span class="s3">def </span><span class="s2">writelines(self</span><span class="s3">, </span><span class="s2">list): 
 
        </span><span class="s3">return </span><span class="s2">self.writer.writelines(list) 
 
    </span><span class="s3">def </span><span class="s2">reset(self): 
 
        self.reader.reset() 
        self.writer.reset() 
 
    </span><span class="s3">def </span><span class="s2">seek(self</span><span class="s3">, </span><span class="s2">offset</span><span class="s3">, </span><span class="s2">whence=</span><span class="s6">0</span><span class="s2">): 
        self.stream.seek(offset</span><span class="s3">, </span><span class="s2">whence) 
        self.reader.reset() 
        </span><span class="s3">if </span><span class="s2">whence == </span><span class="s6">0 </span><span class="s3">and </span><span class="s2">offset == </span><span class="s6">0</span><span class="s2">: 
            self.writer.reset() 
 
    </span><span class="s3">def </span><span class="s2">__getattr__(self</span><span class="s3">, </span><span class="s2">name</span><span class="s3">,</span><span class="s2"> 
                    getattr=getattr): 
 
        </span><span class="s5">&quot;&quot;&quot; Inherit all other methods from the underlying stream. 
        &quot;&quot;&quot;</span><span class="s2"> 
        </span><span class="s3">return </span><span class="s2">getattr(self.stream</span><span class="s3">, </span><span class="s2">name) 
 
    </span><span class="s1"># these are needed to make &quot;with codecs.open(...)&quot; work properly</span><span class="s2"> 
 
    </span><span class="s3">def </span><span class="s2">__enter__(self): 
        </span><span class="s3">return </span><span class="s2">self 
 
    </span><span class="s3">def </span><span class="s2">__exit__(self</span><span class="s3">, </span><span class="s2">type</span><span class="s3">, </span><span class="s2">value</span><span class="s3">, </span><span class="s2">tb): 
        self.stream.close() 
 
</span><span class="s1">###</span><span class="s2"> 
 
</span><span class="s3">class </span><span class="s2">StreamRecoder: 
 
    </span><span class="s5">&quot;&quot;&quot; StreamRecoder instances translate data from one encoding to another. 
 
        They use the complete set of APIs returned by the 
        codecs.lookup() function to implement their task. 
 
        Data written to the StreamRecoder is first decoded into an 
        intermediate format (depending on the &quot;decode&quot; codec) and then 
        written to the underlying stream using an instance of the provided 
        Writer class. 
 
        In the other direction, data is read from the underlying stream using 
        a Reader instance and then encoded and returned to the caller. 
 
    &quot;&quot;&quot;</span><span class="s2"> 
    </span><span class="s1"># Optional attributes set by the file wrappers below</span><span class="s2"> 
    data_encoding = </span><span class="s0">'unknown'</span><span class="s2"> 
    file_encoding = </span><span class="s0">'unknown'</span><span class="s2"> 
 
    </span><span class="s3">def </span><span class="s2">__init__(self</span><span class="s3">, </span><span class="s2">stream</span><span class="s3">, </span><span class="s2">encode</span><span class="s3">, </span><span class="s2">decode</span><span class="s3">, </span><span class="s2">Reader</span><span class="s3">, </span><span class="s2">Writer</span><span class="s3">,</span><span class="s2"> 
                 errors=</span><span class="s0">'strict'</span><span class="s2">): 
 
        </span><span class="s5">&quot;&quot;&quot; Creates a StreamRecoder instance which implements a two-way 
            conversion: encode and decode work on the frontend (the 
            data visible to .read() and .write()) while Reader and Writer 
            work on the backend (the data in stream). 
 
            You can use these objects to do transparent 
            transcodings from e.g. latin-1 to utf-8 and back. 
 
            stream must be a file-like object. 
 
            encode and decode must adhere to the Codec interface; Reader and 
            Writer must be factory functions or classes providing the 
            StreamReader and StreamWriter interfaces resp. 
 
            Error handling is done in the same way as defined for the 
            StreamWriter/Readers. 
 
        &quot;&quot;&quot;</span><span class="s2"> 
        self.stream = stream 
        self.encode = encode 
        self.decode = decode 
        self.reader = Reader(stream</span><span class="s3">, </span><span class="s2">errors) 
        self.writer = Writer(stream</span><span class="s3">, </span><span class="s2">errors) 
        self.errors = errors 
 
    </span><span class="s3">def </span><span class="s2">read(self</span><span class="s3">, </span><span class="s2">size=-</span><span class="s6">1</span><span class="s2">): 
 
        data = self.reader.read(size) 
        data</span><span class="s3">, </span><span class="s2">bytesencoded = self.encode(data</span><span class="s3">, </span><span class="s2">self.errors) 
        </span><span class="s3">return </span><span class="s2">data 
 
    </span><span class="s3">def </span><span class="s2">readline(self</span><span class="s3">, </span><span class="s2">size=</span><span class="s3">None</span><span class="s2">): 
 
        </span><span class="s3">if </span><span class="s2">size </span><span class="s3">is None</span><span class="s2">: 
            data = self.reader.readline() 
        </span><span class="s3">else</span><span class="s2">: 
            data = self.reader.readline(size) 
        data</span><span class="s3">, </span><span class="s2">bytesencoded = self.encode(data</span><span class="s3">, </span><span class="s2">self.errors) 
        </span><span class="s3">return </span><span class="s2">data 
 
    </span><span class="s3">def </span><span class="s2">readlines(self</span><span class="s3">, </span><span class="s2">sizehint=</span><span class="s3">None</span><span class="s2">): 
 
        data = self.reader.read() 
        data</span><span class="s3">, </span><span class="s2">bytesencoded = self.encode(data</span><span class="s3">, </span><span class="s2">self.errors) 
        </span><span class="s3">return </span><span class="s2">data.splitlines(keepends=</span><span class="s3">True</span><span class="s2">) 
 
    </span><span class="s3">def </span><span class="s2">__next__(self): 
 
        </span><span class="s5">&quot;&quot;&quot; Return the next decoded line from the input stream.&quot;&quot;&quot;</span><span class="s2"> 
        data = next(self.reader) 
        data</span><span class="s3">, </span><span class="s2">bytesencoded = self.encode(data</span><span class="s3">, </span><span class="s2">self.errors) 
        </span><span class="s3">return </span><span class="s2">data 
 
    </span><span class="s3">def </span><span class="s2">__iter__(self): 
        </span><span class="s3">return </span><span class="s2">self 
 
    </span><span class="s3">def </span><span class="s2">write(self</span><span class="s3">, </span><span class="s2">data): 
 
        data</span><span class="s3">, </span><span class="s2">bytesdecoded = self.decode(data</span><span class="s3">, </span><span class="s2">self.errors) 
        </span><span class="s3">return </span><span class="s2">self.writer.write(data) 
 
    </span><span class="s3">def </span><span class="s2">writelines(self</span><span class="s3">, </span><span class="s2">list): 
 
        data = </span><span class="s0">''</span><span class="s2">.join(list) 
        data</span><span class="s3">, </span><span class="s2">bytesdecoded = self.decode(data</span><span class="s3">, </span><span class="s2">self.errors) 
        </span><span class="s3">return </span><span class="s2">self.writer.write(data) 
 
    </span><span class="s3">def </span><span class="s2">reset(self): 
 
        self.reader.reset() 
        self.writer.reset() 
 
    </span><span class="s3">def </span><span class="s2">__getattr__(self</span><span class="s3">, </span><span class="s2">name</span><span class="s3">,</span><span class="s2"> 
                    getattr=getattr): 
 
        </span><span class="s5">&quot;&quot;&quot; Inherit all other methods from the underlying stream. 
        &quot;&quot;&quot;</span><span class="s2"> 
        </span><span class="s3">return </span><span class="s2">getattr(self.stream</span><span class="s3">, </span><span class="s2">name) 
 
    </span><span class="s3">def </span><span class="s2">__enter__(self): 
        </span><span class="s3">return </span><span class="s2">self 
 
    </span><span class="s3">def </span><span class="s2">__exit__(self</span><span class="s3">, </span><span class="s2">type</span><span class="s3">, </span><span class="s2">value</span><span class="s3">, </span><span class="s2">tb): 
        self.stream.close() 
 
</span><span class="s1">### Shortcuts</span><span class="s2"> 
 
</span><span class="s3">def </span><span class="s2">open(filename</span><span class="s3">, </span><span class="s2">mode=</span><span class="s0">'r'</span><span class="s3">, </span><span class="s2">encoding=</span><span class="s3">None, </span><span class="s2">errors=</span><span class="s0">'strict'</span><span class="s3">, </span><span class="s2">buffering=</span><span class="s6">1</span><span class="s2">): 
 
    </span><span class="s5">&quot;&quot;&quot; Open an encoded file using the given mode and return 
        a wrapped version providing transparent encoding/decoding. 
 
        Note: The wrapped version will only accept the object format 
        defined by the codecs, i.e. Unicode objects for most builtin 
        codecs. Output is also codec dependent and will usually be 
        Unicode as well. 
 
        Underlying encoded files are always opened in binary mode. 
        The default file mode is 'r', meaning to open the file in read mode. 
 
        encoding specifies the encoding which is to be used for the 
        file. 
 
        errors may be given to define the error handling. It defaults 
        to 'strict' which causes ValueErrors to be raised in case an 
        encoding error occurs. 
 
        buffering has the same meaning as for the builtin open() API. 
        It defaults to line buffered. 
 
        The returned wrapped file object provides an extra attribute 
        .encoding which allows querying the used encoding. This 
        attribute is only available if an encoding was specified as 
        parameter. 
 
    &quot;&quot;&quot;</span><span class="s2"> 
    </span><span class="s3">if </span><span class="s2">encoding </span><span class="s3">is not None and </span><span class="s2">\ 
       </span><span class="s0">'b' </span><span class="s3">not in </span><span class="s2">mode: 
        </span><span class="s1"># Force opening of the file in binary mode</span><span class="s2"> 
        mode = mode + </span><span class="s0">'b'</span><span class="s2"> 
    file = builtins.open(filename</span><span class="s3">, </span><span class="s2">mode</span><span class="s3">, </span><span class="s2">buffering) 
    </span><span class="s3">if </span><span class="s2">encoding </span><span class="s3">is None</span><span class="s2">: 
        </span><span class="s3">return </span><span class="s2">file 
    info = lookup(encoding) 
    srw = StreamReaderWriter(file</span><span class="s3">, </span><span class="s2">info.streamreader</span><span class="s3">, </span><span class="s2">info.streamwriter</span><span class="s3">, </span><span class="s2">errors) 
    </span><span class="s1"># Add attributes to simplify introspection</span><span class="s2"> 
    srw.encoding = encoding 
    </span><span class="s3">return </span><span class="s2">srw 
 
</span><span class="s3">def </span><span class="s2">EncodedFile(file</span><span class="s3">, </span><span class="s2">data_encoding</span><span class="s3">, </span><span class="s2">file_encoding=</span><span class="s3">None, </span><span class="s2">errors=</span><span class="s0">'strict'</span><span class="s2">): 
 
    </span><span class="s5">&quot;&quot;&quot; Return a wrapped version of file which provides transparent 
        encoding translation. 
 
        Data written to the wrapped file is decoded according 
        to the given data_encoding and then encoded to the underlying 
        file using file_encoding. The intermediate data type 
        will usually be Unicode but depends on the specified codecs. 
 
        Bytes read from the file are decoded using file_encoding and then 
        passed back to the caller encoded using data_encoding. 
 
        If file_encoding is not given, it defaults to data_encoding. 
 
        errors may be given to define the error handling. It defaults 
        to 'strict' which causes ValueErrors to be raised in case an 
        encoding error occurs. 
 
        The returned wrapped file object provides two extra attributes 
        .data_encoding and .file_encoding which reflect the given 
        parameters of the same name. The attributes can be used for 
        introspection by Python programs. 
 
    &quot;&quot;&quot;</span><span class="s2"> 
    </span><span class="s3">if </span><span class="s2">file_encoding </span><span class="s3">is None</span><span class="s2">: 
        file_encoding = data_encoding 
    data_info = lookup(data_encoding) 
    file_info = lookup(file_encoding) 
    sr = StreamRecoder(file</span><span class="s3">, </span><span class="s2">data_info.encode</span><span class="s3">, </span><span class="s2">data_info.decode</span><span class="s3">,</span><span class="s2"> 
                       file_info.streamreader</span><span class="s3">, </span><span class="s2">file_info.streamwriter</span><span class="s3">, </span><span class="s2">errors) 
    </span><span class="s1"># Add attributes to simplify introspection</span><span class="s2"> 
    sr.data_encoding = data_encoding 
    sr.file_encoding = file_encoding 
    </span><span class="s3">return </span><span class="s2">sr 
 
</span><span class="s1">### Helpers for codec lookup</span><span class="s2"> 
 
</span><span class="s3">def </span><span class="s2">getencoder(encoding): 
 
    </span><span class="s5">&quot;&quot;&quot; Lookup up the codec for the given encoding and return 
        its encoder function. 
 
        Raises a LookupError in case the encoding cannot be found. 
 
    &quot;&quot;&quot;</span><span class="s2"> 
    </span><span class="s3">return </span><span class="s2">lookup(encoding).encode 
 
</span><span class="s3">def </span><span class="s2">getdecoder(encoding): 
 
    </span><span class="s5">&quot;&quot;&quot; Lookup up the codec for the given encoding and return 
        its decoder function. 
 
        Raises a LookupError in case the encoding cannot be found. 
 
    &quot;&quot;&quot;</span><span class="s2"> 
    </span><span class="s3">return </span><span class="s2">lookup(encoding).decode 
 
</span><span class="s3">def </span><span class="s2">getincrementalencoder(encoding): 
 
    </span><span class="s5">&quot;&quot;&quot; Lookup up the codec for the given encoding and return 
        its IncrementalEncoder class or factory function. 
 
        Raises a LookupError in case the encoding cannot be found 
        or the codecs doesn't provide an incremental encoder. 
 
    &quot;&quot;&quot;</span><span class="s2"> 
    encoder = lookup(encoding).incrementalencoder 
    </span><span class="s3">if </span><span class="s2">encoder </span><span class="s3">is None</span><span class="s2">: 
        </span><span class="s3">raise </span><span class="s2">LookupError(encoding) 
    </span><span class="s3">return </span><span class="s2">encoder 
 
</span><span class="s3">def </span><span class="s2">getincrementaldecoder(encoding): 
 
    </span><span class="s5">&quot;&quot;&quot; Lookup up the codec for the given encoding and return 
        its IncrementalDecoder class or factory function. 
 
        Raises a LookupError in case the encoding cannot be found 
        or the codecs doesn't provide an incremental decoder. 
 
    &quot;&quot;&quot;</span><span class="s2"> 
    decoder = lookup(encoding).incrementaldecoder 
    </span><span class="s3">if </span><span class="s2">decoder </span><span class="s3">is None</span><span class="s2">: 
        </span><span class="s3">raise </span><span class="s2">LookupError(encoding) 
    </span><span class="s3">return </span><span class="s2">decoder 
 
</span><span class="s3">def </span><span class="s2">getreader(encoding): 
 
    </span><span class="s5">&quot;&quot;&quot; Lookup up the codec for the given encoding and return 
        its StreamReader class or factory function. 
 
        Raises a LookupError in case the encoding cannot be found. 
 
    &quot;&quot;&quot;</span><span class="s2"> 
    </span><span class="s3">return </span><span class="s2">lookup(encoding).streamreader 
 
</span><span class="s3">def </span><span class="s2">getwriter(encoding): 
 
    </span><span class="s5">&quot;&quot;&quot; Lookup up the codec for the given encoding and return 
        its StreamWriter class or factory function. 
 
        Raises a LookupError in case the encoding cannot be found. 
 
    &quot;&quot;&quot;</span><span class="s2"> 
    </span><span class="s3">return </span><span class="s2">lookup(encoding).streamwriter 
 
</span><span class="s3">def </span><span class="s2">iterencode(iterator</span><span class="s3">, </span><span class="s2">encoding</span><span class="s3">, </span><span class="s2">errors=</span><span class="s0">'strict'</span><span class="s3">, </span><span class="s2">**kwargs): 
    </span><span class="s5">&quot;&quot;&quot; 
    Encoding iterator. 
 
    Encodes the input strings from the iterator using an IncrementalEncoder. 
 
    errors and kwargs are passed through to the IncrementalEncoder 
    constructor. 
    &quot;&quot;&quot;</span><span class="s2"> 
    encoder = getincrementalencoder(encoding)(errors</span><span class="s3">, </span><span class="s2">**kwargs) 
    </span><span class="s3">for </span><span class="s2">input </span><span class="s3">in </span><span class="s2">iterator: 
        output = encoder.encode(input) 
        </span><span class="s3">if </span><span class="s2">output: 
            </span><span class="s3">yield </span><span class="s2">output 
    output = encoder.encode(</span><span class="s0">&quot;&quot;</span><span class="s3">, True</span><span class="s2">) 
    </span><span class="s3">if </span><span class="s2">output: 
        </span><span class="s3">yield </span><span class="s2">output 
 
</span><span class="s3">def </span><span class="s2">iterdecode(iterator</span><span class="s3">, </span><span class="s2">encoding</span><span class="s3">, </span><span class="s2">errors=</span><span class="s0">'strict'</span><span class="s3">, </span><span class="s2">**kwargs): 
    </span><span class="s5">&quot;&quot;&quot; 
    Decoding iterator. 
 
    Decodes the input strings from the iterator using an IncrementalDecoder. 
 
    errors and kwargs are passed through to the IncrementalDecoder 
    constructor. 
    &quot;&quot;&quot;</span><span class="s2"> 
    decoder = getincrementaldecoder(encoding)(errors</span><span class="s3">, </span><span class="s2">**kwargs) 
    </span><span class="s3">for </span><span class="s2">input </span><span class="s3">in </span><span class="s2">iterator: 
        output = decoder.decode(input) 
        </span><span class="s3">if </span><span class="s2">output: 
            </span><span class="s3">yield </span><span class="s2">output 
    output = decoder.decode(</span><span class="s4">b&quot;&quot;</span><span class="s3">, True</span><span class="s2">) 
    </span><span class="s3">if </span><span class="s2">output: 
        </span><span class="s3">yield </span><span class="s2">output 
 
</span><span class="s1">### Helpers for charmap-based codecs</span><span class="s2"> 
 
</span><span class="s3">def </span><span class="s2">make_identity_dict(rng): 
 
    </span><span class="s5">&quot;&quot;&quot; make_identity_dict(rng) -&gt; dict 
 
        Return a dictionary where elements of the rng sequence are 
        mapped to themselves. 
 
    &quot;&quot;&quot;</span><span class="s2"> 
    </span><span class="s3">return </span><span class="s2">{i:i </span><span class="s3">for </span><span class="s2">i </span><span class="s3">in </span><span class="s2">rng} 
 
</span><span class="s3">def </span><span class="s2">make_encoding_map(decoding_map): 
 
    </span><span class="s5">&quot;&quot;&quot; Creates an encoding map from a decoding map. 
 
        If a target mapping in the decoding map occurs multiple 
        times, then that target is mapped to None (undefined mapping), 
        causing an exception when encountered by the charmap codec 
        during translation. 
 
        One example where this happens is cp875.py which decodes 
        multiple character to \\u001a. 
 
    &quot;&quot;&quot;</span><span class="s2"> 
    m = {} 
    </span><span class="s3">for </span><span class="s2">k</span><span class="s3">,</span><span class="s2">v </span><span class="s3">in </span><span class="s2">decoding_map.items(): 
        </span><span class="s3">if not </span><span class="s2">v </span><span class="s3">in </span><span class="s2">m: 
            m[v] = k 
        </span><span class="s3">else</span><span class="s2">: 
            m[v] = </span><span class="s3">None</span><span class="s2"> 
    </span><span class="s3">return </span><span class="s2">m 
 
</span><span class="s1">### error handlers</span><span class="s2"> 
 
</span><span class="s3">try</span><span class="s2">: 
    strict_errors = lookup_error(</span><span class="s0">&quot;strict&quot;</span><span class="s2">) 
    ignore_errors = lookup_error(</span><span class="s0">&quot;ignore&quot;</span><span class="s2">) 
    replace_errors = lookup_error(</span><span class="s0">&quot;replace&quot;</span><span class="s2">) 
    xmlcharrefreplace_errors = lookup_error(</span><span class="s0">&quot;xmlcharrefreplace&quot;</span><span class="s2">) 
    backslashreplace_errors = lookup_error(</span><span class="s0">&quot;backslashreplace&quot;</span><span class="s2">) 
    namereplace_errors = lookup_error(</span><span class="s0">&quot;namereplace&quot;</span><span class="s2">) 
</span><span class="s3">except </span><span class="s2">LookupError: 
    </span><span class="s1"># In --disable-unicode builds, these error handler are missing</span><span class="s2"> 
    strict_errors = </span><span class="s3">None</span><span class="s2"> 
    ignore_errors = </span><span class="s3">None</span><span class="s2"> 
    replace_errors = </span><span class="s3">None</span><span class="s2"> 
    xmlcharrefreplace_errors = </span><span class="s3">None</span><span class="s2"> 
    backslashreplace_errors = </span><span class="s3">None</span><span class="s2"> 
    namereplace_errors = </span><span class="s3">None</span><span class="s2"> 
 
</span><span class="s1"># Tell modulefinder that using codecs probably needs the encodings</span><span class="s2"> 
</span><span class="s1"># package</span><span class="s2"> 
_false = </span><span class="s6">0</span><span class="s2"> 
</span><span class="s3">if </span><span class="s2">_false: 
    </span><span class="s3">import </span><span class="s2">encodings 
 
</span><span class="s1">### Tests</span><span class="s2"> 
 
</span><span class="s3">if </span><span class="s2">__name__ == </span><span class="s0">'__main__'</span><span class="s2">: 
 
    </span><span class="s1"># Make stdout translate Latin-1 output into UTF-8 output</span><span class="s2"> 
    sys.stdout = EncodedFile(sys.stdout</span><span class="s3">, </span><span class="s0">'latin-1'</span><span class="s3">, </span><span class="s0">'utf-8'</span><span class="s2">) 
 
    </span><span class="s1"># Have stdin translate Latin-1 input into UTF-8 input</span><span class="s2"> 
    sys.stdin = EncodedFile(sys.stdin</span><span class="s3">, </span><span class="s0">'utf-8'</span><span class="s3">, </span><span class="s0">'latin-1'</span><span class="s2">) 
</span></pre>
</body>
</html>