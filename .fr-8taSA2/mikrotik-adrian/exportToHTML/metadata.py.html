<html>
<head>
<title>metadata.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.ln { color: #606366; font-weight: normal; font-style: normal; }
.s0 { color: rgb(98,151,85); font-style: italic; }
.s1 { color: rgb(169,183,198); }
.s2 { color: rgb(204,120,50); }
.s3 { color: rgb(106,135,89); }
.s4 { color: rgb(128,128,128); }
.s5 { color: rgb(104,151,187); }
</style>
</head>
<BODY BGCOLOR="#2b2b2b">
<TABLE CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<TR><TD><CENTER>
<FONT FACE="Arial, Helvetica" COLOR="#000000">
metadata.py</FONT>
</center></TD></TR></TABLE>
<pre>
<span class="s0">&quot;&quot;&quot; 
Tools for converting old- to new-style metadata. 
&quot;&quot;&quot;</span><span class="s1"> 
 
</span><span class="s2">import </span><span class="s1">email.parser 
</span><span class="s2">import </span><span class="s1">os.path 
</span><span class="s2">import </span><span class="s1">re 
</span><span class="s2">import </span><span class="s1">textwrap 
</span><span class="s2">from </span><span class="s1">collections </span><span class="s2">import </span><span class="s1">namedtuple</span><span class="s2">, </span><span class="s1">OrderedDict 
 
</span><span class="s2">import </span><span class="s1">pkg_resources 
 
</span><span class="s2">from </span><span class="s1">. </span><span class="s2">import </span><span class="s1">__version__ </span><span class="s2">as </span><span class="s1">wheel_version 
</span><span class="s2">from </span><span class="s1">.pkginfo </span><span class="s2">import </span><span class="s1">read_pkg_info 
</span><span class="s2">from </span><span class="s1">.util </span><span class="s2">import </span><span class="s1">OrderedDefaultDict 
 
METADATA_VERSION = </span><span class="s3">&quot;2.0&quot;</span><span class="s1"> 
 
PLURAL_FIELDS = {</span><span class="s3">&quot;classifier&quot;</span><span class="s1">: </span><span class="s3">&quot;classifiers&quot;</span><span class="s2">,</span><span class="s1"> 
                 </span><span class="s3">&quot;provides_dist&quot;</span><span class="s1">: </span><span class="s3">&quot;provides&quot;</span><span class="s2">,</span><span class="s1"> 
                 </span><span class="s3">&quot;provides_extra&quot;</span><span class="s1">: </span><span class="s3">&quot;extras&quot;</span><span class="s1">} 
 
SKIP_FIELDS = set() 
 
CONTACT_FIELDS = (({</span><span class="s3">&quot;email&quot;</span><span class="s1">: </span><span class="s3">&quot;author_email&quot;</span><span class="s2">, </span><span class="s3">&quot;name&quot;</span><span class="s1">: </span><span class="s3">&quot;author&quot;</span><span class="s1">}</span><span class="s2">,</span><span class="s1"> 
                   </span><span class="s3">&quot;author&quot;</span><span class="s1">)</span><span class="s2">,</span><span class="s1"> 
                  ({</span><span class="s3">&quot;email&quot;</span><span class="s1">: </span><span class="s3">&quot;maintainer_email&quot;</span><span class="s2">, </span><span class="s3">&quot;name&quot;</span><span class="s1">: </span><span class="s3">&quot;maintainer&quot;</span><span class="s1">}</span><span class="s2">,</span><span class="s1"> 
                   </span><span class="s3">&quot;maintainer&quot;</span><span class="s1">)) 
 
</span><span class="s4"># commonly filled out as &quot;UNKNOWN&quot; by distutils:</span><span class="s1"> 
UNKNOWN_FIELDS = {</span><span class="s3">&quot;author&quot;</span><span class="s2">, </span><span class="s3">&quot;author_email&quot;</span><span class="s2">, </span><span class="s3">&quot;platform&quot;</span><span class="s2">, </span><span class="s3">&quot;home_page&quot;</span><span class="s2">, </span><span class="s3">&quot;license&quot;</span><span class="s1">} 
 
</span><span class="s4"># Wheel itself is probably the only program that uses non-extras markers</span><span class="s1"> 
</span><span class="s4"># in METADATA/PKG-INFO. Support its syntax with the extra at the end only.</span><span class="s1"> 
EXTRA_RE = re.compile(</span><span class="s3">&quot;&quot;&quot;^(?P&lt;package&gt;.*?)(;\s*(?P&lt;condition&gt;.*?)(extra == '(?P&lt;extra&gt;.*?)')?)$&quot;&quot;&quot;</span><span class="s1">) 
KEYWORDS_RE = re.compile(</span><span class="s3">&quot;[</span><span class="s2">\0</span><span class="s3">-,]+&quot;</span><span class="s1">) 
 
MayRequiresKey = namedtuple(</span><span class="s3">'MayRequiresKey'</span><span class="s2">, </span><span class="s1">(</span><span class="s3">'condition'</span><span class="s2">, </span><span class="s3">'extra'</span><span class="s1">)) 
 
 
</span><span class="s2">def </span><span class="s1">unique(iterable): 
    </span><span class="s0">&quot;&quot;&quot; 
    Yield unique values in iterable, preserving order. 
    &quot;&quot;&quot;</span><span class="s1"> 
    seen = set() 
    </span><span class="s2">for </span><span class="s1">value </span><span class="s2">in </span><span class="s1">iterable: 
        </span><span class="s2">if </span><span class="s1">value </span><span class="s2">not in </span><span class="s1">seen: 
            seen.add(value) 
            </span><span class="s2">yield </span><span class="s1">value 
 
 
</span><span class="s2">def </span><span class="s1">handle_requires(metadata</span><span class="s2">, </span><span class="s1">pkg_info</span><span class="s2">, </span><span class="s1">key): 
    </span><span class="s0">&quot;&quot;&quot; 
    Place the runtime requirements from pkg_info into metadata. 
    &quot;&quot;&quot;</span><span class="s1"> 
    may_requires = OrderedDefaultDict(list) 
    </span><span class="s2">for </span><span class="s1">value </span><span class="s2">in </span><span class="s1">sorted(pkg_info.get_all(key)): 
        extra_match = EXTRA_RE.search(value) 
        </span><span class="s2">if </span><span class="s1">extra_match: 
            groupdict = extra_match.groupdict() 
            condition = groupdict[</span><span class="s3">'condition'</span><span class="s1">] 
            extra = groupdict[</span><span class="s3">'extra'</span><span class="s1">] 
            package = groupdict[</span><span class="s3">'package'</span><span class="s1">] 
            </span><span class="s2">if </span><span class="s1">condition.endswith(</span><span class="s3">' and '</span><span class="s1">): 
                condition = condition[:-</span><span class="s5">5</span><span class="s1">] 
        </span><span class="s2">else</span><span class="s1">: 
            condition</span><span class="s2">, </span><span class="s1">extra = </span><span class="s2">None, None</span><span class="s1"> 
            package = value 
        key = MayRequiresKey(condition</span><span class="s2">, </span><span class="s1">extra) 
        may_requires[key].append(package) 
 
    </span><span class="s2">if </span><span class="s1">may_requires: 
        metadata[</span><span class="s3">'run_requires'</span><span class="s1">] = [] 
 
        </span><span class="s2">def </span><span class="s1">sort_key(item): 
            </span><span class="s4"># Both condition and extra could be None, which can't be compared</span><span class="s1"> 
            </span><span class="s4"># against strings in Python 3.</span><span class="s1"> 
            key</span><span class="s2">, </span><span class="s1">value = item 
            </span><span class="s2">if </span><span class="s1">key.condition </span><span class="s2">is None</span><span class="s1">: 
                </span><span class="s2">return </span><span class="s3">''</span><span class="s1"> 
            </span><span class="s2">return </span><span class="s1">key.condition 
 
        </span><span class="s2">for </span><span class="s1">key</span><span class="s2">, </span><span class="s1">value </span><span class="s2">in </span><span class="s1">sorted(may_requires.items()</span><span class="s2">, </span><span class="s1">key=sort_key): 
            may_requirement = OrderedDict(((</span><span class="s3">'requires'</span><span class="s2">, </span><span class="s1">value)</span><span class="s2">,</span><span class="s1">)) 
            </span><span class="s2">if </span><span class="s1">key.extra: 
                may_requirement[</span><span class="s3">'extra'</span><span class="s1">] = key.extra 
            </span><span class="s2">if </span><span class="s1">key.condition: 
                may_requirement[</span><span class="s3">'environment'</span><span class="s1">] = key.condition 
            metadata[</span><span class="s3">'run_requires'</span><span class="s1">].append(may_requirement) 
 
        </span><span class="s2">if </span><span class="s3">'extras' </span><span class="s2">not in </span><span class="s1">metadata: 
            metadata[</span><span class="s3">'extras'</span><span class="s1">] = [] 
        metadata[</span><span class="s3">'extras'</span><span class="s1">].extend([key.extra </span><span class="s2">for </span><span class="s1">key </span><span class="s2">in </span><span class="s1">may_requires.keys() </span><span class="s2">if </span><span class="s1">key.extra]) 
 
 
</span><span class="s2">def </span><span class="s1">pkginfo_to_dict(path</span><span class="s2">, </span><span class="s1">distribution=</span><span class="s2">None</span><span class="s1">): 
    </span><span class="s0">&quot;&quot;&quot; 
    Convert PKG-INFO to a prototype Metadata 2.0 (PEP 426) dict. 
 
    The description is included under the key ['description'] rather than 
    being written to a separate file. 
 
    path: path to PKG-INFO file 
    distribution: optional distutils Distribution() 
    &quot;&quot;&quot;</span><span class="s1"> 
 
    metadata = OrderedDefaultDict( 
        </span><span class="s2">lambda</span><span class="s1">: OrderedDefaultDict(</span><span class="s2">lambda</span><span class="s1">: OrderedDefaultDict(OrderedDict))) 
    metadata[</span><span class="s3">&quot;generator&quot;</span><span class="s1">] = </span><span class="s3">&quot;bdist_wheel (&quot; </span><span class="s1">+ wheel_version + </span><span class="s3">&quot;)&quot;</span><span class="s1"> 
    </span><span class="s2">try</span><span class="s1">: 
        unicode 
        pkg_info = read_pkg_info(path) 
    </span><span class="s2">except </span><span class="s1">NameError: 
        </span><span class="s2">with </span><span class="s1">open(path</span><span class="s2">, </span><span class="s3">'rb'</span><span class="s1">) </span><span class="s2">as </span><span class="s1">pkg_info_file: 
            pkg_info = email.parser.Parser().parsestr(pkg_info_file.read().decode(</span><span class="s3">'utf-8'</span><span class="s1">)) 
    description = </span><span class="s2">None</span><span class="s1"> 
 
    </span><span class="s2">if </span><span class="s1">pkg_info[</span><span class="s3">'Summary'</span><span class="s1">]: 
        metadata[</span><span class="s3">'summary'</span><span class="s1">] = pkginfo_unicode(pkg_info</span><span class="s2">, </span><span class="s3">'Summary'</span><span class="s1">) 
        </span><span class="s2">del </span><span class="s1">pkg_info[</span><span class="s3">'Summary'</span><span class="s1">] 
 
    </span><span class="s2">if </span><span class="s1">pkg_info[</span><span class="s3">'Description'</span><span class="s1">]: 
        description = dedent_description(pkg_info) 
        </span><span class="s2">del </span><span class="s1">pkg_info[</span><span class="s3">'Description'</span><span class="s1">] 
    </span><span class="s2">else</span><span class="s1">: 
        payload = pkg_info.get_payload() 
        </span><span class="s2">if </span><span class="s1">isinstance(payload</span><span class="s2">, </span><span class="s1">bytes): 
            </span><span class="s4"># Avoid a Python 2 Unicode error.</span><span class="s1"> 
            </span><span class="s4"># We still suffer ? glyphs on Python 3.</span><span class="s1"> 
            payload = payload.decode(</span><span class="s3">'utf-8'</span><span class="s1">) 
        </span><span class="s2">if </span><span class="s1">payload: 
            description = payload 
 
    </span><span class="s2">if </span><span class="s1">description: 
        pkg_info[</span><span class="s3">'description'</span><span class="s1">] = description 
 
    </span><span class="s2">for </span><span class="s1">key </span><span class="s2">in </span><span class="s1">sorted(unique(k.lower() </span><span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">pkg_info.keys())): 
        low_key = key.replace(</span><span class="s3">'-'</span><span class="s2">, </span><span class="s3">'_'</span><span class="s1">) 
 
        </span><span class="s2">if </span><span class="s1">low_key </span><span class="s2">in </span><span class="s1">SKIP_FIELDS: 
            </span><span class="s2">continue</span><span class="s1"> 
 
        </span><span class="s2">if </span><span class="s1">low_key </span><span class="s2">in </span><span class="s1">UNKNOWN_FIELDS </span><span class="s2">and </span><span class="s1">pkg_info.get(key) == </span><span class="s3">'UNKNOWN'</span><span class="s1">: 
            </span><span class="s2">continue</span><span class="s1"> 
 
        </span><span class="s2">if </span><span class="s1">low_key </span><span class="s2">in </span><span class="s1">sorted(PLURAL_FIELDS): 
            metadata[PLURAL_FIELDS[low_key]] = pkg_info.get_all(key) 
 
        </span><span class="s2">elif </span><span class="s1">low_key == </span><span class="s3">&quot;requires_dist&quot;</span><span class="s1">: 
            handle_requires(metadata</span><span class="s2">, </span><span class="s1">pkg_info</span><span class="s2">, </span><span class="s1">key) 
 
        </span><span class="s2">elif </span><span class="s1">low_key == </span><span class="s3">'provides_extra'</span><span class="s1">: 
            </span><span class="s2">if </span><span class="s3">'extras' </span><span class="s2">not in </span><span class="s1">metadata: 
                metadata[</span><span class="s3">'extras'</span><span class="s1">] = [] 
            metadata[</span><span class="s3">'extras'</span><span class="s1">].extend(pkg_info.get_all(key)) 
 
        </span><span class="s2">elif </span><span class="s1">low_key == </span><span class="s3">'home_page'</span><span class="s1">: 
            metadata[</span><span class="s3">'extensions'</span><span class="s1">][</span><span class="s3">'python.details'</span><span class="s1">][</span><span class="s3">'project_urls'</span><span class="s1">] = {</span><span class="s3">'Home'</span><span class="s1">: pkg_info[key]} 
 
        </span><span class="s2">elif </span><span class="s1">low_key == </span><span class="s3">'keywords'</span><span class="s1">: 
            metadata[</span><span class="s3">'keywords'</span><span class="s1">] = KEYWORDS_RE.split(pkg_info[key]) 
 
        </span><span class="s2">else</span><span class="s1">: 
            metadata[low_key] = pkg_info[key] 
 
    metadata[</span><span class="s3">'metadata_version'</span><span class="s1">] = METADATA_VERSION 
 
    </span><span class="s2">if </span><span class="s3">'extras' </span><span class="s2">in </span><span class="s1">metadata: 
        metadata[</span><span class="s3">'extras'</span><span class="s1">] = sorted(set(metadata[</span><span class="s3">'extras'</span><span class="s1">])) 
 
    </span><span class="s4"># include more information if distribution is available</span><span class="s1"> 
    </span><span class="s2">if </span><span class="s1">distribution: 
        </span><span class="s2">for </span><span class="s1">requires</span><span class="s2">, </span><span class="s1">attr </span><span class="s2">in </span><span class="s1">((</span><span class="s3">'test_requires'</span><span class="s2">, </span><span class="s3">'tests_require'</span><span class="s1">)</span><span class="s2">,</span><span class="s1">): 
            </span><span class="s2">try</span><span class="s1">: 
                requirements = getattr(distribution</span><span class="s2">, </span><span class="s1">attr) 
                </span><span class="s2">if </span><span class="s1">isinstance(requirements</span><span class="s2">, </span><span class="s1">list): 
                    new_requirements = sorted(convert_requirements(requirements)) 
                    metadata[requires] = [{</span><span class="s3">'requires'</span><span class="s1">: new_requirements}] 
            </span><span class="s2">except </span><span class="s1">AttributeError: 
                </span><span class="s2">pass</span><span class="s1"> 
 
    </span><span class="s4"># handle contacts</span><span class="s1"> 
    contacts = [] 
    </span><span class="s2">for </span><span class="s1">contact_type</span><span class="s2">, </span><span class="s1">role </span><span class="s2">in </span><span class="s1">CONTACT_FIELDS: 
        contact = OrderedDict() 
        </span><span class="s2">for </span><span class="s1">key </span><span class="s2">in </span><span class="s1">sorted(contact_type): 
            </span><span class="s2">if </span><span class="s1">contact_type[key] </span><span class="s2">in </span><span class="s1">metadata: 
                contact[key] = metadata.pop(contact_type[key]) 
        </span><span class="s2">if </span><span class="s1">contact: 
            contact[</span><span class="s3">'role'</span><span class="s1">] = role 
            contacts.append(contact) 
    </span><span class="s2">if </span><span class="s1">contacts: 
        metadata[</span><span class="s3">'extensions'</span><span class="s1">][</span><span class="s3">'python.details'</span><span class="s1">][</span><span class="s3">'contacts'</span><span class="s1">] = contacts 
 
    </span><span class="s4"># convert entry points to exports</span><span class="s1"> 
    </span><span class="s2">try</span><span class="s1">: 
        </span><span class="s2">with </span><span class="s1">open(os.path.join(os.path.dirname(path)</span><span class="s2">, </span><span class="s3">&quot;entry_points.txt&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s3">&quot;r&quot;</span><span class="s1">) </span><span class="s2">as </span><span class="s1">ep_file: 
            ep_map = pkg_resources.EntryPoint.parse_map(ep_file.read()) 
        exports = OrderedDict() 
        </span><span class="s2">for </span><span class="s1">group</span><span class="s2">, </span><span class="s1">items </span><span class="s2">in </span><span class="s1">sorted(ep_map.items()): 
            exports[group] = OrderedDict() 
            </span><span class="s2">for </span><span class="s1">item </span><span class="s2">in </span><span class="s1">sorted(map(str</span><span class="s2">, </span><span class="s1">items.values())): 
                name</span><span class="s2">, </span><span class="s1">export = item.split(</span><span class="s3">' = '</span><span class="s2">, </span><span class="s5">1</span><span class="s1">) 
                exports[group][name] = export 
        </span><span class="s2">if </span><span class="s1">exports: 
            metadata[</span><span class="s3">'extensions'</span><span class="s1">][</span><span class="s3">'python.exports'</span><span class="s1">] = exports 
    </span><span class="s2">except </span><span class="s1">IOError: 
        </span><span class="s2">pass</span><span class="s1"> 
 
    </span><span class="s4"># copy console_scripts entry points to commands</span><span class="s1"> 
    </span><span class="s2">if </span><span class="s3">'python.exports' </span><span class="s2">in </span><span class="s1">metadata[</span><span class="s3">'extensions'</span><span class="s1">]: 
        </span><span class="s2">for </span><span class="s1">(ep_script</span><span class="s2">, </span><span class="s1">wrap_script) </span><span class="s2">in </span><span class="s1">((</span><span class="s3">'console_scripts'</span><span class="s2">, </span><span class="s3">'wrap_console'</span><span class="s1">)</span><span class="s2">,</span><span class="s1"> 
                                         (</span><span class="s3">'gui_scripts'</span><span class="s2">, </span><span class="s3">'wrap_gui'</span><span class="s1">)): 
            </span><span class="s2">if </span><span class="s1">ep_script </span><span class="s2">in </span><span class="s1">metadata[</span><span class="s3">'extensions'</span><span class="s1">][</span><span class="s3">'python.exports'</span><span class="s1">]: 
                metadata[</span><span class="s3">'extensions'</span><span class="s1">][</span><span class="s3">'python.commands'</span><span class="s1">][wrap_script] = \ 
                    metadata[</span><span class="s3">'extensions'</span><span class="s1">][</span><span class="s3">'python.exports'</span><span class="s1">][ep_script] 
 
    </span><span class="s2">return </span><span class="s1">metadata 
 
 
</span><span class="s2">def </span><span class="s1">requires_to_requires_dist(requirement): 
    </span><span class="s0">&quot;&quot;&quot;Compose the version predicates for requirement in PEP 345 fashion.&quot;&quot;&quot;</span><span class="s1"> 
    requires_dist = [] 
    </span><span class="s2">for </span><span class="s1">op</span><span class="s2">, </span><span class="s1">ver </span><span class="s2">in </span><span class="s1">requirement.specs: 
        requires_dist.append(op + ver) 
    </span><span class="s2">if not </span><span class="s1">requires_dist: 
        </span><span class="s2">return </span><span class="s3">''</span><span class="s1"> 
    </span><span class="s2">return </span><span class="s3">&quot; (%s)&quot; </span><span class="s1">% </span><span class="s3">','</span><span class="s1">.join(sorted(requires_dist)) 
 
 
</span><span class="s2">def </span><span class="s1">convert_requirements(requirements): 
    </span><span class="s0">&quot;&quot;&quot;Yield Requires-Dist: strings for parsed requirements strings.&quot;&quot;&quot;</span><span class="s1"> 
    </span><span class="s2">for </span><span class="s1">req </span><span class="s2">in </span><span class="s1">requirements: 
        parsed_requirement = pkg_resources.Requirement.parse(req) 
        spec = requires_to_requires_dist(parsed_requirement) 
        extras = </span><span class="s3">&quot;,&quot;</span><span class="s1">.join(parsed_requirement.extras) 
        </span><span class="s2">if </span><span class="s1">extras: 
            extras = </span><span class="s3">&quot;[%s]&quot; </span><span class="s1">% extras 
        </span><span class="s2">yield </span><span class="s1">(parsed_requirement.project_name + extras + spec) 
 
 
</span><span class="s2">def </span><span class="s1">generate_requirements(extras_require): 
    </span><span class="s0">&quot;&quot;&quot; 
    Convert requirements from a setup()-style dictionary to ('Requires-Dist', 'requirement') 
    and ('Provides-Extra', 'extra') tuples. 
 
    extras_require is a dictionary of {extra: [requirements]} as passed to setup(), 
    using the empty extra {'': [requirements]} to hold install_requires. 
    &quot;&quot;&quot;</span><span class="s1"> 
    </span><span class="s2">for </span><span class="s1">extra</span><span class="s2">, </span><span class="s1">depends </span><span class="s2">in </span><span class="s1">extras_require.items(): 
        condition = </span><span class="s3">''</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">extra </span><span class="s2">and </span><span class="s3">':' </span><span class="s2">in </span><span class="s1">extra:  </span><span class="s4"># setuptools extra:condition syntax</span><span class="s1"> 
            extra</span><span class="s2">, </span><span class="s1">condition = extra.split(</span><span class="s3">':'</span><span class="s2">, </span><span class="s5">1</span><span class="s1">) 
            extra = pkg_resources.safe_extra(extra) 
        </span><span class="s2">if </span><span class="s1">extra: 
            </span><span class="s2">yield </span><span class="s1">(</span><span class="s3">'Provides-Extra'</span><span class="s2">, </span><span class="s1">extra) 
            </span><span class="s2">if </span><span class="s1">condition: 
                condition += </span><span class="s3">&quot; and &quot;</span><span class="s1"> 
            condition += </span><span class="s3">&quot;extra == '%s'&quot; </span><span class="s1">% extra 
        </span><span class="s2">if </span><span class="s1">condition: 
            condition = </span><span class="s3">'; ' </span><span class="s1">+ condition 
        </span><span class="s2">for </span><span class="s1">new_req </span><span class="s2">in </span><span class="s1">convert_requirements(depends): 
            </span><span class="s2">yield </span><span class="s1">(</span><span class="s3">'Requires-Dist'</span><span class="s2">, </span><span class="s1">new_req + condition) 
 
 
</span><span class="s2">def </span><span class="s1">pkginfo_to_metadata(egg_info_path</span><span class="s2">, </span><span class="s1">pkginfo_path): 
    </span><span class="s0">&quot;&quot;&quot; 
    Convert .egg-info directory with PKG-INFO to the Metadata 1.3 aka 
    old-draft Metadata 2.0 format. 
    &quot;&quot;&quot;</span><span class="s1"> 
    pkg_info = read_pkg_info(pkginfo_path) 
    pkg_info.replace_header(</span><span class="s3">'Metadata-Version'</span><span class="s2">, </span><span class="s3">'2.0'</span><span class="s1">) 
    requires_path = os.path.join(egg_info_path</span><span class="s2">, </span><span class="s3">'requires.txt'</span><span class="s1">) 
    </span><span class="s2">if </span><span class="s1">os.path.exists(requires_path): 
        </span><span class="s2">with </span><span class="s1">open(requires_path) </span><span class="s2">as </span><span class="s1">requires_file: 
            requires = requires_file.read() 
        </span><span class="s2">for </span><span class="s1">extra</span><span class="s2">, </span><span class="s1">reqs </span><span class="s2">in </span><span class="s1">sorted(pkg_resources.split_sections(requires)</span><span class="s2">,</span><span class="s1"> 
                                  key=</span><span class="s2">lambda </span><span class="s1">x: x[</span><span class="s5">0</span><span class="s1">] </span><span class="s2">or </span><span class="s3">''</span><span class="s1">): 
            </span><span class="s2">for </span><span class="s1">item </span><span class="s2">in </span><span class="s1">generate_requirements({extra: reqs}): 
                pkg_info[item[</span><span class="s5">0</span><span class="s1">]] = item[</span><span class="s5">1</span><span class="s1">] 
 
    description = pkg_info[</span><span class="s3">'Description'</span><span class="s1">] 
    </span><span class="s2">if </span><span class="s1">description: 
        pkg_info.set_payload(dedent_description(pkg_info)) 
        </span><span class="s2">del </span><span class="s1">pkg_info[</span><span class="s3">'Description'</span><span class="s1">] 
 
    </span><span class="s2">return </span><span class="s1">pkg_info 
 
 
</span><span class="s2">def </span><span class="s1">pkginfo_unicode(pkg_info</span><span class="s2">, </span><span class="s1">field): 
    </span><span class="s0">&quot;&quot;&quot;Hack to coax Unicode out of an email Message() - Python 3.3+&quot;&quot;&quot;</span><span class="s1"> 
    text = pkg_info[field] 
    field = field.lower() 
    </span><span class="s2">if not </span><span class="s1">isinstance(text</span><span class="s2">, </span><span class="s1">str): 
        </span><span class="s2">if not </span><span class="s1">hasattr(pkg_info</span><span class="s2">, </span><span class="s3">'raw_items'</span><span class="s1">):  </span><span class="s4"># Python 3.2</span><span class="s1"> 
            </span><span class="s2">return </span><span class="s1">str(text) 
        </span><span class="s2">for </span><span class="s1">item </span><span class="s2">in </span><span class="s1">pkg_info.raw_items(): 
            </span><span class="s2">if </span><span class="s1">item[</span><span class="s5">0</span><span class="s1">].lower() == field: 
                text = item[</span><span class="s5">1</span><span class="s1">].encode(</span><span class="s3">'ascii'</span><span class="s2">, </span><span class="s3">'surrogateescape'</span><span class="s1">) \ 
                    .decode(</span><span class="s3">'utf-8'</span><span class="s1">) 
                </span><span class="s2">break</span><span class="s1"> 
 
    </span><span class="s2">return </span><span class="s1">text 
 
 
</span><span class="s2">def </span><span class="s1">dedent_description(pkg_info): 
    </span><span class="s0">&quot;&quot;&quot; 
    Dedent and convert pkg_info['Description'] to Unicode. 
    &quot;&quot;&quot;</span><span class="s1"> 
    description = pkg_info[</span><span class="s3">'Description'</span><span class="s1">] 
 
    </span><span class="s4"># Python 3 Unicode handling, sorta.</span><span class="s1"> 
    surrogates = </span><span class="s2">False</span><span class="s1"> 
    </span><span class="s2">if not </span><span class="s1">isinstance(description</span><span class="s2">, </span><span class="s1">str): 
        surrogates = </span><span class="s2">True</span><span class="s1"> 
        description = pkginfo_unicode(pkg_info</span><span class="s2">, </span><span class="s3">'Description'</span><span class="s1">) 
 
    description_lines = description.splitlines() 
    description_dedent = </span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">.join( 
        </span><span class="s4"># if the first line of long_description is blank,</span><span class="s1"> 
        </span><span class="s4"># the first line here will be indented.</span><span class="s1"> 
        (description_lines[</span><span class="s5">0</span><span class="s1">].lstrip()</span><span class="s2">,</span><span class="s1"> 
         textwrap.dedent(</span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">.join(description_lines[</span><span class="s5">1</span><span class="s1">:]))</span><span class="s2">,</span><span class="s1"> 
         </span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">)) 
 
    </span><span class="s2">if </span><span class="s1">surrogates: 
        description_dedent = description_dedent \ 
            .encode(</span><span class="s3">&quot;utf8&quot;</span><span class="s1">) \ 
            .decode(</span><span class="s3">&quot;ascii&quot;</span><span class="s2">, </span><span class="s3">&quot;surrogateescape&quot;</span><span class="s1">) 
 
    </span><span class="s2">return </span><span class="s1">description_dedent 
 
 
</span><span class="s2">if </span><span class="s1">__name__ == </span><span class="s3">&quot;__main__&quot;</span><span class="s1">: 
    </span><span class="s2">import </span><span class="s1">sys 
    </span><span class="s2">import </span><span class="s1">pprint 
 
    pprint.pprint(pkginfo_to_dict(sys.argv[</span><span class="s5">1</span><span class="s1">])) 
</span></pre>
</body>
</html>