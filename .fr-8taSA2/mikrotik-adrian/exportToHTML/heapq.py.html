<html>
<head>
<title>heapq.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.ln { color: #606366; font-weight: normal; font-style: normal; }
.s0 { color: rgb(98,151,85); font-style: italic; }
.s1 { color: rgb(169,183,198); }
.s2 { color: rgb(128,128,128); }
.s3 { color: rgb(106,135,89); }
.s4 { color: rgb(204,120,50); }
.s5 { color: rgb(104,151,187); }
</style>
</head>
<BODY BGCOLOR="#2b2b2b">
<TABLE CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<TR><TD><CENTER>
<FONT FACE="Arial, Helvetica" COLOR="#000000">
heapq.py</FONT>
</center></TD></TR></TABLE>
<pre>
<span class="s0">&quot;&quot;&quot;Heap queue algorithm (a.k.a. priority queue). 
 
Heaps are arrays for which a[k] &lt;= a[2*k+1] and a[k] &lt;= a[2*k+2] for 
all k, counting elements from 0.  For the sake of comparison, 
non-existing elements are considered to be infinite.  The interesting 
property of a heap is that a[0] is always its smallest element. 
 
Usage: 
 
heap = []            # creates an empty heap 
heappush(heap, item) # pushes a new item on the heap 
item = heappop(heap) # pops the smallest item from the heap 
item = heap[0]       # smallest item on the heap without popping it 
heapify(x)           # transforms list into a heap, in-place, in linear time 
item = heapreplace(heap, item) # pops and returns smallest item, and adds 
                               # new item; the heap size is unchanged 
 
Our API differs from textbook heap algorithms as follows: 
 
- We use 0-based indexing.  This makes the relationship between the 
  index for a node and the indexes for its children slightly less 
  obvious, but is more suitable since Python uses 0-based indexing. 
 
- Our heappop() method returns the smallest item, not the largest. 
 
These two make it possible to view the heap as a regular Python list 
without surprises: heap[0] is the smallest item, and heap.sort() 
maintains the heap invariant! 
&quot;&quot;&quot;</span><span class="s1"> 
 
</span><span class="s2"># Original code by Kevin O'Connor, augmented by Tim Peters and Raymond Hettinger</span><span class="s1"> 
 
__about__ = </span><span class="s3">&quot;&quot;&quot;Heap queues 
 
[explanation by Fran√ßois Pinard] 
 
Heaps are arrays for which a[k] &lt;= a[2*k+1] and a[k] &lt;= a[2*k+2] for 
all k, counting elements from 0.  For the sake of comparison, 
non-existing elements are considered to be infinite.  The interesting 
property of a heap is that a[0] is always its smallest element. 
 
The strange invariant above is meant to be an efficient memory 
representation for a tournament.  The numbers below are `k', not a[k]: 
 
                                   0 
 
                  1                                 2 
 
          3               4                5               6 
 
      7       8       9       10      11      12      13      14 
 
    15 16   17 18   19 20   21 22   23 24   25 26   27 28   29 30 
 
 
In the tree above, each cell `k' is topping `2*k+1' and `2*k+2'.  In 
a usual binary tournament we see in sports, each cell is the winner 
over the two cells it tops, and we can trace the winner down the tree 
to see all opponents s/he had.  However, in many computer applications 
of such tournaments, we do not need to trace the history of a winner. 
To be more memory efficient, when a winner is promoted, we try to 
replace it by something else at a lower level, and the rule becomes 
that a cell and the two cells it tops contain three different items, 
but the top cell &quot;wins&quot; over the two topped cells. 
 
If this heap invariant is protected at all time, index 0 is clearly 
the overall winner.  The simplest algorithmic way to remove it and 
find the &quot;next&quot; winner is to move some loser (let's say cell 30 in the 
diagram above) into the 0 position, and then percolate this new 0 down 
the tree, exchanging values, until the invariant is re-established. 
This is clearly logarithmic on the total number of items in the tree. 
By iterating over all items, you get an O(n ln n) sort. 
 
A nice feature of this sort is that you can efficiently insert new 
items while the sort is going on, provided that the inserted items are 
not &quot;better&quot; than the last 0'th element you extracted.  This is 
especially useful in simulation contexts, where the tree holds all 
incoming events, and the &quot;win&quot; condition means the smallest scheduled 
time.  When an event schedule other events for execution, they are 
scheduled into the future, so they can easily go into the heap.  So, a 
heap is a good structure for implementing schedulers (this is what I 
used for my MIDI sequencer :-). 
 
Various structures for implementing schedulers have been extensively 
studied, and heaps are good for this, as they are reasonably speedy, 
the speed is almost constant, and the worst case is not much different 
than the average case.  However, there are other representations which 
are more efficient overall, yet the worst cases might be terrible. 
 
Heaps are also very useful in big disk sorts.  You most probably all 
know that a big sort implies producing &quot;runs&quot; (which are pre-sorted 
sequences, which size is usually related to the amount of CPU memory), 
followed by a merging passes for these runs, which merging is often 
very cleverly organised[1].  It is very important that the initial 
sort produces the longest runs possible.  Tournaments are a good way 
to that.  If, using all the memory available to hold a tournament, you 
replace and percolate items that happen to fit the current run, you'll 
produce runs which are twice the size of the memory for random input, 
and much better for input fuzzily ordered. 
 
Moreover, if you output the 0'th item on disk and get an input which 
may not fit in the current tournament (because the value &quot;wins&quot; over 
the last output value), it cannot fit in the heap, so the size of the 
heap decreases.  The freed memory could be cleverly reused immediately 
for progressively building a second heap, which grows at exactly the 
same rate the first heap is melting.  When the first heap completely 
vanishes, you switch heaps and start a new run.  Clever and quite 
effective! 
 
In a word, heaps are useful memory structures to know.  I use them in 
a few applications, and I think it is good to keep a `heap' module 
around. :-) 
 
-------------------- 
[1] The disk balancing algorithms which are current, nowadays, are 
more annoying than clever, and this is a consequence of the seeking 
capabilities of the disks.  On devices which cannot seek, like big 
tape drives, the story was quite different, and one had to be very 
clever to ensure (far in advance) that each tape movement will be the 
most effective possible (that is, will best participate at 
&quot;progressing&quot; the merge).  Some tapes were even able to read 
backwards, and this was also used to avoid the rewinding time. 
Believe me, real good tape sorts were quite spectacular to watch! 
From all times, sorting has always been a Great Art! :-) 
&quot;&quot;&quot;</span><span class="s1"> 
 
__all__ = [</span><span class="s3">'heappush'</span><span class="s4">, </span><span class="s3">'heappop'</span><span class="s4">, </span><span class="s3">'heapify'</span><span class="s4">, </span><span class="s3">'heapreplace'</span><span class="s4">, </span><span class="s3">'merge'</span><span class="s4">,</span><span class="s1"> 
           </span><span class="s3">'nlargest'</span><span class="s4">, </span><span class="s3">'nsmallest'</span><span class="s4">, </span><span class="s3">'heappushpop'</span><span class="s1">] 
 
</span><span class="s4">def </span><span class="s1">heappush(heap</span><span class="s4">, </span><span class="s1">item): 
    </span><span class="s0">&quot;&quot;&quot;Push item onto heap, maintaining the heap invariant.&quot;&quot;&quot;</span><span class="s1"> 
    heap.append(item) 
    _siftdown(heap</span><span class="s4">, </span><span class="s5">0</span><span class="s4">, </span><span class="s1">len(heap)-</span><span class="s5">1</span><span class="s1">) 
 
</span><span class="s4">def </span><span class="s1">heappop(heap): 
    </span><span class="s0">&quot;&quot;&quot;Pop the smallest item off the heap, maintaining the heap invariant.&quot;&quot;&quot;</span><span class="s1"> 
    lastelt = heap.pop()    </span><span class="s2"># raises appropriate IndexError if heap is empty</span><span class="s1"> 
    </span><span class="s4">if </span><span class="s1">heap: 
        returnitem = heap[</span><span class="s5">0</span><span class="s1">] 
        heap[</span><span class="s5">0</span><span class="s1">] = lastelt 
        _siftup(heap</span><span class="s4">, </span><span class="s5">0</span><span class="s1">) 
        </span><span class="s4">return </span><span class="s1">returnitem 
    </span><span class="s4">return </span><span class="s1">lastelt 
 
</span><span class="s4">def </span><span class="s1">heapreplace(heap</span><span class="s4">, </span><span class="s1">item): 
    </span><span class="s0">&quot;&quot;&quot;Pop and return the current smallest value, and add the new item. 
 
    This is more efficient than heappop() followed by heappush(), and can be 
    more appropriate when using a fixed-size heap.  Note that the value 
    returned may be larger than item!  That constrains reasonable uses of 
    this routine unless written as part of a conditional replacement: 
 
        if item &gt; heap[0]: 
            item = heapreplace(heap, item) 
    &quot;&quot;&quot;</span><span class="s1"> 
    returnitem = heap[</span><span class="s5">0</span><span class="s1">]    </span><span class="s2"># raises appropriate IndexError if heap is empty</span><span class="s1"> 
    heap[</span><span class="s5">0</span><span class="s1">] = item 
    _siftup(heap</span><span class="s4">, </span><span class="s5">0</span><span class="s1">) 
    </span><span class="s4">return </span><span class="s1">returnitem 
 
</span><span class="s4">def </span><span class="s1">heappushpop(heap</span><span class="s4">, </span><span class="s1">item): 
    </span><span class="s0">&quot;&quot;&quot;Fast version of a heappush followed by a heappop.&quot;&quot;&quot;</span><span class="s1"> 
    </span><span class="s4">if </span><span class="s1">heap </span><span class="s4">and </span><span class="s1">heap[</span><span class="s5">0</span><span class="s1">] &lt; item: 
        item</span><span class="s4">, </span><span class="s1">heap[</span><span class="s5">0</span><span class="s1">] = heap[</span><span class="s5">0</span><span class="s1">]</span><span class="s4">, </span><span class="s1">item 
        _siftup(heap</span><span class="s4">, </span><span class="s5">0</span><span class="s1">) 
    </span><span class="s4">return </span><span class="s1">item 
 
</span><span class="s4">def </span><span class="s1">heapify(x): 
    </span><span class="s0">&quot;&quot;&quot;Transform list into a heap, in-place, in O(len(x)) time.&quot;&quot;&quot;</span><span class="s1"> 
    n = len(x) 
    </span><span class="s2"># Transform bottom-up.  The largest index there's any point to looking at</span><span class="s1"> 
    </span><span class="s2"># is the largest with a child index in-range, so must have 2*i + 1 &lt; n,</span><span class="s1"> 
    </span><span class="s2"># or i &lt; (n-1)/2.  If n is even = 2*j, this is (2*j-1)/2 = j-1/2 so</span><span class="s1"> 
    </span><span class="s2"># j-1 is the largest, which is n//2 - 1.  If n is odd = 2*j+1, this is</span><span class="s1"> 
    </span><span class="s2"># (2*j+1-1)/2 = j so j-1 is the largest, and that's again n//2-1.</span><span class="s1"> 
    </span><span class="s4">for </span><span class="s1">i </span><span class="s4">in </span><span class="s1">reversed(range(n//</span><span class="s5">2</span><span class="s1">)): 
        _siftup(x</span><span class="s4">, </span><span class="s1">i) 
 
</span><span class="s4">def </span><span class="s1">_heappop_max(heap): 
    </span><span class="s0">&quot;&quot;&quot;Maxheap version of a heappop.&quot;&quot;&quot;</span><span class="s1"> 
    lastelt = heap.pop()    </span><span class="s2"># raises appropriate IndexError if heap is empty</span><span class="s1"> 
    </span><span class="s4">if </span><span class="s1">heap: 
        returnitem = heap[</span><span class="s5">0</span><span class="s1">] 
        heap[</span><span class="s5">0</span><span class="s1">] = lastelt 
        _siftup_max(heap</span><span class="s4">, </span><span class="s5">0</span><span class="s1">) 
        </span><span class="s4">return </span><span class="s1">returnitem 
    </span><span class="s4">return </span><span class="s1">lastelt 
 
</span><span class="s4">def </span><span class="s1">_heapreplace_max(heap</span><span class="s4">, </span><span class="s1">item): 
    </span><span class="s0">&quot;&quot;&quot;Maxheap version of a heappop followed by a heappush.&quot;&quot;&quot;</span><span class="s1"> 
    returnitem = heap[</span><span class="s5">0</span><span class="s1">]    </span><span class="s2"># raises appropriate IndexError if heap is empty</span><span class="s1"> 
    heap[</span><span class="s5">0</span><span class="s1">] = item 
    _siftup_max(heap</span><span class="s4">, </span><span class="s5">0</span><span class="s1">) 
    </span><span class="s4">return </span><span class="s1">returnitem 
 
</span><span class="s4">def </span><span class="s1">_heapify_max(x): 
    </span><span class="s0">&quot;&quot;&quot;Transform list into a maxheap, in-place, in O(len(x)) time.&quot;&quot;&quot;</span><span class="s1"> 
    n = len(x) 
    </span><span class="s4">for </span><span class="s1">i </span><span class="s4">in </span><span class="s1">reversed(range(n//</span><span class="s5">2</span><span class="s1">)): 
        _siftup_max(x</span><span class="s4">, </span><span class="s1">i) 
 
</span><span class="s2"># 'heap' is a heap at all indices &gt;= startpos, except possibly for pos.  pos</span><span class="s1"> 
</span><span class="s2"># is the index of a leaf with a possibly out-of-order value.  Restore the</span><span class="s1"> 
</span><span class="s2"># heap invariant.</span><span class="s1"> 
</span><span class="s4">def </span><span class="s1">_siftdown(heap</span><span class="s4">, </span><span class="s1">startpos</span><span class="s4">, </span><span class="s1">pos): 
    newitem = heap[pos] 
    </span><span class="s2"># Follow the path to the root, moving parents down until finding a place</span><span class="s1"> 
    </span><span class="s2"># newitem fits.</span><span class="s1"> 
    </span><span class="s4">while </span><span class="s1">pos &gt; startpos: 
        parentpos = (pos - </span><span class="s5">1</span><span class="s1">) &gt;&gt; </span><span class="s5">1</span><span class="s1"> 
        parent = heap[parentpos] 
        </span><span class="s4">if </span><span class="s1">newitem &lt; parent: 
            heap[pos] = parent 
            pos = parentpos 
            </span><span class="s4">continue</span><span class="s1"> 
        </span><span class="s4">break</span><span class="s1"> 
    heap[pos] = newitem 
 
</span><span class="s2"># The child indices of heap index pos are already heaps, and we want to make</span><span class="s1"> 
</span><span class="s2"># a heap at index pos too.  We do this by bubbling the smaller child of</span><span class="s1"> 
</span><span class="s2"># pos up (and so on with that child's children, etc) until hitting a leaf,</span><span class="s1"> 
</span><span class="s2"># then using _siftdown to move the oddball originally at index pos into place.</span><span class="s1"> 
</span><span class="s2">#</span><span class="s1"> 
</span><span class="s2"># We *could* break out of the loop as soon as we find a pos where newitem &lt;=</span><span class="s1"> 
</span><span class="s2"># both its children, but turns out that's not a good idea, and despite that</span><span class="s1"> 
</span><span class="s2"># many books write the algorithm that way.  During a heap pop, the last array</span><span class="s1"> 
</span><span class="s2"># element is sifted in, and that tends to be large, so that comparing it</span><span class="s1"> 
</span><span class="s2"># against values starting from the root usually doesn't pay (= usually doesn't</span><span class="s1"> 
</span><span class="s2"># get us out of the loop early).  See Knuth, Volume 3, where this is</span><span class="s1"> 
</span><span class="s2"># explained and quantified in an exercise.</span><span class="s1"> 
</span><span class="s2">#</span><span class="s1"> 
</span><span class="s2"># Cutting the # of comparisons is important, since these routines have no</span><span class="s1"> 
</span><span class="s2"># way to extract &quot;the priority&quot; from an array element, so that intelligence</span><span class="s1"> 
</span><span class="s2"># is likely to be hiding in custom comparison methods, or in array elements</span><span class="s1"> 
</span><span class="s2"># storing (priority, record) tuples.  Comparisons are thus potentially</span><span class="s1"> 
</span><span class="s2"># expensive.</span><span class="s1"> 
</span><span class="s2">#</span><span class="s1"> 
</span><span class="s2"># On random arrays of length 1000, making this change cut the number of</span><span class="s1"> 
</span><span class="s2"># comparisons made by heapify() a little, and those made by exhaustive</span><span class="s1"> 
</span><span class="s2"># heappop() a lot, in accord with theory.  Here are typical results from 3</span><span class="s1"> 
</span><span class="s2"># runs (3 just to demonstrate how small the variance is):</span><span class="s1"> 
</span><span class="s2">#</span><span class="s1"> 
</span><span class="s2"># Compares needed by heapify     Compares needed by 1000 heappops</span><span class="s1"> 
</span><span class="s2"># --------------------------     --------------------------------</span><span class="s1"> 
</span><span class="s2"># 1837 cut to 1663               14996 cut to 8680</span><span class="s1"> 
</span><span class="s2"># 1855 cut to 1659               14966 cut to 8678</span><span class="s1"> 
</span><span class="s2"># 1847 cut to 1660               15024 cut to 8703</span><span class="s1"> 
</span><span class="s2">#</span><span class="s1"> 
</span><span class="s2"># Building the heap by using heappush() 1000 times instead required</span><span class="s1"> 
</span><span class="s2"># 2198, 2148, and 2219 compares:  heapify() is more efficient, when</span><span class="s1"> 
</span><span class="s2"># you can use it.</span><span class="s1"> 
</span><span class="s2">#</span><span class="s1"> 
</span><span class="s2"># The total compares needed by list.sort() on the same lists were 8627,</span><span class="s1"> 
</span><span class="s2"># 8627, and 8632 (this should be compared to the sum of heapify() and</span><span class="s1"> 
</span><span class="s2"># heappop() compares):  list.sort() is (unsurprisingly!) more efficient</span><span class="s1"> 
</span><span class="s2"># for sorting.</span><span class="s1"> 
 
</span><span class="s4">def </span><span class="s1">_siftup(heap</span><span class="s4">, </span><span class="s1">pos): 
    endpos = len(heap) 
    startpos = pos 
    newitem = heap[pos] 
    </span><span class="s2"># Bubble up the smaller child until hitting a leaf.</span><span class="s1"> 
    childpos = </span><span class="s5">2</span><span class="s1">*pos + </span><span class="s5">1    </span><span class="s2"># leftmost child position</span><span class="s1"> 
    </span><span class="s4">while </span><span class="s1">childpos &lt; endpos: 
        </span><span class="s2"># Set childpos to index of smaller child.</span><span class="s1"> 
        rightpos = childpos + </span><span class="s5">1</span><span class="s1"> 
        </span><span class="s4">if </span><span class="s1">rightpos &lt; endpos </span><span class="s4">and not </span><span class="s1">heap[childpos] &lt; heap[rightpos]: 
            childpos = rightpos 
        </span><span class="s2"># Move the smaller child up.</span><span class="s1"> 
        heap[pos] = heap[childpos] 
        pos = childpos 
        childpos = </span><span class="s5">2</span><span class="s1">*pos + </span><span class="s5">1</span><span class="s1"> 
    </span><span class="s2"># The leaf at pos is empty now.  Put newitem there, and bubble it up</span><span class="s1"> 
    </span><span class="s2"># to its final resting place (by sifting its parents down).</span><span class="s1"> 
    heap[pos] = newitem 
    _siftdown(heap</span><span class="s4">, </span><span class="s1">startpos</span><span class="s4">, </span><span class="s1">pos) 
 
</span><span class="s4">def </span><span class="s1">_siftdown_max(heap</span><span class="s4">, </span><span class="s1">startpos</span><span class="s4">, </span><span class="s1">pos): 
    </span><span class="s0">'Maxheap variant of _siftdown'</span><span class="s1"> 
    newitem = heap[pos] 
    </span><span class="s2"># Follow the path to the root, moving parents down until finding a place</span><span class="s1"> 
    </span><span class="s2"># newitem fits.</span><span class="s1"> 
    </span><span class="s4">while </span><span class="s1">pos &gt; startpos: 
        parentpos = (pos - </span><span class="s5">1</span><span class="s1">) &gt;&gt; </span><span class="s5">1</span><span class="s1"> 
        parent = heap[parentpos] 
        </span><span class="s4">if </span><span class="s1">parent &lt; newitem: 
            heap[pos] = parent 
            pos = parentpos 
            </span><span class="s4">continue</span><span class="s1"> 
        </span><span class="s4">break</span><span class="s1"> 
    heap[pos] = newitem 
 
</span><span class="s4">def </span><span class="s1">_siftup_max(heap</span><span class="s4">, </span><span class="s1">pos): 
    </span><span class="s0">'Maxheap variant of _siftup'</span><span class="s1"> 
    endpos = len(heap) 
    startpos = pos 
    newitem = heap[pos] 
    </span><span class="s2"># Bubble up the larger child until hitting a leaf.</span><span class="s1"> 
    childpos = </span><span class="s5">2</span><span class="s1">*pos + </span><span class="s5">1    </span><span class="s2"># leftmost child position</span><span class="s1"> 
    </span><span class="s4">while </span><span class="s1">childpos &lt; endpos: 
        </span><span class="s2"># Set childpos to index of larger child.</span><span class="s1"> 
        rightpos = childpos + </span><span class="s5">1</span><span class="s1"> 
        </span><span class="s4">if </span><span class="s1">rightpos &lt; endpos </span><span class="s4">and not </span><span class="s1">heap[rightpos] &lt; heap[childpos]: 
            childpos = rightpos 
        </span><span class="s2"># Move the larger child up.</span><span class="s1"> 
        heap[pos] = heap[childpos] 
        pos = childpos 
        childpos = </span><span class="s5">2</span><span class="s1">*pos + </span><span class="s5">1</span><span class="s1"> 
    </span><span class="s2"># The leaf at pos is empty now.  Put newitem there, and bubble it up</span><span class="s1"> 
    </span><span class="s2"># to its final resting place (by sifting its parents down).</span><span class="s1"> 
    heap[pos] = newitem 
    _siftdown_max(heap</span><span class="s4">, </span><span class="s1">startpos</span><span class="s4">, </span><span class="s1">pos) 
 
</span><span class="s4">def </span><span class="s1">merge(*iterables</span><span class="s4">, </span><span class="s1">key=</span><span class="s4">None, </span><span class="s1">reverse=</span><span class="s4">False</span><span class="s1">): 
    </span><span class="s0">'''Merge multiple sorted inputs into a single sorted output. 
 
    Similar to sorted(itertools.chain(*iterables)) but returns a generator, 
    does not pull the data into memory all at once, and assumes that each of 
    the input streams is already sorted (smallest to largest). 
 
    &gt;&gt;&gt; list(merge([1,3,5,7], [0,2,4,8], [5,10,15,20], [], [25])) 
    [0, 1, 2, 3, 4, 5, 5, 7, 8, 10, 15, 20, 25] 
 
    If *key* is not None, applies a key function to each element to determine 
    its sort order. 
 
    &gt;&gt;&gt; list(merge(['dog', 'horse'], ['cat', 'fish', 'kangaroo'], key=len)) 
    ['dog', 'cat', 'fish', 'horse', 'kangaroo'] 
 
    '''</span><span class="s1"> 
 
    h = [] 
    h_append = h.append 
 
    </span><span class="s4">if </span><span class="s1">reverse: 
        _heapify = _heapify_max 
        _heappop = _heappop_max 
        _heapreplace = _heapreplace_max 
        direction = -</span><span class="s5">1</span><span class="s1"> 
    </span><span class="s4">else</span><span class="s1">: 
        _heapify = heapify 
        _heappop = heappop 
        _heapreplace = heapreplace 
        direction = </span><span class="s5">1</span><span class="s1"> 
 
    </span><span class="s4">if </span><span class="s1">key </span><span class="s4">is None</span><span class="s1">: 
        </span><span class="s4">for </span><span class="s1">order</span><span class="s4">, </span><span class="s1">it </span><span class="s4">in </span><span class="s1">enumerate(map(iter</span><span class="s4">, </span><span class="s1">iterables)): 
            </span><span class="s4">try</span><span class="s1">: 
                next = it.__next__ 
                h_append([next()</span><span class="s4">, </span><span class="s1">order * direction</span><span class="s4">, </span><span class="s1">next]) 
            </span><span class="s4">except </span><span class="s1">StopIteration: 
                </span><span class="s4">pass</span><span class="s1"> 
        _heapify(h) 
        </span><span class="s4">while </span><span class="s1">len(h) &gt; </span><span class="s5">1</span><span class="s1">: 
            </span><span class="s4">try</span><span class="s1">: 
                </span><span class="s4">while True</span><span class="s1">: 
                    value</span><span class="s4">, </span><span class="s1">order</span><span class="s4">, </span><span class="s1">next = s = h[</span><span class="s5">0</span><span class="s1">] 
                    </span><span class="s4">yield </span><span class="s1">value 
                    s[</span><span class="s5">0</span><span class="s1">] = next()           </span><span class="s2"># raises StopIteration when exhausted</span><span class="s1"> 
                    _heapreplace(h</span><span class="s4">, </span><span class="s1">s)      </span><span class="s2"># restore heap condition</span><span class="s1"> 
            </span><span class="s4">except </span><span class="s1">StopIteration: 
                _heappop(h)                 </span><span class="s2"># remove empty iterator</span><span class="s1"> 
        </span><span class="s4">if </span><span class="s1">h: 
            </span><span class="s2"># fast case when only a single iterator remains</span><span class="s1"> 
            value</span><span class="s4">, </span><span class="s1">order</span><span class="s4">, </span><span class="s1">next = h[</span><span class="s5">0</span><span class="s1">] 
            </span><span class="s4">yield </span><span class="s1">value 
            </span><span class="s4">yield from </span><span class="s1">next.__self__ 
        </span><span class="s4">return</span><span class="s1"> 
 
    </span><span class="s4">for </span><span class="s1">order</span><span class="s4">, </span><span class="s1">it </span><span class="s4">in </span><span class="s1">enumerate(map(iter</span><span class="s4">, </span><span class="s1">iterables)): 
        </span><span class="s4">try</span><span class="s1">: 
            next = it.__next__ 
            value = next() 
            h_append([key(value)</span><span class="s4">, </span><span class="s1">order * direction</span><span class="s4">, </span><span class="s1">value</span><span class="s4">, </span><span class="s1">next]) 
        </span><span class="s4">except </span><span class="s1">StopIteration: 
            </span><span class="s4">pass</span><span class="s1"> 
    _heapify(h) 
    </span><span class="s4">while </span><span class="s1">len(h) &gt; </span><span class="s5">1</span><span class="s1">: 
        </span><span class="s4">try</span><span class="s1">: 
            </span><span class="s4">while True</span><span class="s1">: 
                key_value</span><span class="s4">, </span><span class="s1">order</span><span class="s4">, </span><span class="s1">value</span><span class="s4">, </span><span class="s1">next = s = h[</span><span class="s5">0</span><span class="s1">] 
                </span><span class="s4">yield </span><span class="s1">value 
                value = next() 
                s[</span><span class="s5">0</span><span class="s1">] = key(value) 
                s[</span><span class="s5">2</span><span class="s1">] = value 
                _heapreplace(h</span><span class="s4">, </span><span class="s1">s) 
        </span><span class="s4">except </span><span class="s1">StopIteration: 
            _heappop(h) 
    </span><span class="s4">if </span><span class="s1">h: 
        key_value</span><span class="s4">, </span><span class="s1">order</span><span class="s4">, </span><span class="s1">value</span><span class="s4">, </span><span class="s1">next = h[</span><span class="s5">0</span><span class="s1">] 
        </span><span class="s4">yield </span><span class="s1">value 
        </span><span class="s4">yield from </span><span class="s1">next.__self__ 
 
 
</span><span class="s2"># Algorithm notes for nlargest() and nsmallest()</span><span class="s1"> 
</span><span class="s2"># ==============================================</span><span class="s1"> 
</span><span class="s2">#</span><span class="s1"> 
</span><span class="s2"># Make a single pass over the data while keeping the k most extreme values</span><span class="s1"> 
</span><span class="s2"># in a heap.  Memory consumption is limited to keeping k values in a list.</span><span class="s1"> 
</span><span class="s2">#</span><span class="s1"> 
</span><span class="s2"># Measured performance for random inputs:</span><span class="s1"> 
</span><span class="s2">#</span><span class="s1"> 
</span><span class="s2">#                                   number of comparisons</span><span class="s1"> 
</span><span class="s2">#    n inputs     k-extreme values  (average of 5 trials)   % more than min()</span><span class="s1"> 
</span><span class="s2"># -------------   ----------------  ---------------------   -----------------</span><span class="s1"> 
</span><span class="s2">#      1,000           100                  3,317               231.7%</span><span class="s1"> 
</span><span class="s2">#     10,000           100                 14,046                40.5%</span><span class="s1"> 
</span><span class="s2">#    100,000           100                105,749                 5.7%</span><span class="s1"> 
</span><span class="s2">#  1,000,000           100              1,007,751                 0.8%</span><span class="s1"> 
</span><span class="s2"># 10,000,000           100             10,009,401                 0.1%</span><span class="s1"> 
</span><span class="s2">#</span><span class="s1"> 
</span><span class="s2"># Theoretical number of comparisons for k smallest of n random inputs:</span><span class="s1"> 
</span><span class="s2">#</span><span class="s1"> 
</span><span class="s2"># Step   Comparisons                  Action</span><span class="s1"> 
</span><span class="s2"># ----   --------------------------   ---------------------------</span><span class="s1"> 
</span><span class="s2">#  1     1.66 * k                     heapify the first k-inputs</span><span class="s1"> 
</span><span class="s2">#  2     n - k                        compare remaining elements to top of heap</span><span class="s1"> 
</span><span class="s2">#  3     k * (1 + lg2(k)) * ln(n/k)   replace the topmost value on the heap</span><span class="s1"> 
</span><span class="s2">#  4     k * lg2(k) - (k/2)           final sort of the k most extreme values</span><span class="s1"> 
</span><span class="s2">#</span><span class="s1"> 
</span><span class="s2"># Combining and simplifying for a rough estimate gives:</span><span class="s1"> 
</span><span class="s2">#</span><span class="s1"> 
</span><span class="s2">#        comparisons = n + k * (log(k, 2) * log(n/k) + log(k, 2) + log(n/k))</span><span class="s1"> 
</span><span class="s2">#</span><span class="s1"> 
</span><span class="s2"># Computing the number of comparisons for step 3:</span><span class="s1"> 
</span><span class="s2"># -----------------------------------------------</span><span class="s1"> 
</span><span class="s2"># * For the i-th new value from the iterable, the probability of being in the</span><span class="s1"> 
</span><span class="s2">#   k most extreme values is k/i.  For example, the probability of the 101st</span><span class="s1"> 
</span><span class="s2">#   value seen being in the 100 most extreme values is 100/101.</span><span class="s1"> 
</span><span class="s2"># * If the value is a new extreme value, the cost of inserting it into the</span><span class="s1"> 
</span><span class="s2">#   heap is 1 + log(k, 2).</span><span class="s1"> 
</span><span class="s2"># * The probability times the cost gives:</span><span class="s1"> 
</span><span class="s2">#            (k/i) * (1 + log(k, 2))</span><span class="s1"> 
</span><span class="s2"># * Summing across the remaining n-k elements gives:</span><span class="s1"> 
</span><span class="s2">#            sum((k/i) * (1 + log(k, 2)) for i in range(k+1, n+1))</span><span class="s1"> 
</span><span class="s2"># * This reduces to:</span><span class="s1"> 
</span><span class="s2">#            (H(n) - H(k)) * k * (1 + log(k, 2))</span><span class="s1"> 
</span><span class="s2"># * Where H(n) is the n-th harmonic number estimated by:</span><span class="s1"> 
</span><span class="s2">#            gamma = 0.5772156649</span><span class="s1"> 
</span><span class="s2">#            H(n) = log(n, e) + gamma + 1 / (2 * n)</span><span class="s1"> 
</span><span class="s2">#   http://en.wikipedia.org/wiki/Harmonic_series_(mathematics)#Rate_of_divergence</span><span class="s1"> 
</span><span class="s2"># * Substituting the H(n) formula:</span><span class="s1"> 
</span><span class="s2">#            comparisons = k * (1 + log(k, 2)) * (log(n/k, e) + (1/n - 1/k) / 2)</span><span class="s1"> 
</span><span class="s2">#</span><span class="s1"> 
</span><span class="s2"># Worst-case for step 3:</span><span class="s1"> 
</span><span class="s2"># ----------------------</span><span class="s1"> 
</span><span class="s2"># In the worst case, the input data is reversed sorted so that every new element</span><span class="s1"> 
</span><span class="s2"># must be inserted in the heap:</span><span class="s1"> 
</span><span class="s2">#</span><span class="s1"> 
</span><span class="s2">#             comparisons = 1.66 * k + log(k, 2) * (n - k)</span><span class="s1"> 
</span><span class="s2">#</span><span class="s1"> 
</span><span class="s2"># Alternative Algorithms</span><span class="s1"> 
</span><span class="s2"># ----------------------</span><span class="s1"> 
</span><span class="s2"># Other algorithms were not used because they:</span><span class="s1"> 
</span><span class="s2"># 1) Took much more auxiliary memory,</span><span class="s1"> 
</span><span class="s2"># 2) Made multiple passes over the data.</span><span class="s1"> 
</span><span class="s2"># 3) Made more comparisons in common cases (small k, large n, semi-random input).</span><span class="s1"> 
</span><span class="s2"># See the more detailed comparison of approach at:</span><span class="s1"> 
</span><span class="s2"># http://code.activestate.com/recipes/577573-compare-algorithms-for-heapqsmallest</span><span class="s1"> 
 
</span><span class="s4">def </span><span class="s1">nsmallest(n</span><span class="s4">, </span><span class="s1">iterable</span><span class="s4">, </span><span class="s1">key=</span><span class="s4">None</span><span class="s1">): 
    </span><span class="s0">&quot;&quot;&quot;Find the n smallest elements in a dataset. 
 
    Equivalent to:  sorted(iterable, key=key)[:n] 
    &quot;&quot;&quot;</span><span class="s1"> 
 
    </span><span class="s2"># Short-cut for n==1 is to use min()</span><span class="s1"> 
    </span><span class="s4">if </span><span class="s1">n == </span><span class="s5">1</span><span class="s1">: 
        it = iter(iterable) 
        sentinel = object() 
        </span><span class="s4">if </span><span class="s1">key </span><span class="s4">is None</span><span class="s1">: 
            result = min(it</span><span class="s4">, </span><span class="s1">default=sentinel) 
        </span><span class="s4">else</span><span class="s1">: 
            result = min(it</span><span class="s4">, </span><span class="s1">default=sentinel</span><span class="s4">, </span><span class="s1">key=key) 
        </span><span class="s4">return </span><span class="s1">[] </span><span class="s4">if </span><span class="s1">result </span><span class="s4">is </span><span class="s1">sentinel </span><span class="s4">else </span><span class="s1">[result] 
 
    </span><span class="s2"># When n&gt;=size, it's faster to use sorted()</span><span class="s1"> 
    </span><span class="s4">try</span><span class="s1">: 
        size = len(iterable) 
    </span><span class="s4">except </span><span class="s1">(TypeError</span><span class="s4">, </span><span class="s1">AttributeError): 
        </span><span class="s4">pass</span><span class="s1"> 
    </span><span class="s4">else</span><span class="s1">: 
        </span><span class="s4">if </span><span class="s1">n &gt;= size: 
            </span><span class="s4">return </span><span class="s1">sorted(iterable</span><span class="s4">, </span><span class="s1">key=key)[:n] 
 
    </span><span class="s2"># When key is none, use simpler decoration</span><span class="s1"> 
    </span><span class="s4">if </span><span class="s1">key </span><span class="s4">is None</span><span class="s1">: 
        it = iter(iterable) 
        </span><span class="s2"># put the range(n) first so that zip() doesn't</span><span class="s1"> 
        </span><span class="s2"># consume one too many elements from the iterator</span><span class="s1"> 
        result = [(elem</span><span class="s4">, </span><span class="s1">i) </span><span class="s4">for </span><span class="s1">i</span><span class="s4">, </span><span class="s1">elem </span><span class="s4">in </span><span class="s1">zip(range(n)</span><span class="s4">, </span><span class="s1">it)] 
        </span><span class="s4">if not </span><span class="s1">result: 
            </span><span class="s4">return </span><span class="s1">result 
        _heapify_max(result) 
        top = result[</span><span class="s5">0</span><span class="s1">][</span><span class="s5">0</span><span class="s1">] 
        order = n 
        _heapreplace = _heapreplace_max 
        </span><span class="s4">for </span><span class="s1">elem </span><span class="s4">in </span><span class="s1">it: 
            </span><span class="s4">if </span><span class="s1">elem &lt; top: 
                _heapreplace(result</span><span class="s4">, </span><span class="s1">(elem</span><span class="s4">, </span><span class="s1">order)) 
                top = result[</span><span class="s5">0</span><span class="s1">][</span><span class="s5">0</span><span class="s1">] 
                order += </span><span class="s5">1</span><span class="s1"> 
        result.sort() 
        </span><span class="s4">return </span><span class="s1">[r[</span><span class="s5">0</span><span class="s1">] </span><span class="s4">for </span><span class="s1">r </span><span class="s4">in </span><span class="s1">result] 
 
    </span><span class="s2"># General case, slowest method</span><span class="s1"> 
    it = iter(iterable) 
    result = [(key(elem)</span><span class="s4">, </span><span class="s1">i</span><span class="s4">, </span><span class="s1">elem) </span><span class="s4">for </span><span class="s1">i</span><span class="s4">, </span><span class="s1">elem </span><span class="s4">in </span><span class="s1">zip(range(n)</span><span class="s4">, </span><span class="s1">it)] 
    </span><span class="s4">if not </span><span class="s1">result: 
        </span><span class="s4">return </span><span class="s1">result 
    _heapify_max(result) 
    top = result[</span><span class="s5">0</span><span class="s1">][</span><span class="s5">0</span><span class="s1">] 
    order = n 
    _heapreplace = _heapreplace_max 
    </span><span class="s4">for </span><span class="s1">elem </span><span class="s4">in </span><span class="s1">it: 
        k = key(elem) 
        </span><span class="s4">if </span><span class="s1">k &lt; top: 
            _heapreplace(result</span><span class="s4">, </span><span class="s1">(k</span><span class="s4">, </span><span class="s1">order</span><span class="s4">, </span><span class="s1">elem)) 
            top = result[</span><span class="s5">0</span><span class="s1">][</span><span class="s5">0</span><span class="s1">] 
            order += </span><span class="s5">1</span><span class="s1"> 
    result.sort() 
    </span><span class="s4">return </span><span class="s1">[r[</span><span class="s5">2</span><span class="s1">] </span><span class="s4">for </span><span class="s1">r </span><span class="s4">in </span><span class="s1">result] 
 
</span><span class="s4">def </span><span class="s1">nlargest(n</span><span class="s4">, </span><span class="s1">iterable</span><span class="s4">, </span><span class="s1">key=</span><span class="s4">None</span><span class="s1">): 
    </span><span class="s0">&quot;&quot;&quot;Find the n largest elements in a dataset. 
 
    Equivalent to:  sorted(iterable, key=key, reverse=True)[:n] 
    &quot;&quot;&quot;</span><span class="s1"> 
 
    </span><span class="s2"># Short-cut for n==1 is to use max()</span><span class="s1"> 
    </span><span class="s4">if </span><span class="s1">n == </span><span class="s5">1</span><span class="s1">: 
        it = iter(iterable) 
        sentinel = object() 
        </span><span class="s4">if </span><span class="s1">key </span><span class="s4">is None</span><span class="s1">: 
            result = max(it</span><span class="s4">, </span><span class="s1">default=sentinel) 
        </span><span class="s4">else</span><span class="s1">: 
            result = max(it</span><span class="s4">, </span><span class="s1">default=sentinel</span><span class="s4">, </span><span class="s1">key=key) 
        </span><span class="s4">return </span><span class="s1">[] </span><span class="s4">if </span><span class="s1">result </span><span class="s4">is </span><span class="s1">sentinel </span><span class="s4">else </span><span class="s1">[result] 
 
    </span><span class="s2"># When n&gt;=size, it's faster to use sorted()</span><span class="s1"> 
    </span><span class="s4">try</span><span class="s1">: 
        size = len(iterable) 
    </span><span class="s4">except </span><span class="s1">(TypeError</span><span class="s4">, </span><span class="s1">AttributeError): 
        </span><span class="s4">pass</span><span class="s1"> 
    </span><span class="s4">else</span><span class="s1">: 
        </span><span class="s4">if </span><span class="s1">n &gt;= size: 
            </span><span class="s4">return </span><span class="s1">sorted(iterable</span><span class="s4">, </span><span class="s1">key=key</span><span class="s4">, </span><span class="s1">reverse=</span><span class="s4">True</span><span class="s1">)[:n] 
 
    </span><span class="s2"># When key is none, use simpler decoration</span><span class="s1"> 
    </span><span class="s4">if </span><span class="s1">key </span><span class="s4">is None</span><span class="s1">: 
        it = iter(iterable) 
        result = [(elem</span><span class="s4">, </span><span class="s1">i) </span><span class="s4">for </span><span class="s1">i</span><span class="s4">, </span><span class="s1">elem </span><span class="s4">in </span><span class="s1">zip(range(</span><span class="s5">0</span><span class="s4">, </span><span class="s1">-n</span><span class="s4">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">)</span><span class="s4">, </span><span class="s1">it)] 
        </span><span class="s4">if not </span><span class="s1">result: 
            </span><span class="s4">return </span><span class="s1">result 
        heapify(result) 
        top = result[</span><span class="s5">0</span><span class="s1">][</span><span class="s5">0</span><span class="s1">] 
        order = -n 
        _heapreplace = heapreplace 
        </span><span class="s4">for </span><span class="s1">elem </span><span class="s4">in </span><span class="s1">it: 
            </span><span class="s4">if </span><span class="s1">top &lt; elem: 
                _heapreplace(result</span><span class="s4">, </span><span class="s1">(elem</span><span class="s4">, </span><span class="s1">order)) 
                top = result[</span><span class="s5">0</span><span class="s1">][</span><span class="s5">0</span><span class="s1">] 
                order -= </span><span class="s5">1</span><span class="s1"> 
        result.sort(reverse=</span><span class="s4">True</span><span class="s1">) 
        </span><span class="s4">return </span><span class="s1">[r[</span><span class="s5">0</span><span class="s1">] </span><span class="s4">for </span><span class="s1">r </span><span class="s4">in </span><span class="s1">result] 
 
    </span><span class="s2"># General case, slowest method</span><span class="s1"> 
    it = iter(iterable) 
    result = [(key(elem)</span><span class="s4">, </span><span class="s1">i</span><span class="s4">, </span><span class="s1">elem) </span><span class="s4">for </span><span class="s1">i</span><span class="s4">, </span><span class="s1">elem </span><span class="s4">in </span><span class="s1">zip(range(</span><span class="s5">0</span><span class="s4">, </span><span class="s1">-n</span><span class="s4">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">)</span><span class="s4">, </span><span class="s1">it)] 
    </span><span class="s4">if not </span><span class="s1">result: 
        </span><span class="s4">return </span><span class="s1">result 
    heapify(result) 
    top = result[</span><span class="s5">0</span><span class="s1">][</span><span class="s5">0</span><span class="s1">] 
    order = -n 
    _heapreplace = heapreplace 
    </span><span class="s4">for </span><span class="s1">elem </span><span class="s4">in </span><span class="s1">it: 
        k = key(elem) 
        </span><span class="s4">if </span><span class="s1">top &lt; k: 
            _heapreplace(result</span><span class="s4">, </span><span class="s1">(k</span><span class="s4">, </span><span class="s1">order</span><span class="s4">, </span><span class="s1">elem)) 
            top = result[</span><span class="s5">0</span><span class="s1">][</span><span class="s5">0</span><span class="s1">] 
            order -= </span><span class="s5">1</span><span class="s1"> 
    result.sort(reverse=</span><span class="s4">True</span><span class="s1">) 
    </span><span class="s4">return </span><span class="s1">[r[</span><span class="s5">2</span><span class="s1">] </span><span class="s4">for </span><span class="s1">r </span><span class="s4">in </span><span class="s1">result] 
 
</span><span class="s2"># If available, use C implementation</span><span class="s1"> 
</span><span class="s4">try</span><span class="s1">: 
    </span><span class="s4">from </span><span class="s1">_heapq </span><span class="s4">import </span><span class="s1">* 
</span><span class="s4">except </span><span class="s1">ImportError: 
    </span><span class="s4">pass</span><span class="s1"> 
</span><span class="s4">try</span><span class="s1">: 
    </span><span class="s4">from </span><span class="s1">_heapq </span><span class="s4">import </span><span class="s1">_heapreplace_max 
</span><span class="s4">except </span><span class="s1">ImportError: 
    </span><span class="s4">pass</span><span class="s1"> 
</span><span class="s4">try</span><span class="s1">: 
    </span><span class="s4">from </span><span class="s1">_heapq </span><span class="s4">import </span><span class="s1">_heapify_max 
</span><span class="s4">except </span><span class="s1">ImportError: 
    </span><span class="s4">pass</span><span class="s1"> 
</span><span class="s4">try</span><span class="s1">: 
    </span><span class="s4">from </span><span class="s1">_heapq </span><span class="s4">import </span><span class="s1">_heappop_max 
</span><span class="s4">except </span><span class="s1">ImportError: 
    </span><span class="s4">pass</span><span class="s1"> 
 
 
</span><span class="s4">if </span><span class="s1">__name__ == </span><span class="s3">&quot;__main__&quot;</span><span class="s1">: 
 
    </span><span class="s4">import </span><span class="s1">doctest 
    print(doctest.testmod()) 
</span></pre>
</body>
</html>