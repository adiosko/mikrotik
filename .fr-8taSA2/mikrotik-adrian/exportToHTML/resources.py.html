<html>
<head>
<title>resources.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.ln { color: #606366; font-weight: normal; font-style: normal; }
.s0 { color: rgb(128,128,128); }
.s1 { color: rgb(169,183,198); }
.s2 { color: rgb(204,120,50); }
.s3 { color: rgb(106,135,89); }
.s4 { color: rgb(98,151,85); font-style: italic; }
.s5 { color: rgb(165,194,97); }
.s6 { color: rgb(104,151,187); }
</style>
</head>
<BODY BGCOLOR="#2b2b2b">
<TABLE CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<TR><TD><CENTER>
<FONT FACE="Arial, Helvetica" COLOR="#000000">
resources.py</FONT>
</center></TD></TR></TABLE>
<pre>
<span class="s0"># -*- coding: utf-8 -*-</span><span class="s1"> 
</span><span class="s0">#</span><span class="s1"> 
</span><span class="s0"># Copyright (C) 2013-2016 Vinay Sajip.</span><span class="s1"> 
</span><span class="s0"># Licensed to the Python Software Foundation under a contributor agreement.</span><span class="s1"> 
</span><span class="s0"># See LICENSE.txt and CONTRIBUTORS.txt.</span><span class="s1"> 
</span><span class="s0">#</span><span class="s1"> 
</span><span class="s2">from </span><span class="s1">__future__ </span><span class="s2">import </span><span class="s1">unicode_literals 
 
</span><span class="s2">import </span><span class="s1">bisect 
</span><span class="s2">import </span><span class="s1">io 
</span><span class="s2">import </span><span class="s1">logging 
</span><span class="s2">import </span><span class="s1">os 
</span><span class="s2">import </span><span class="s1">pkgutil 
</span><span class="s2">import </span><span class="s1">shutil 
</span><span class="s2">import </span><span class="s1">sys 
</span><span class="s2">import </span><span class="s1">types 
</span><span class="s2">import </span><span class="s1">zipimport 
 
</span><span class="s2">from </span><span class="s1">. </span><span class="s2">import </span><span class="s1">DistlibException 
</span><span class="s2">from </span><span class="s1">.util </span><span class="s2">import </span><span class="s1">cached_property</span><span class="s2">, </span><span class="s1">get_cache_base</span><span class="s2">, </span><span class="s1">path_to_cache_dir</span><span class="s2">, </span><span class="s1">Cache 
 
logger = logging.getLogger(__name__) 
 
 
cache = </span><span class="s2">None    </span><span class="s0"># created when needed</span><span class="s1"> 
 
 
</span><span class="s2">class </span><span class="s1">ResourceCache(Cache): 
    </span><span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">base=</span><span class="s2">None</span><span class="s1">): 
        </span><span class="s2">if </span><span class="s1">base </span><span class="s2">is None</span><span class="s1">: 
            </span><span class="s0"># Use native string to avoid issues on 2.x: see Python #20140.</span><span class="s1"> 
            base = os.path.join(get_cache_base()</span><span class="s2">, </span><span class="s1">str(</span><span class="s3">'resource-cache'</span><span class="s1">)) 
        super(ResourceCache</span><span class="s2">, </span><span class="s1">self).__init__(base) 
 
    </span><span class="s2">def </span><span class="s1">is_stale(self</span><span class="s2">, </span><span class="s1">resource</span><span class="s2">, </span><span class="s1">path): 
        </span><span class="s4">&quot;&quot;&quot; 
        Is the cache stale for the given resource? 
 
        :param resource: The :class:`Resource` being cached. 
        :param path: The path of the resource in the cache. 
        :return: True if the cache is stale. 
        &quot;&quot;&quot;</span><span class="s1"> 
        </span><span class="s0"># Cache invalidation is a hard problem :-)</span><span class="s1"> 
        </span><span class="s2">return True</span><span class="s1"> 
 
    </span><span class="s2">def </span><span class="s1">get(self</span><span class="s2">, </span><span class="s1">resource): 
        </span><span class="s4">&quot;&quot;&quot; 
        Get a resource into the cache, 
 
        :param resource: A :class:`Resource` instance. 
        :return: The pathname of the resource in the cache. 
        &quot;&quot;&quot;</span><span class="s1"> 
        prefix</span><span class="s2">, </span><span class="s1">path = resource.finder.get_cache_info(resource) 
        </span><span class="s2">if </span><span class="s1">prefix </span><span class="s2">is None</span><span class="s1">: 
            result = path 
        </span><span class="s2">else</span><span class="s1">: 
            result = os.path.join(self.base</span><span class="s2">, </span><span class="s1">self.prefix_to_dir(prefix)</span><span class="s2">, </span><span class="s1">path) 
            dirname = os.path.dirname(result) 
            </span><span class="s2">if not </span><span class="s1">os.path.isdir(dirname): 
                os.makedirs(dirname) 
            </span><span class="s2">if not </span><span class="s1">os.path.exists(result): 
                stale = </span><span class="s2">True</span><span class="s1"> 
            </span><span class="s2">else</span><span class="s1">: 
                stale = self.is_stale(resource</span><span class="s2">, </span><span class="s1">path) 
            </span><span class="s2">if </span><span class="s1">stale: 
                </span><span class="s0"># write the bytes of the resource to the cache location</span><span class="s1"> 
                </span><span class="s2">with </span><span class="s1">open(result</span><span class="s2">, </span><span class="s3">'wb'</span><span class="s1">) </span><span class="s2">as </span><span class="s1">f: 
                    f.write(resource.bytes) 
        </span><span class="s2">return </span><span class="s1">result 
 
 
</span><span class="s2">class </span><span class="s1">ResourceBase(object): 
    </span><span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">finder</span><span class="s2">, </span><span class="s1">name): 
        self.finder = finder 
        self.name = name 
 
 
</span><span class="s2">class </span><span class="s1">Resource(ResourceBase): 
    </span><span class="s4">&quot;&quot;&quot; 
    A class representing an in-package resource, such as a data file. This is 
    not normally instantiated by user code, but rather by a 
    :class:`ResourceFinder` which manages the resource. 
    &quot;&quot;&quot;</span><span class="s1"> 
    is_container = </span><span class="s2">False        </span><span class="s0"># Backwards compatibility</span><span class="s1"> 
 
    </span><span class="s2">def </span><span class="s1">as_stream(self): 
        </span><span class="s4">&quot;&quot;&quot; 
        Get the resource as a stream. 
 
        This is not a property to make it obvious that it returns a new stream 
        each time. 
        &quot;&quot;&quot;</span><span class="s1"> 
        </span><span class="s2">return </span><span class="s1">self.finder.get_stream(self) 
 
    @cached_property 
    </span><span class="s2">def </span><span class="s1">file_path(self): 
        </span><span class="s2">global </span><span class="s1">cache 
        </span><span class="s2">if </span><span class="s1">cache </span><span class="s2">is None</span><span class="s1">: 
            cache = ResourceCache() 
        </span><span class="s2">return </span><span class="s1">cache.get(self) 
 
    @cached_property 
    </span><span class="s2">def </span><span class="s1">bytes(self): 
        </span><span class="s2">return </span><span class="s1">self.finder.get_bytes(self) 
 
    @cached_property 
    </span><span class="s2">def </span><span class="s1">size(self): 
        </span><span class="s2">return </span><span class="s1">self.finder.get_size(self) 
 
 
</span><span class="s2">class </span><span class="s1">ResourceContainer(ResourceBase): 
    is_container = </span><span class="s2">True     </span><span class="s0"># Backwards compatibility</span><span class="s1"> 
 
    @cached_property 
    </span><span class="s2">def </span><span class="s1">resources(self): 
        </span><span class="s2">return </span><span class="s1">self.finder.get_resources(self) 
 
 
</span><span class="s2">class </span><span class="s1">ResourceFinder(object): 
    </span><span class="s4">&quot;&quot;&quot; 
    Resource finder for file system resources. 
    &quot;&quot;&quot;</span><span class="s1"> 
 
    </span><span class="s2">if </span><span class="s1">sys.platform.startswith(</span><span class="s3">'java'</span><span class="s1">): 
        skipped_extensions = (</span><span class="s3">'.pyc'</span><span class="s2">, </span><span class="s3">'.pyo'</span><span class="s2">, </span><span class="s3">'.class'</span><span class="s1">) 
    </span><span class="s2">else</span><span class="s1">: 
        skipped_extensions = (</span><span class="s3">'.pyc'</span><span class="s2">, </span><span class="s3">'.pyo'</span><span class="s1">) 
 
    </span><span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">module): 
        self.module = module 
        self.loader = getattr(module</span><span class="s2">, </span><span class="s3">'__loader__'</span><span class="s2">, None</span><span class="s1">) 
        self.base = os.path.dirname(getattr(module</span><span class="s2">, </span><span class="s3">'__file__'</span><span class="s2">, </span><span class="s3">''</span><span class="s1">)) 
 
    </span><span class="s2">def </span><span class="s1">_adjust_path(self</span><span class="s2">, </span><span class="s1">path): 
        </span><span class="s2">return </span><span class="s1">os.path.realpath(path) 
 
    </span><span class="s2">def </span><span class="s1">_make_path(self</span><span class="s2">, </span><span class="s1">resource_name): 
        </span><span class="s0"># Issue #50: need to preserve type of path on Python 2.x</span><span class="s1"> 
        </span><span class="s0"># like os.path._get_sep</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">isinstance(resource_name</span><span class="s2">, </span><span class="s1">bytes):    </span><span class="s0"># should only happen on 2.x</span><span class="s1"> 
            sep = </span><span class="s5">b'/'</span><span class="s1"> 
        </span><span class="s2">else</span><span class="s1">: 
            sep = </span><span class="s3">'/'</span><span class="s1"> 
        parts = resource_name.split(sep) 
        parts.insert(</span><span class="s6">0</span><span class="s2">, </span><span class="s1">self.base) 
        result = os.path.join(*parts) 
        </span><span class="s2">return </span><span class="s1">self._adjust_path(result) 
 
    </span><span class="s2">def </span><span class="s1">_find(self</span><span class="s2">, </span><span class="s1">path): 
        </span><span class="s2">return </span><span class="s1">os.path.exists(path) 
 
    </span><span class="s2">def </span><span class="s1">get_cache_info(self</span><span class="s2">, </span><span class="s1">resource): 
        </span><span class="s2">return None, </span><span class="s1">resource.path 
 
    </span><span class="s2">def </span><span class="s1">find(self</span><span class="s2">, </span><span class="s1">resource_name): 
        path = self._make_path(resource_name) 
        </span><span class="s2">if not </span><span class="s1">self._find(path): 
            result = </span><span class="s2">None</span><span class="s1"> 
        </span><span class="s2">else</span><span class="s1">: 
            </span><span class="s2">if </span><span class="s1">self._is_directory(path): 
                result = ResourceContainer(self</span><span class="s2">, </span><span class="s1">resource_name) 
            </span><span class="s2">else</span><span class="s1">: 
                result = Resource(self</span><span class="s2">, </span><span class="s1">resource_name) 
            result.path = path 
        </span><span class="s2">return </span><span class="s1">result 
 
    </span><span class="s2">def </span><span class="s1">get_stream(self</span><span class="s2">, </span><span class="s1">resource): 
        </span><span class="s2">return </span><span class="s1">open(resource.path</span><span class="s2">, </span><span class="s3">'rb'</span><span class="s1">) 
 
    </span><span class="s2">def </span><span class="s1">get_bytes(self</span><span class="s2">, </span><span class="s1">resource): 
        </span><span class="s2">with </span><span class="s1">open(resource.path</span><span class="s2">, </span><span class="s3">'rb'</span><span class="s1">) </span><span class="s2">as </span><span class="s1">f: 
            </span><span class="s2">return </span><span class="s1">f.read() 
 
    </span><span class="s2">def </span><span class="s1">get_size(self</span><span class="s2">, </span><span class="s1">resource): 
        </span><span class="s2">return </span><span class="s1">os.path.getsize(resource.path) 
 
    </span><span class="s2">def </span><span class="s1">get_resources(self</span><span class="s2">, </span><span class="s1">resource): 
        </span><span class="s2">def </span><span class="s1">allowed(f): 
            </span><span class="s2">return </span><span class="s1">(f != </span><span class="s3">'__pycache__' </span><span class="s2">and not</span><span class="s1"> 
                    f.endswith(self.skipped_extensions)) 
        </span><span class="s2">return </span><span class="s1">set([f </span><span class="s2">for </span><span class="s1">f </span><span class="s2">in </span><span class="s1">os.listdir(resource.path) </span><span class="s2">if </span><span class="s1">allowed(f)]) 
 
    </span><span class="s2">def </span><span class="s1">is_container(self</span><span class="s2">, </span><span class="s1">resource): 
        </span><span class="s2">return </span><span class="s1">self._is_directory(resource.path) 
 
    _is_directory = staticmethod(os.path.isdir) 
 
    </span><span class="s2">def </span><span class="s1">iterator(self</span><span class="s2">, </span><span class="s1">resource_name): 
        resource = self.find(resource_name) 
        </span><span class="s2">if </span><span class="s1">resource </span><span class="s2">is not None</span><span class="s1">: 
            todo = [resource] 
            </span><span class="s2">while </span><span class="s1">todo: 
                resource = todo.pop(</span><span class="s6">0</span><span class="s1">) 
                </span><span class="s2">yield </span><span class="s1">resource 
                </span><span class="s2">if </span><span class="s1">resource.is_container: 
                    rname = resource.name 
                    </span><span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">resource.resources: 
                        </span><span class="s2">if not </span><span class="s1">rname: 
                            new_name = name 
                        </span><span class="s2">else</span><span class="s1">: 
                            new_name = </span><span class="s3">'/'</span><span class="s1">.join([rname</span><span class="s2">, </span><span class="s1">name]) 
                        child = self.find(new_name) 
                        </span><span class="s2">if </span><span class="s1">child.is_container: 
                            todo.append(child) 
                        </span><span class="s2">else</span><span class="s1">: 
                            </span><span class="s2">yield </span><span class="s1">child 
 
 
</span><span class="s2">class </span><span class="s1">ZipResourceFinder(ResourceFinder): 
    </span><span class="s4">&quot;&quot;&quot; 
    Resource finder for resources in .zip files. 
    &quot;&quot;&quot;</span><span class="s1"> 
    </span><span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">module): 
        super(ZipResourceFinder</span><span class="s2">, </span><span class="s1">self).__init__(module) 
        archive = self.loader.archive 
        self.prefix_len = </span><span class="s6">1 </span><span class="s1">+ len(archive) 
        </span><span class="s0"># PyPy doesn't have a _files attr on zipimporter, and you can't set one</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">hasattr(self.loader</span><span class="s2">, </span><span class="s3">'_files'</span><span class="s1">): 
            self._files = self.loader._files 
        </span><span class="s2">else</span><span class="s1">: 
            self._files = zipimport._zip_directory_cache[archive] 
        self.index = sorted(self._files) 
 
    </span><span class="s2">def </span><span class="s1">_adjust_path(self</span><span class="s2">, </span><span class="s1">path): 
        </span><span class="s2">return </span><span class="s1">path 
 
    </span><span class="s2">def </span><span class="s1">_find(self</span><span class="s2">, </span><span class="s1">path): 
        path = path[self.prefix_len:] 
        </span><span class="s2">if </span><span class="s1">path </span><span class="s2">in </span><span class="s1">self._files: 
            result = </span><span class="s2">True</span><span class="s1"> 
        </span><span class="s2">else</span><span class="s1">: 
            </span><span class="s2">if </span><span class="s1">path </span><span class="s2">and </span><span class="s1">path[-</span><span class="s6">1</span><span class="s1">] != os.sep: 
                path = path + os.sep 
            i = bisect.bisect(self.index</span><span class="s2">, </span><span class="s1">path) 
            </span><span class="s2">try</span><span class="s1">: 
                result = self.index[i].startswith(path) 
            </span><span class="s2">except </span><span class="s1">IndexError: 
                result = </span><span class="s2">False</span><span class="s1"> 
        </span><span class="s2">if not </span><span class="s1">result: 
            logger.debug(</span><span class="s3">'_find failed: %r %r'</span><span class="s2">, </span><span class="s1">path</span><span class="s2">, </span><span class="s1">self.loader.prefix) 
        </span><span class="s2">else</span><span class="s1">: 
            logger.debug(</span><span class="s3">'_find worked: %r %r'</span><span class="s2">, </span><span class="s1">path</span><span class="s2">, </span><span class="s1">self.loader.prefix) 
        </span><span class="s2">return </span><span class="s1">result 
 
    </span><span class="s2">def </span><span class="s1">get_cache_info(self</span><span class="s2">, </span><span class="s1">resource): 
        prefix = self.loader.archive 
        path = resource.path[</span><span class="s6">1 </span><span class="s1">+ len(prefix):] 
        </span><span class="s2">return </span><span class="s1">prefix</span><span class="s2">, </span><span class="s1">path 
 
    </span><span class="s2">def </span><span class="s1">get_bytes(self</span><span class="s2">, </span><span class="s1">resource): 
        </span><span class="s2">return </span><span class="s1">self.loader.get_data(resource.path) 
 
    </span><span class="s2">def </span><span class="s1">get_stream(self</span><span class="s2">, </span><span class="s1">resource): 
        </span><span class="s2">return </span><span class="s1">io.BytesIO(self.get_bytes(resource)) 
 
    </span><span class="s2">def </span><span class="s1">get_size(self</span><span class="s2">, </span><span class="s1">resource): 
        path = resource.path[self.prefix_len:] 
        </span><span class="s2">return </span><span class="s1">self._files[path][</span><span class="s6">3</span><span class="s1">] 
 
    </span><span class="s2">def </span><span class="s1">get_resources(self</span><span class="s2">, </span><span class="s1">resource): 
        path = resource.path[self.prefix_len:] 
        </span><span class="s2">if </span><span class="s1">path </span><span class="s2">and </span><span class="s1">path[-</span><span class="s6">1</span><span class="s1">] != os.sep: 
            path += os.sep 
        plen = len(path) 
        result = set() 
        i = bisect.bisect(self.index</span><span class="s2">, </span><span class="s1">path) 
        </span><span class="s2">while </span><span class="s1">i &lt; len(self.index): 
            </span><span class="s2">if not </span><span class="s1">self.index[i].startswith(path): 
                </span><span class="s2">break</span><span class="s1"> 
            s = self.index[i][plen:] 
            result.add(s.split(os.sep</span><span class="s2">, </span><span class="s6">1</span><span class="s1">)[</span><span class="s6">0</span><span class="s1">])   </span><span class="s0"># only immediate children</span><span class="s1"> 
            i += </span><span class="s6">1</span><span class="s1"> 
        </span><span class="s2">return </span><span class="s1">result 
 
    </span><span class="s2">def </span><span class="s1">_is_directory(self</span><span class="s2">, </span><span class="s1">path): 
        path = path[self.prefix_len:] 
        </span><span class="s2">if </span><span class="s1">path </span><span class="s2">and </span><span class="s1">path[-</span><span class="s6">1</span><span class="s1">] != os.sep: 
            path += os.sep 
        i = bisect.bisect(self.index</span><span class="s2">, </span><span class="s1">path) 
        </span><span class="s2">try</span><span class="s1">: 
            result = self.index[i].startswith(path) 
        </span><span class="s2">except </span><span class="s1">IndexError: 
            result = </span><span class="s2">False</span><span class="s1"> 
        </span><span class="s2">return </span><span class="s1">result 
 
_finder_registry = { 
    type(</span><span class="s2">None</span><span class="s1">): ResourceFinder</span><span class="s2">,</span><span class="s1"> 
    zipimport.zipimporter: ZipResourceFinder 
} 
 
</span><span class="s2">try</span><span class="s1">: 
    </span><span class="s0"># In Python 3.6, _frozen_importlib -&gt; _frozen_importlib_external</span><span class="s1"> 
    </span><span class="s2">try</span><span class="s1">: 
        </span><span class="s2">import </span><span class="s1">_frozen_importlib_external </span><span class="s2">as </span><span class="s1">_fi 
    </span><span class="s2">except </span><span class="s1">ImportError: 
        </span><span class="s2">import </span><span class="s1">_frozen_importlib </span><span class="s2">as </span><span class="s1">_fi 
    _finder_registry[_fi.SourceFileLoader] = ResourceFinder 
    _finder_registry[_fi.FileFinder] = ResourceFinder 
    </span><span class="s2">del </span><span class="s1">_fi 
</span><span class="s2">except </span><span class="s1">(ImportError</span><span class="s2">, </span><span class="s1">AttributeError): 
    </span><span class="s2">pass</span><span class="s1"> 
 
 
</span><span class="s2">def </span><span class="s1">register_finder(loader</span><span class="s2">, </span><span class="s1">finder_maker): 
    _finder_registry[type(loader)] = finder_maker 
 
_finder_cache = {} 
 
 
</span><span class="s2">def </span><span class="s1">finder(package): 
    </span><span class="s4">&quot;&quot;&quot; 
    Return a resource finder for a package. 
    :param package: The name of the package. 
    :return: A :class:`ResourceFinder` instance for the package. 
    &quot;&quot;&quot;</span><span class="s1"> 
    </span><span class="s2">if </span><span class="s1">package </span><span class="s2">in </span><span class="s1">_finder_cache: 
        result = _finder_cache[package] 
    </span><span class="s2">else</span><span class="s1">: 
        </span><span class="s2">if </span><span class="s1">package </span><span class="s2">not in </span><span class="s1">sys.modules: 
            __import__(package) 
        module = sys.modules[package] 
        path = getattr(module</span><span class="s2">, </span><span class="s3">'__path__'</span><span class="s2">, None</span><span class="s1">) 
        </span><span class="s2">if </span><span class="s1">path </span><span class="s2">is None</span><span class="s1">: 
            </span><span class="s2">raise </span><span class="s1">DistlibException(</span><span class="s3">'You cannot get a finder for a module, '</span><span class="s1"> 
                                   </span><span class="s3">'only for a package'</span><span class="s1">) 
        loader = getattr(module</span><span class="s2">, </span><span class="s3">'__loader__'</span><span class="s2">, None</span><span class="s1">) 
        finder_maker = _finder_registry.get(type(loader)) 
        </span><span class="s2">if </span><span class="s1">finder_maker </span><span class="s2">is None</span><span class="s1">: 
            </span><span class="s2">raise </span><span class="s1">DistlibException(</span><span class="s3">'Unable to locate finder for %r' </span><span class="s1">% package) 
        result = finder_maker(module) 
        _finder_cache[package] = result 
    </span><span class="s2">return </span><span class="s1">result 
 
 
_dummy_module = types.ModuleType(str(</span><span class="s3">'__dummy__'</span><span class="s1">)) 
 
 
</span><span class="s2">def </span><span class="s1">finder_for_path(path): 
    </span><span class="s4">&quot;&quot;&quot; 
    Return a resource finder for a path, which should represent a container. 
 
    :param path: The path. 
    :return: A :class:`ResourceFinder` instance for the path. 
    &quot;&quot;&quot;</span><span class="s1"> 
    result = </span><span class="s2">None</span><span class="s1"> 
    </span><span class="s0"># calls any path hooks, gets importer into cache</span><span class="s1"> 
    pkgutil.get_importer(path) 
    loader = sys.path_importer_cache.get(path) 
    finder = _finder_registry.get(type(loader)) 
    </span><span class="s2">if </span><span class="s1">finder: 
        module = _dummy_module 
        module.__file__ = os.path.join(path</span><span class="s2">, </span><span class="s3">''</span><span class="s1">) 
        module.__loader__ = loader 
        result = finder(module) 
    </span><span class="s2">return </span><span class="s1">result 
</span></pre>
</body>
</html>