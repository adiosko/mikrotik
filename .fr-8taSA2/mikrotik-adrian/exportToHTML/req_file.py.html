<html>
<head>
<title>req_file.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.ln { color: #606366; font-weight: normal; font-style: normal; }
.s0 { color: rgb(98,151,85); font-style: italic; }
.s1 { color: rgb(169,183,198); }
.s2 { color: rgb(204,120,50); }
.s3 { color: rgb(106,135,89); }
.s4 { color: rgb(128,128,128); }
.s5 { color: rgb(104,151,187); }
</style>
</head>
<BODY BGCOLOR="#2b2b2b">
<TABLE CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<TR><TD><CENTER>
<FONT FACE="Arial, Helvetica" COLOR="#000000">
req_file.py</FONT>
</center></TD></TR></TABLE>
<pre>
<span class="s0">&quot;&quot;&quot; 
Requirements file parsing 
&quot;&quot;&quot;</span><span class="s1"> 
 
</span><span class="s2">from </span><span class="s1">__future__ </span><span class="s2">import </span><span class="s1">absolute_import 
 
</span><span class="s2">import </span><span class="s1">os 
</span><span class="s2">import </span><span class="s1">re 
</span><span class="s2">import </span><span class="s1">shlex 
</span><span class="s2">import </span><span class="s1">sys 
</span><span class="s2">import </span><span class="s1">optparse 
</span><span class="s2">import </span><span class="s1">warnings 
 
</span><span class="s2">from </span><span class="s1">pip._vendor.six.moves.urllib </span><span class="s2">import </span><span class="s1">parse </span><span class="s2">as </span><span class="s1">urllib_parse 
</span><span class="s2">from </span><span class="s1">pip._vendor.six.moves </span><span class="s2">import </span><span class="s1">filterfalse 
 
</span><span class="s2">import </span><span class="s1">pip 
</span><span class="s2">from </span><span class="s1">pip.download </span><span class="s2">import </span><span class="s1">get_file_content 
</span><span class="s2">from </span><span class="s1">pip.req.req_install </span><span class="s2">import </span><span class="s1">InstallRequirement 
</span><span class="s2">from </span><span class="s1">pip.exceptions </span><span class="s2">import </span><span class="s1">(RequirementsFileParseError) 
</span><span class="s2">from </span><span class="s1">pip.utils.deprecation </span><span class="s2">import </span><span class="s1">RemovedInPip10Warning 
</span><span class="s2">from </span><span class="s1">pip </span><span class="s2">import </span><span class="s1">cmdoptions 
 
__all__ = [</span><span class="s3">'parse_requirements'</span><span class="s1">] 
 
SCHEME_RE = re.compile(</span><span class="s3">r'^(http|https|file):'</span><span class="s2">, </span><span class="s1">re.I) 
COMMENT_RE = re.compile(</span><span class="s3">r'(^|\s)+#.*$'</span><span class="s1">) 
 
SUPPORTED_OPTIONS = [ 
    cmdoptions.constraints</span><span class="s2">,</span><span class="s1"> 
    cmdoptions.editable</span><span class="s2">,</span><span class="s1"> 
    cmdoptions.requirements</span><span class="s2">,</span><span class="s1"> 
    cmdoptions.no_index</span><span class="s2">,</span><span class="s1"> 
    cmdoptions.index_url</span><span class="s2">,</span><span class="s1"> 
    cmdoptions.find_links</span><span class="s2">,</span><span class="s1"> 
    cmdoptions.extra_index_url</span><span class="s2">,</span><span class="s1"> 
    cmdoptions.allow_external</span><span class="s2">,</span><span class="s1"> 
    cmdoptions.allow_all_external</span><span class="s2">,</span><span class="s1"> 
    cmdoptions.no_allow_external</span><span class="s2">,</span><span class="s1"> 
    cmdoptions.allow_unsafe</span><span class="s2">,</span><span class="s1"> 
    cmdoptions.no_allow_unsafe</span><span class="s2">,</span><span class="s1"> 
    cmdoptions.use_wheel</span><span class="s2">,</span><span class="s1"> 
    cmdoptions.no_use_wheel</span><span class="s2">,</span><span class="s1"> 
    cmdoptions.always_unzip</span><span class="s2">,</span><span class="s1"> 
    cmdoptions.no_binary</span><span class="s2">,</span><span class="s1"> 
    cmdoptions.only_binary</span><span class="s2">,</span><span class="s1"> 
    cmdoptions.pre</span><span class="s2">,</span><span class="s1"> 
    cmdoptions.process_dependency_links</span><span class="s2">,</span><span class="s1"> 
    cmdoptions.trusted_host</span><span class="s2">,</span><span class="s1"> 
    cmdoptions.require_hashes</span><span class="s2">,</span><span class="s1"> 
] 
 
</span><span class="s4"># options to be passed to requirements</span><span class="s1"> 
SUPPORTED_OPTIONS_REQ = [ 
    cmdoptions.install_options</span><span class="s2">,</span><span class="s1"> 
    cmdoptions.global_options</span><span class="s2">,</span><span class="s1"> 
    cmdoptions.hash</span><span class="s2">,</span><span class="s1"> 
] 
 
</span><span class="s4"># the 'dest' string values</span><span class="s1"> 
SUPPORTED_OPTIONS_REQ_DEST = [o().dest </span><span class="s2">for </span><span class="s1">o </span><span class="s2">in </span><span class="s1">SUPPORTED_OPTIONS_REQ] 
 
 
</span><span class="s2">def </span><span class="s1">parse_requirements(filename</span><span class="s2">, </span><span class="s1">finder=</span><span class="s2">None, </span><span class="s1">comes_from=</span><span class="s2">None, </span><span class="s1">options=</span><span class="s2">None,</span><span class="s1"> 
                       session=</span><span class="s2">None, </span><span class="s1">constraint=</span><span class="s2">False, </span><span class="s1">wheel_cache=</span><span class="s2">None</span><span class="s1">): 
    </span><span class="s0">&quot;&quot;&quot;Parse a requirements file and yield InstallRequirement instances. 
 
    :param filename:    Path or url of requirements file. 
    :param finder:      Instance of pip.index.PackageFinder. 
    :param comes_from:  Origin description of requirements. 
    :param options:     cli options. 
    :param session:     Instance of pip.download.PipSession. 
    :param constraint:  If true, parsing a constraint file rather than 
        requirements file. 
    :param wheel_cache: Instance of pip.wheel.WheelCache 
    &quot;&quot;&quot;</span><span class="s1"> 
    </span><span class="s2">if </span><span class="s1">session </span><span class="s2">is None</span><span class="s1">: 
        </span><span class="s2">raise </span><span class="s1">TypeError( 
            </span><span class="s3">&quot;parse_requirements() missing 1 required keyword argument: &quot;</span><span class="s1"> 
            </span><span class="s3">&quot;'session'&quot;</span><span class="s1"> 
        ) 
 
    _</span><span class="s2">, </span><span class="s1">content = get_file_content( 
        filename</span><span class="s2">, </span><span class="s1">comes_from=comes_from</span><span class="s2">, </span><span class="s1">session=session 
    ) 
 
    lines_enum = preprocess(content</span><span class="s2">, </span><span class="s1">options) 
 
    </span><span class="s2">for </span><span class="s1">line_number</span><span class="s2">, </span><span class="s1">line </span><span class="s2">in </span><span class="s1">lines_enum: 
        req_iter = process_line(line</span><span class="s2">, </span><span class="s1">filename</span><span class="s2">, </span><span class="s1">line_number</span><span class="s2">, </span><span class="s1">finder</span><span class="s2">,</span><span class="s1"> 
                                comes_from</span><span class="s2">, </span><span class="s1">options</span><span class="s2">, </span><span class="s1">session</span><span class="s2">, </span><span class="s1">wheel_cache</span><span class="s2">,</span><span class="s1"> 
                                constraint=constraint) 
        </span><span class="s2">for </span><span class="s1">req </span><span class="s2">in </span><span class="s1">req_iter: 
            </span><span class="s2">yield </span><span class="s1">req 
 
 
</span><span class="s2">def </span><span class="s1">preprocess(content</span><span class="s2">, </span><span class="s1">options): 
    </span><span class="s0">&quot;&quot;&quot;Split, filter, and join lines, and return a line iterator 
 
    :param content: the content of the requirements file 
    :param options: cli options 
    &quot;&quot;&quot;</span><span class="s1"> 
    lines_enum = enumerate(content.splitlines()</span><span class="s2">, </span><span class="s1">start=</span><span class="s5">1</span><span class="s1">) 
    lines_enum = join_lines(lines_enum) 
    lines_enum = ignore_comments(lines_enum) 
    lines_enum = skip_regex(lines_enum</span><span class="s2">, </span><span class="s1">options) 
    </span><span class="s2">return </span><span class="s1">lines_enum 
 
 
</span><span class="s2">def </span><span class="s1">process_line(line</span><span class="s2">, </span><span class="s1">filename</span><span class="s2">, </span><span class="s1">line_number</span><span class="s2">, </span><span class="s1">finder=</span><span class="s2">None, </span><span class="s1">comes_from=</span><span class="s2">None,</span><span class="s1"> 
                 options=</span><span class="s2">None, </span><span class="s1">session=</span><span class="s2">None, </span><span class="s1">wheel_cache=</span><span class="s2">None,</span><span class="s1"> 
                 constraint=</span><span class="s2">False</span><span class="s1">): 
    </span><span class="s0">&quot;&quot;&quot;Process a single requirements line; This can result in creating/yielding 
    requirements, or updating the finder. 
 
    For lines that contain requirements, the only options that have an effect 
    are from SUPPORTED_OPTIONS_REQ, and they are scoped to the 
    requirement. Other options from SUPPORTED_OPTIONS may be present, but are 
    ignored. 
 
    For lines that do not contain requirements, the only options that have an 
    effect are from SUPPORTED_OPTIONS. Options from SUPPORTED_OPTIONS_REQ may 
    be present, but are ignored. These lines may contain multiple options 
    (although our docs imply only one is supported), and all our parsed and 
    affect the finder. 
 
    :param constraint: If True, parsing a constraints file. 
    :param options: OptionParser options that we may update 
    &quot;&quot;&quot;</span><span class="s1"> 
    parser = build_parser() 
    defaults = parser.get_default_values() 
    defaults.index_url = </span><span class="s2">None</span><span class="s1"> 
    </span><span class="s2">if </span><span class="s1">finder: 
        </span><span class="s4"># `finder.format_control` will be updated during parsing</span><span class="s1"> 
        defaults.format_control = finder.format_control 
    args_str</span><span class="s2">, </span><span class="s1">options_str = break_args_options(line) 
    </span><span class="s2">if </span><span class="s1">sys.version_info &lt; (</span><span class="s5">2</span><span class="s2">, </span><span class="s5">7</span><span class="s2">, </span><span class="s5">3</span><span class="s1">): 
        </span><span class="s4"># Prior to 2.7.3, shlex cannot deal with unicode entries</span><span class="s1"> 
        options_str = options_str.encode(</span><span class="s3">'utf8'</span><span class="s1">) 
    opts</span><span class="s2">, </span><span class="s1">_ = parser.parse_args(shlex.split(options_str)</span><span class="s2">, </span><span class="s1">defaults) 
 
    </span><span class="s4"># preserve for the nested code path</span><span class="s1"> 
    line_comes_from = </span><span class="s3">'%s %s (line %s)' </span><span class="s1">% ( 
        </span><span class="s3">'-c' </span><span class="s2">if </span><span class="s1">constraint </span><span class="s2">else </span><span class="s3">'-r'</span><span class="s2">, </span><span class="s1">filename</span><span class="s2">, </span><span class="s1">line_number) 
 
    </span><span class="s4"># yield a line requirement</span><span class="s1"> 
    </span><span class="s2">if </span><span class="s1">args_str: 
        isolated = options.isolated_mode </span><span class="s2">if </span><span class="s1">options </span><span class="s2">else False</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">options: 
            cmdoptions.check_install_build_global(options</span><span class="s2">, </span><span class="s1">opts) 
        </span><span class="s4"># get the options that apply to requirements</span><span class="s1"> 
        req_options = {} 
        </span><span class="s2">for </span><span class="s1">dest </span><span class="s2">in </span><span class="s1">SUPPORTED_OPTIONS_REQ_DEST: 
            </span><span class="s2">if </span><span class="s1">dest </span><span class="s2">in </span><span class="s1">opts.__dict__ </span><span class="s2">and </span><span class="s1">opts.__dict__[dest]: 
                req_options[dest] = opts.__dict__[dest] 
        </span><span class="s2">yield </span><span class="s1">InstallRequirement.from_line( 
            args_str</span><span class="s2">, </span><span class="s1">line_comes_from</span><span class="s2">, </span><span class="s1">constraint=constraint</span><span class="s2">,</span><span class="s1"> 
            isolated=isolated</span><span class="s2">, </span><span class="s1">options=req_options</span><span class="s2">, </span><span class="s1">wheel_cache=wheel_cache 
        ) 
 
    </span><span class="s4"># yield an editable requirement</span><span class="s1"> 
    </span><span class="s2">elif </span><span class="s1">opts.editables: 
        isolated = options.isolated_mode </span><span class="s2">if </span><span class="s1">options </span><span class="s2">else False</span><span class="s1"> 
        default_vcs = options.default_vcs </span><span class="s2">if </span><span class="s1">options </span><span class="s2">else None</span><span class="s1"> 
        </span><span class="s2">yield </span><span class="s1">InstallRequirement.from_editable( 
            opts.editables[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">comes_from=line_comes_from</span><span class="s2">,</span><span class="s1"> 
            constraint=constraint</span><span class="s2">, </span><span class="s1">default_vcs=default_vcs</span><span class="s2">, </span><span class="s1">isolated=isolated</span><span class="s2">,</span><span class="s1"> 
            wheel_cache=wheel_cache 
        ) 
 
    </span><span class="s4"># parse a nested requirements file</span><span class="s1"> 
    </span><span class="s2">elif </span><span class="s1">opts.requirements </span><span class="s2">or </span><span class="s1">opts.constraints: 
        </span><span class="s2">if </span><span class="s1">opts.requirements: 
            req_path = opts.requirements[</span><span class="s5">0</span><span class="s1">] 
            nested_constraint = </span><span class="s2">False</span><span class="s1"> 
        </span><span class="s2">else</span><span class="s1">: 
            req_path = opts.constraints[</span><span class="s5">0</span><span class="s1">] 
            nested_constraint = </span><span class="s2">True</span><span class="s1"> 
        </span><span class="s4"># original file is over http</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">SCHEME_RE.search(filename): 
            </span><span class="s4"># do a url join so relative paths work</span><span class="s1"> 
            req_path = urllib_parse.urljoin(filename</span><span class="s2">, </span><span class="s1">req_path) 
        </span><span class="s4"># original file and nested file are paths</span><span class="s1"> 
        </span><span class="s2">elif not </span><span class="s1">SCHEME_RE.search(req_path): 
            </span><span class="s4"># do a join so relative paths work</span><span class="s1"> 
            req_path = os.path.join(os.path.dirname(filename)</span><span class="s2">, </span><span class="s1">req_path) 
        </span><span class="s4"># TODO: Why not use `comes_from='-r {} (line {})'` here as well?</span><span class="s1"> 
        parser = parse_requirements( 
            req_path</span><span class="s2">, </span><span class="s1">finder</span><span class="s2">, </span><span class="s1">comes_from</span><span class="s2">, </span><span class="s1">options</span><span class="s2">, </span><span class="s1">session</span><span class="s2">,</span><span class="s1"> 
            constraint=nested_constraint</span><span class="s2">, </span><span class="s1">wheel_cache=wheel_cache 
        ) 
        </span><span class="s2">for </span><span class="s1">req </span><span class="s2">in </span><span class="s1">parser: 
            </span><span class="s2">yield </span><span class="s1">req 
 
    </span><span class="s4"># percolate hash-checking option upward</span><span class="s1"> 
    </span><span class="s2">elif </span><span class="s1">opts.require_hashes: 
        options.require_hashes = opts.require_hashes 
 
    </span><span class="s4"># set finder options</span><span class="s1"> 
    </span><span class="s2">elif </span><span class="s1">finder: 
        </span><span class="s2">if </span><span class="s1">opts.allow_external: 
            warnings.warn( 
                </span><span class="s3">&quot;--allow-external has been deprecated and will be removed in &quot;</span><span class="s1"> 
                </span><span class="s3">&quot;the future. Due to changes in the repository protocol, it no &quot;</span><span class="s1"> 
                </span><span class="s3">&quot;longer has any effect.&quot;</span><span class="s2">,</span><span class="s1"> 
                RemovedInPip10Warning</span><span class="s2">,</span><span class="s1"> 
            ) 
 
        </span><span class="s2">if </span><span class="s1">opts.allow_all_external: 
            warnings.warn( 
                </span><span class="s3">&quot;--allow-all-external has been deprecated and will be removed &quot;</span><span class="s1"> 
                </span><span class="s3">&quot;in the future. Due to changes in the repository protocol, it &quot;</span><span class="s1"> 
                </span><span class="s3">&quot;no longer has any effect.&quot;</span><span class="s2">,</span><span class="s1"> 
                RemovedInPip10Warning</span><span class="s2">,</span><span class="s1"> 
            ) 
 
        </span><span class="s2">if </span><span class="s1">opts.allow_unverified: 
            warnings.warn( 
                </span><span class="s3">&quot;--allow-unverified has been deprecated and will be removed &quot;</span><span class="s1"> 
                </span><span class="s3">&quot;in the future. Due to changes in the repository protocol, it &quot;</span><span class="s1"> 
                </span><span class="s3">&quot;no longer has any effect.&quot;</span><span class="s2">,</span><span class="s1"> 
                RemovedInPip10Warning</span><span class="s2">,</span><span class="s1"> 
            ) 
 
        </span><span class="s2">if </span><span class="s1">opts.index_url: 
            finder.index_urls = [opts.index_url] 
        </span><span class="s2">if </span><span class="s1">opts.use_wheel </span><span class="s2">is False</span><span class="s1">: 
            finder.use_wheel = </span><span class="s2">False</span><span class="s1"> 
            pip.index.fmt_ctl_no_use_wheel(finder.format_control) 
        </span><span class="s2">if </span><span class="s1">opts.no_index </span><span class="s2">is True</span><span class="s1">: 
            finder.index_urls = [] 
        </span><span class="s2">if </span><span class="s1">opts.extra_index_urls: 
            finder.index_urls.extend(opts.extra_index_urls) 
        </span><span class="s2">if </span><span class="s1">opts.find_links: 
            </span><span class="s4"># FIXME: it would be nice to keep track of the source</span><span class="s1"> 
            </span><span class="s4"># of the find_links: support a find-links local path</span><span class="s1"> 
            </span><span class="s4"># relative to a requirements file.</span><span class="s1"> 
            value = opts.find_links[</span><span class="s5">0</span><span class="s1">] 
            req_dir = os.path.dirname(os.path.abspath(filename)) 
            relative_to_reqs_file = os.path.join(req_dir</span><span class="s2">, </span><span class="s1">value) 
            </span><span class="s2">if </span><span class="s1">os.path.exists(relative_to_reqs_file): 
                value = relative_to_reqs_file 
            finder.find_links.append(value) 
        </span><span class="s2">if </span><span class="s1">opts.pre: 
            finder.allow_all_prereleases = </span><span class="s2">True</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">opts.process_dependency_links: 
            finder.process_dependency_links = </span><span class="s2">True</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">opts.trusted_hosts: 
            finder.secure_origins.extend( 
                (</span><span class="s3">&quot;*&quot;</span><span class="s2">, </span><span class="s1">host</span><span class="s2">, </span><span class="s3">&quot;*&quot;</span><span class="s1">) </span><span class="s2">for </span><span class="s1">host </span><span class="s2">in </span><span class="s1">opts.trusted_hosts) 
 
 
</span><span class="s2">def </span><span class="s1">break_args_options(line): 
    </span><span class="s0">&quot;&quot;&quot;Break up the line into an args and options string.  We only want to shlex 
    (and then optparse) the options, not the args.  args can contain markers 
    which are corrupted by shlex. 
    &quot;&quot;&quot;</span><span class="s1"> 
    tokens = line.split(</span><span class="s3">' '</span><span class="s1">) 
    args = [] 
    options = tokens[:] 
    </span><span class="s2">for </span><span class="s1">token </span><span class="s2">in </span><span class="s1">tokens: 
        </span><span class="s2">if </span><span class="s1">token.startswith(</span><span class="s3">'-'</span><span class="s1">) </span><span class="s2">or </span><span class="s1">token.startswith(</span><span class="s3">'--'</span><span class="s1">): 
            </span><span class="s2">break</span><span class="s1"> 
        </span><span class="s2">else</span><span class="s1">: 
            args.append(token) 
            options.pop(</span><span class="s5">0</span><span class="s1">) 
    </span><span class="s2">return </span><span class="s3">' '</span><span class="s1">.join(args)</span><span class="s2">, </span><span class="s3">' '</span><span class="s1">.join(options) 
 
 
</span><span class="s2">def </span><span class="s1">build_parser(): 
    </span><span class="s0">&quot;&quot;&quot; 
    Return a parser for parsing requirement lines 
    &quot;&quot;&quot;</span><span class="s1"> 
    parser = optparse.OptionParser(add_help_option=</span><span class="s2">False</span><span class="s1">) 
 
    option_factories = SUPPORTED_OPTIONS + SUPPORTED_OPTIONS_REQ 
    </span><span class="s2">for </span><span class="s1">option_factory </span><span class="s2">in </span><span class="s1">option_factories: 
        option = option_factory() 
        parser.add_option(option) 
 
    </span><span class="s4"># By default optparse sys.exits on parsing errors. We want to wrap</span><span class="s1"> 
    </span><span class="s4"># that in our own exception.</span><span class="s1"> 
    </span><span class="s2">def </span><span class="s1">parser_exit(self</span><span class="s2">, </span><span class="s1">msg): 
        </span><span class="s2">raise </span><span class="s1">RequirementsFileParseError(msg) 
    parser.exit = parser_exit 
 
    </span><span class="s2">return </span><span class="s1">parser 
 
 
</span><span class="s2">def </span><span class="s1">join_lines(lines_enum): 
    </span><span class="s0">&quot;&quot;&quot;Joins a line ending in '\' with the previous line (except when following 
    comments).  The joined line takes on the index of the first line. 
    &quot;&quot;&quot;</span><span class="s1"> 
    primary_line_number = </span><span class="s2">None</span><span class="s1"> 
    new_line = [] 
    </span><span class="s2">for </span><span class="s1">line_number</span><span class="s2">, </span><span class="s1">line </span><span class="s2">in </span><span class="s1">lines_enum: 
        </span><span class="s2">if not </span><span class="s1">line.endswith(</span><span class="s3">'</span><span class="s2">\\</span><span class="s3">'</span><span class="s1">) </span><span class="s2">or </span><span class="s1">COMMENT_RE.match(line): 
            </span><span class="s2">if </span><span class="s1">COMMENT_RE.match(line): 
                </span><span class="s4"># this ensures comments are always matched later</span><span class="s1"> 
                line = </span><span class="s3">' ' </span><span class="s1">+ line 
            </span><span class="s2">if </span><span class="s1">new_line: 
                new_line.append(line) 
                </span><span class="s2">yield </span><span class="s1">primary_line_number</span><span class="s2">, </span><span class="s3">''</span><span class="s1">.join(new_line) 
                new_line = [] 
            </span><span class="s2">else</span><span class="s1">: 
                </span><span class="s2">yield </span><span class="s1">line_number</span><span class="s2">, </span><span class="s1">line 
        </span><span class="s2">else</span><span class="s1">: 
            </span><span class="s2">if not </span><span class="s1">new_line: 
                primary_line_number = line_number 
            new_line.append(line.strip(</span><span class="s3">'</span><span class="s2">\\</span><span class="s3">'</span><span class="s1">)) 
 
    </span><span class="s4"># last line contains \</span><span class="s1"> 
    </span><span class="s2">if </span><span class="s1">new_line: 
        </span><span class="s2">yield </span><span class="s1">primary_line_number</span><span class="s2">, </span><span class="s3">''</span><span class="s1">.join(new_line) 
 
    </span><span class="s4"># TODO: handle space after '\'.</span><span class="s1"> 
 
 
</span><span class="s2">def </span><span class="s1">ignore_comments(lines_enum): 
    </span><span class="s0">&quot;&quot;&quot; 
    Strips comments and filter empty lines. 
    &quot;&quot;&quot;</span><span class="s1"> 
    </span><span class="s2">for </span><span class="s1">line_number</span><span class="s2">, </span><span class="s1">line </span><span class="s2">in </span><span class="s1">lines_enum: 
        line = COMMENT_RE.sub(</span><span class="s3">''</span><span class="s2">, </span><span class="s1">line) 
        line = line.strip() 
        </span><span class="s2">if </span><span class="s1">line: 
            </span><span class="s2">yield </span><span class="s1">line_number</span><span class="s2">, </span><span class="s1">line 
 
 
</span><span class="s2">def </span><span class="s1">skip_regex(lines_enum</span><span class="s2">, </span><span class="s1">options): 
    </span><span class="s0">&quot;&quot;&quot; 
    Skip lines that match '--skip-requirements-regex' pattern 
 
    Note: the regex pattern is only built once 
    &quot;&quot;&quot;</span><span class="s1"> 
    skip_regex = options.skip_requirements_regex </span><span class="s2">if </span><span class="s1">options </span><span class="s2">else None</span><span class="s1"> 
    </span><span class="s2">if </span><span class="s1">skip_regex: 
        pattern = re.compile(skip_regex) 
        lines_enum = filterfalse( 
            </span><span class="s2">lambda </span><span class="s1">e: pattern.search(e[</span><span class="s5">1</span><span class="s1">])</span><span class="s2">,</span><span class="s1"> 
            lines_enum) 
    </span><span class="s2">return </span><span class="s1">lines_enum 
</span></pre>
</body>
</html>