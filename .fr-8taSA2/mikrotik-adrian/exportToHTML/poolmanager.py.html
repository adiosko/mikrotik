<html>
<head>
<title>poolmanager.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.ln { color: #606366; font-weight: normal; font-style: normal; }
.s0 { color: rgb(204,120,50); }
.s1 { color: rgb(169,183,198); }
.s2 { color: rgb(128,128,128); }
.s3 { color: rgb(106,135,89); }
.s4 { color: rgb(98,151,85); font-style: italic; }
.s5 { color: rgb(104,151,187); }
</style>
</head>
<BODY BGCOLOR="#2b2b2b">
<TABLE CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<TR><TD><CENTER>
<FONT FACE="Arial, Helvetica" COLOR="#000000">
poolmanager.py</FONT>
</center></TD></TR></TABLE>
<pre>
<span class="s0">from </span><span class="s1">__future__ </span><span class="s0">import </span><span class="s1">absolute_import 
</span><span class="s0">import </span><span class="s1">collections 
</span><span class="s0">import </span><span class="s1">functools 
</span><span class="s0">import </span><span class="s1">logging 
 
</span><span class="s0">try</span><span class="s1">:  </span><span class="s2"># Python 3</span><span class="s1"> 
    </span><span class="s0">from </span><span class="s1">urllib.parse </span><span class="s0">import </span><span class="s1">urljoin 
</span><span class="s0">except </span><span class="s1">ImportError: 
    </span><span class="s0">from </span><span class="s1">urlparse </span><span class="s0">import </span><span class="s1">urljoin 
 
</span><span class="s0">from </span><span class="s1">._collections </span><span class="s0">import </span><span class="s1">RecentlyUsedContainer 
</span><span class="s0">from </span><span class="s1">.connectionpool </span><span class="s0">import </span><span class="s1">HTTPConnectionPool</span><span class="s0">, </span><span class="s1">HTTPSConnectionPool 
</span><span class="s0">from </span><span class="s1">.connectionpool </span><span class="s0">import </span><span class="s1">port_by_scheme 
</span><span class="s0">from </span><span class="s1">.exceptions </span><span class="s0">import </span><span class="s1">LocationValueError</span><span class="s0">, </span><span class="s1">MaxRetryError</span><span class="s0">, </span><span class="s1">ProxySchemeUnknown 
</span><span class="s0">from </span><span class="s1">.request </span><span class="s0">import </span><span class="s1">RequestMethods 
</span><span class="s0">from </span><span class="s1">.util.url </span><span class="s0">import </span><span class="s1">parse_url 
</span><span class="s0">from </span><span class="s1">.util.retry </span><span class="s0">import </span><span class="s1">Retry 
 
 
__all__ = [</span><span class="s3">'PoolManager'</span><span class="s0">, </span><span class="s3">'ProxyManager'</span><span class="s0">, </span><span class="s3">'proxy_from_url'</span><span class="s1">] 
 
 
log = logging.getLogger(__name__) 
 
SSL_KEYWORDS = (</span><span class="s3">'key_file'</span><span class="s0">, </span><span class="s3">'cert_file'</span><span class="s0">, </span><span class="s3">'cert_reqs'</span><span class="s0">, </span><span class="s3">'ca_certs'</span><span class="s0">,</span><span class="s1"> 
                </span><span class="s3">'ssl_version'</span><span class="s0">, </span><span class="s3">'ca_cert_dir'</span><span class="s1">) 
 
</span><span class="s2"># The base fields to use when determining what pool to get a connection from;</span><span class="s1"> 
</span><span class="s2"># these do not rely on the ``connection_pool_kw`` and can be determined by the</span><span class="s1"> 
</span><span class="s2"># URL and potentially the ``urllib3.connection.port_by_scheme`` dictionary.</span><span class="s1"> 
</span><span class="s2">#</span><span class="s1"> 
</span><span class="s2"># All custom key schemes should include the fields in this key at a minimum.</span><span class="s1"> 
BasePoolKey = collections.namedtuple(</span><span class="s3">'BasePoolKey'</span><span class="s0">, </span><span class="s1">(</span><span class="s3">'scheme'</span><span class="s0">, </span><span class="s3">'host'</span><span class="s0">, </span><span class="s3">'port'</span><span class="s1">)) 
 
</span><span class="s2"># The fields to use when determining what pool to get a HTTP and HTTPS</span><span class="s1"> 
</span><span class="s2"># connection from. All additional fields must be present in the PoolManager's</span><span class="s1"> 
</span><span class="s2"># ``connection_pool_kw`` instance variable.</span><span class="s1"> 
HTTPPoolKey = collections.namedtuple( 
    </span><span class="s3">'HTTPPoolKey'</span><span class="s0">, </span><span class="s1">BasePoolKey._fields + (</span><span class="s3">'timeout'</span><span class="s0">, </span><span class="s3">'retries'</span><span class="s0">, </span><span class="s3">'strict'</span><span class="s0">,</span><span class="s1"> 
                                          </span><span class="s3">'block'</span><span class="s0">, </span><span class="s3">'source_address'</span><span class="s1">) 
) 
HTTPSPoolKey = collections.namedtuple( 
    </span><span class="s3">'HTTPSPoolKey'</span><span class="s0">, </span><span class="s1">HTTPPoolKey._fields + SSL_KEYWORDS 
) 
 
 
</span><span class="s0">def </span><span class="s1">_default_key_normalizer(key_class</span><span class="s0">, </span><span class="s1">request_context): 
    </span><span class="s4">&quot;&quot;&quot; 
    Create a pool key of type ``key_class`` for a request. 
 
    According to RFC 3986, both the scheme and host are case-insensitive. 
    Therefore, this function normalizes both before constructing the pool 
    key for an HTTPS request. If you wish to change this behaviour, provide 
    alternate callables to ``key_fn_by_scheme``. 
 
    :param key_class: 
        The class to use when constructing the key. This should be a namedtuple 
        with the ``scheme`` and ``host`` keys at a minimum. 
 
    :param request_context: 
        A dictionary-like object that contain the context for a request. 
        It should contain a key for each field in the :class:`HTTPPoolKey` 
    &quot;&quot;&quot;</span><span class="s1"> 
    context = {} 
    </span><span class="s0">for </span><span class="s1">key </span><span class="s0">in </span><span class="s1">key_class._fields: 
        context[key] = request_context.get(key) 
    context[</span><span class="s3">'scheme'</span><span class="s1">] = context[</span><span class="s3">'scheme'</span><span class="s1">].lower() 
    context[</span><span class="s3">'host'</span><span class="s1">] = context[</span><span class="s3">'host'</span><span class="s1">].lower() 
    </span><span class="s0">return </span><span class="s1">key_class(**context) 
 
 
</span><span class="s2"># A dictionary that maps a scheme to a callable that creates a pool key.</span><span class="s1"> 
</span><span class="s2"># This can be used to alter the way pool keys are constructed, if desired.</span><span class="s1"> 
</span><span class="s2"># Each PoolManager makes a copy of this dictionary so they can be configured</span><span class="s1"> 
</span><span class="s2"># globally here, or individually on the instance.</span><span class="s1"> 
key_fn_by_scheme = { 
    </span><span class="s3">'http'</span><span class="s1">: functools.partial(_default_key_normalizer</span><span class="s0">, </span><span class="s1">HTTPPoolKey)</span><span class="s0">,</span><span class="s1"> 
    </span><span class="s3">'https'</span><span class="s1">: functools.partial(_default_key_normalizer</span><span class="s0">, </span><span class="s1">HTTPSPoolKey)</span><span class="s0">,</span><span class="s1"> 
} 
 
pool_classes_by_scheme = { 
    </span><span class="s3">'http'</span><span class="s1">: HTTPConnectionPool</span><span class="s0">,</span><span class="s1"> 
    </span><span class="s3">'https'</span><span class="s1">: HTTPSConnectionPool</span><span class="s0">,</span><span class="s1"> 
} 
 
 
</span><span class="s0">class </span><span class="s1">PoolManager(RequestMethods): 
    </span><span class="s4">&quot;&quot;&quot; 
    Allows for arbitrary requests while transparently keeping track of 
    necessary connection pools for you. 
 
    :param num_pools: 
        Number of connection pools to cache before discarding the least 
        recently used pool. 
 
    :param headers: 
        Headers to include with all requests, unless other headers are given 
        explicitly. 
 
    :param \**connection_pool_kw: 
        Additional parameters are used to create fresh 
        :class:`urllib3.connectionpool.ConnectionPool` instances. 
 
    Example:: 
 
        &gt;&gt;&gt; manager = PoolManager(num_pools=2) 
        &gt;&gt;&gt; r = manager.request('GET', 'http://google.com/') 
        &gt;&gt;&gt; r = manager.request('GET', 'http://google.com/mail') 
        &gt;&gt;&gt; r = manager.request('GET', 'http://yahoo.com/') 
        &gt;&gt;&gt; len(manager.pools) 
        2 
 
    &quot;&quot;&quot;</span><span class="s1"> 
 
    proxy = </span><span class="s0">None</span><span class="s1"> 
 
    </span><span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">num_pools=</span><span class="s5">10</span><span class="s0">, </span><span class="s1">headers=</span><span class="s0">None, </span><span class="s1">**connection_pool_kw): 
        RequestMethods.__init__(self</span><span class="s0">, </span><span class="s1">headers) 
        self.connection_pool_kw = connection_pool_kw 
        self.pools = RecentlyUsedContainer(num_pools</span><span class="s0">,</span><span class="s1"> 
                                           dispose_func=</span><span class="s0">lambda </span><span class="s1">p: p.close()) 
 
        </span><span class="s2"># Locally set the pool classes and keys so other PoolManagers can</span><span class="s1"> 
        </span><span class="s2"># override them.</span><span class="s1"> 
        self.pool_classes_by_scheme = pool_classes_by_scheme 
        self.key_fn_by_scheme = key_fn_by_scheme.copy() 
 
    </span><span class="s0">def </span><span class="s1">__enter__(self): 
        </span><span class="s0">return </span><span class="s1">self 
 
    </span><span class="s0">def </span><span class="s1">__exit__(self</span><span class="s0">, </span><span class="s1">exc_type</span><span class="s0">, </span><span class="s1">exc_val</span><span class="s0">, </span><span class="s1">exc_tb): 
        self.clear() 
        </span><span class="s2"># Return False to re-raise any potential exceptions</span><span class="s1"> 
        </span><span class="s0">return False</span><span class="s1"> 
 
    </span><span class="s0">def </span><span class="s1">_new_pool(self</span><span class="s0">, </span><span class="s1">scheme</span><span class="s0">, </span><span class="s1">host</span><span class="s0">, </span><span class="s1">port): 
        </span><span class="s4">&quot;&quot;&quot; 
        Create a new :class:`ConnectionPool` based on host, port and scheme. 
 
        This method is used to actually create the connection pools handed out 
        by :meth:`connection_from_url` and companion methods. It is intended 
        to be overridden for customization. 
        &quot;&quot;&quot;</span><span class="s1"> 
        pool_cls = self.pool_classes_by_scheme[scheme] 
        kwargs = self.connection_pool_kw 
        </span><span class="s0">if </span><span class="s1">scheme == </span><span class="s3">'http'</span><span class="s1">: 
            kwargs = self.connection_pool_kw.copy() 
            </span><span class="s0">for </span><span class="s1">kw </span><span class="s0">in </span><span class="s1">SSL_KEYWORDS: 
                kwargs.pop(kw</span><span class="s0">, None</span><span class="s1">) 
 
        </span><span class="s0">return </span><span class="s1">pool_cls(host</span><span class="s0">, </span><span class="s1">port</span><span class="s0">, </span><span class="s1">**kwargs) 
 
    </span><span class="s0">def </span><span class="s1">clear(self): 
        </span><span class="s4">&quot;&quot;&quot; 
        Empty our store of pools and direct them all to close. 
 
        This will not affect in-flight connections, but they will not be 
        re-used after completion. 
        &quot;&quot;&quot;</span><span class="s1"> 
        self.pools.clear() 
 
    </span><span class="s0">def </span><span class="s1">connection_from_host(self</span><span class="s0">, </span><span class="s1">host</span><span class="s0">, </span><span class="s1">port=</span><span class="s0">None, </span><span class="s1">scheme=</span><span class="s3">'http'</span><span class="s1">): 
        </span><span class="s4">&quot;&quot;&quot; 
        Get a :class:`ConnectionPool` based on the host, port, and scheme. 
 
        If ``port`` isn't given, it will be derived from the ``scheme`` using 
        ``urllib3.connectionpool.port_by_scheme``. 
        &quot;&quot;&quot;</span><span class="s1"> 
 
        </span><span class="s0">if not </span><span class="s1">host: 
            </span><span class="s0">raise </span><span class="s1">LocationValueError(</span><span class="s3">&quot;No host specified.&quot;</span><span class="s1">) 
 
        request_context = self.connection_pool_kw.copy() 
        request_context[</span><span class="s3">'scheme'</span><span class="s1">] = scheme </span><span class="s0">or </span><span class="s3">'http'</span><span class="s1"> 
        </span><span class="s0">if not </span><span class="s1">port: 
            port = port_by_scheme.get(request_context[</span><span class="s3">'scheme'</span><span class="s1">].lower()</span><span class="s0">, </span><span class="s5">80</span><span class="s1">) 
        request_context[</span><span class="s3">'port'</span><span class="s1">] = port 
        request_context[</span><span class="s3">'host'</span><span class="s1">] = host 
 
        </span><span class="s0">return </span><span class="s1">self.connection_from_context(request_context) 
 
    </span><span class="s0">def </span><span class="s1">connection_from_context(self</span><span class="s0">, </span><span class="s1">request_context): 
        </span><span class="s4">&quot;&quot;&quot; 
        Get a :class:`ConnectionPool` based on the request context. 
 
        ``request_context`` must at least contain the ``scheme`` key and its 
        value must be a key in ``key_fn_by_scheme`` instance variable. 
        &quot;&quot;&quot;</span><span class="s1"> 
        scheme = request_context[</span><span class="s3">'scheme'</span><span class="s1">].lower() 
        pool_key_constructor = self.key_fn_by_scheme[scheme] 
        pool_key = pool_key_constructor(request_context) 
 
        </span><span class="s0">return </span><span class="s1">self.connection_from_pool_key(pool_key) 
 
    </span><span class="s0">def </span><span class="s1">connection_from_pool_key(self</span><span class="s0">, </span><span class="s1">pool_key): 
        </span><span class="s4">&quot;&quot;&quot; 
        Get a :class:`ConnectionPool` based on the provided pool key. 
 
        ``pool_key`` should be a namedtuple that only contains immutable 
        objects. At a minimum it must have the ``scheme``, ``host``, and 
        ``port`` fields. 
        &quot;&quot;&quot;</span><span class="s1"> 
        </span><span class="s0">with </span><span class="s1">self.pools.lock: 
            </span><span class="s2"># If the scheme, host, or port doesn't match existing open</span><span class="s1"> 
            </span><span class="s2"># connections, open a new ConnectionPool.</span><span class="s1"> 
            pool = self.pools.get(pool_key) 
            </span><span class="s0">if </span><span class="s1">pool: 
                </span><span class="s0">return </span><span class="s1">pool 
 
            </span><span class="s2"># Make a fresh ConnectionPool of the desired type</span><span class="s1"> 
            pool = self._new_pool(pool_key.scheme</span><span class="s0">, </span><span class="s1">pool_key.host</span><span class="s0">, </span><span class="s1">pool_key.port) 
            self.pools[pool_key] = pool 
 
        </span><span class="s0">return </span><span class="s1">pool 
 
    </span><span class="s0">def </span><span class="s1">connection_from_url(self</span><span class="s0">, </span><span class="s1">url): 
        </span><span class="s4">&quot;&quot;&quot; 
        Similar to :func:`urllib3.connectionpool.connection_from_url` but 
        doesn't pass any additional parameters to the 
        :class:`urllib3.connectionpool.ConnectionPool` constructor. 
 
        Additional parameters are taken from the :class:`.PoolManager` 
        constructor. 
        &quot;&quot;&quot;</span><span class="s1"> 
        u = parse_url(url) 
        </span><span class="s0">return </span><span class="s1">self.connection_from_host(u.host</span><span class="s0">, </span><span class="s1">port=u.port</span><span class="s0">, </span><span class="s1">scheme=u.scheme) 
 
    </span><span class="s0">def </span><span class="s1">urlopen(self</span><span class="s0">, </span><span class="s1">method</span><span class="s0">, </span><span class="s1">url</span><span class="s0">, </span><span class="s1">redirect=</span><span class="s0">True, </span><span class="s1">**kw): 
        </span><span class="s4">&quot;&quot;&quot; 
        Same as :meth:`urllib3.connectionpool.HTTPConnectionPool.urlopen` 
        with custom cross-host redirect logic and only sends the request-uri 
        portion of the ``url``. 
 
        The given ``url`` parameter must be absolute, such that an appropriate 
        :class:`urllib3.connectionpool.ConnectionPool` can be chosen for it. 
        &quot;&quot;&quot;</span><span class="s1"> 
        u = parse_url(url) 
        conn = self.connection_from_host(u.host</span><span class="s0">, </span><span class="s1">port=u.port</span><span class="s0">, </span><span class="s1">scheme=u.scheme) 
 
        kw[</span><span class="s3">'assert_same_host'</span><span class="s1">] = </span><span class="s0">False</span><span class="s1"> 
        kw[</span><span class="s3">'redirect'</span><span class="s1">] = </span><span class="s0">False</span><span class="s1"> 
        </span><span class="s0">if </span><span class="s3">'headers' </span><span class="s0">not in </span><span class="s1">kw: 
            kw[</span><span class="s3">'headers'</span><span class="s1">] = self.headers 
 
        </span><span class="s0">if </span><span class="s1">self.proxy </span><span class="s0">is not None and </span><span class="s1">u.scheme == </span><span class="s3">&quot;http&quot;</span><span class="s1">: 
            response = conn.urlopen(method</span><span class="s0">, </span><span class="s1">url</span><span class="s0">, </span><span class="s1">**kw) 
        </span><span class="s0">else</span><span class="s1">: 
            response = conn.urlopen(method</span><span class="s0">, </span><span class="s1">u.request_uri</span><span class="s0">, </span><span class="s1">**kw) 
 
        redirect_location = redirect </span><span class="s0">and </span><span class="s1">response.get_redirect_location() 
        </span><span class="s0">if not </span><span class="s1">redirect_location: 
            </span><span class="s0">return </span><span class="s1">response 
 
        </span><span class="s2"># Support relative URLs for redirecting.</span><span class="s1"> 
        redirect_location = urljoin(url</span><span class="s0">, </span><span class="s1">redirect_location) 
 
        </span><span class="s2"># RFC 7231, Section 6.4.4</span><span class="s1"> 
        </span><span class="s0">if </span><span class="s1">response.status == </span><span class="s5">303</span><span class="s1">: 
            method = </span><span class="s3">'GET'</span><span class="s1"> 
 
        retries = kw.get(</span><span class="s3">'retries'</span><span class="s1">) 
        </span><span class="s0">if not </span><span class="s1">isinstance(retries</span><span class="s0">, </span><span class="s1">Retry): 
            retries = Retry.from_int(retries</span><span class="s0">, </span><span class="s1">redirect=redirect) 
 
        </span><span class="s0">try</span><span class="s1">: 
            retries = retries.increment(method</span><span class="s0">, </span><span class="s1">url</span><span class="s0">, </span><span class="s1">response=response</span><span class="s0">, </span><span class="s1">_pool=conn) 
        </span><span class="s0">except </span><span class="s1">MaxRetryError: 
            </span><span class="s0">if </span><span class="s1">retries.raise_on_redirect: 
                </span><span class="s0">raise</span><span class="s1"> 
            </span><span class="s0">return </span><span class="s1">response 
 
        kw[</span><span class="s3">'retries'</span><span class="s1">] = retries 
        kw[</span><span class="s3">'redirect'</span><span class="s1">] = redirect 
 
        log.info(</span><span class="s3">&quot;Redirecting %s -&gt; %s&quot;</span><span class="s0">, </span><span class="s1">url</span><span class="s0">, </span><span class="s1">redirect_location) 
        </span><span class="s0">return </span><span class="s1">self.urlopen(method</span><span class="s0">, </span><span class="s1">redirect_location</span><span class="s0">, </span><span class="s1">**kw) 
 
 
</span><span class="s0">class </span><span class="s1">ProxyManager(PoolManager): 
    </span><span class="s4">&quot;&quot;&quot; 
    Behaves just like :class:`PoolManager`, but sends all requests through 
    the defined proxy, using the CONNECT method for HTTPS URLs. 
 
    :param proxy_url: 
        The URL of the proxy to be used. 
 
    :param proxy_headers: 
        A dictionary contaning headers that will be sent to the proxy. In case 
        of HTTP they are being sent with each request, while in the 
        HTTPS/CONNECT case they are sent only once. Could be used for proxy 
        authentication. 
 
    Example: 
        &gt;&gt;&gt; proxy = urllib3.ProxyManager('http://localhost:3128/') 
        &gt;&gt;&gt; r1 = proxy.request('GET', 'http://google.com/') 
        &gt;&gt;&gt; r2 = proxy.request('GET', 'http://httpbin.org/') 
        &gt;&gt;&gt; len(proxy.pools) 
        1 
        &gt;&gt;&gt; r3 = proxy.request('GET', 'https://httpbin.org/') 
        &gt;&gt;&gt; r4 = proxy.request('GET', 'https://twitter.com/') 
        &gt;&gt;&gt; len(proxy.pools) 
        3 
 
    &quot;&quot;&quot;</span><span class="s1"> 
 
    </span><span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">proxy_url</span><span class="s0">, </span><span class="s1">num_pools=</span><span class="s5">10</span><span class="s0">, </span><span class="s1">headers=</span><span class="s0">None,</span><span class="s1"> 
                 proxy_headers=</span><span class="s0">None, </span><span class="s1">**connection_pool_kw): 
 
        </span><span class="s0">if </span><span class="s1">isinstance(proxy_url</span><span class="s0">, </span><span class="s1">HTTPConnectionPool): 
            proxy_url = </span><span class="s3">'%s://%s:%i' </span><span class="s1">% (proxy_url.scheme</span><span class="s0">, </span><span class="s1">proxy_url.host</span><span class="s0">,</span><span class="s1"> 
                                        proxy_url.port) 
        proxy = parse_url(proxy_url) 
        </span><span class="s0">if not </span><span class="s1">proxy.port: 
            port = port_by_scheme.get(proxy.scheme</span><span class="s0">, </span><span class="s5">80</span><span class="s1">) 
            proxy = proxy._replace(port=port) 
 
        </span><span class="s0">if </span><span class="s1">proxy.scheme </span><span class="s0">not in </span><span class="s1">(</span><span class="s3">&quot;http&quot;</span><span class="s0">, </span><span class="s3">&quot;https&quot;</span><span class="s1">): 
            </span><span class="s0">raise </span><span class="s1">ProxySchemeUnknown(proxy.scheme) 
 
        self.proxy = proxy 
        self.proxy_headers = proxy_headers </span><span class="s0">or </span><span class="s1">{} 
 
        connection_pool_kw[</span><span class="s3">'_proxy'</span><span class="s1">] = self.proxy 
        connection_pool_kw[</span><span class="s3">'_proxy_headers'</span><span class="s1">] = self.proxy_headers 
 
        super(ProxyManager</span><span class="s0">, </span><span class="s1">self).__init__( 
            num_pools</span><span class="s0">, </span><span class="s1">headers</span><span class="s0">, </span><span class="s1">**connection_pool_kw) 
 
    </span><span class="s0">def </span><span class="s1">connection_from_host(self</span><span class="s0">, </span><span class="s1">host</span><span class="s0">, </span><span class="s1">port=</span><span class="s0">None, </span><span class="s1">scheme=</span><span class="s3">'http'</span><span class="s1">): 
        </span><span class="s0">if </span><span class="s1">scheme == </span><span class="s3">&quot;https&quot;</span><span class="s1">: 
            </span><span class="s0">return </span><span class="s1">super(ProxyManager</span><span class="s0">, </span><span class="s1">self).connection_from_host( 
                host</span><span class="s0">, </span><span class="s1">port</span><span class="s0">, </span><span class="s1">scheme) 
 
        </span><span class="s0">return </span><span class="s1">super(ProxyManager</span><span class="s0">, </span><span class="s1">self).connection_from_host( 
            self.proxy.host</span><span class="s0">, </span><span class="s1">self.proxy.port</span><span class="s0">, </span><span class="s1">self.proxy.scheme) 
 
    </span><span class="s0">def </span><span class="s1">_set_proxy_headers(self</span><span class="s0">, </span><span class="s1">url</span><span class="s0">, </span><span class="s1">headers=</span><span class="s0">None</span><span class="s1">): 
        </span><span class="s4">&quot;&quot;&quot; 
        Sets headers needed by proxies: specifically, the Accept and Host 
        headers. Only sets headers not provided by the user. 
        &quot;&quot;&quot;</span><span class="s1"> 
        headers_ = {</span><span class="s3">'Accept'</span><span class="s1">: </span><span class="s3">'*/*'</span><span class="s1">} 
 
        netloc = parse_url(url).netloc 
        </span><span class="s0">if </span><span class="s1">netloc: 
            headers_[</span><span class="s3">'Host'</span><span class="s1">] = netloc 
 
        </span><span class="s0">if </span><span class="s1">headers: 
            headers_.update(headers) 
        </span><span class="s0">return </span><span class="s1">headers_ 
 
    </span><span class="s0">def </span><span class="s1">urlopen(self</span><span class="s0">, </span><span class="s1">method</span><span class="s0">, </span><span class="s1">url</span><span class="s0">, </span><span class="s1">redirect=</span><span class="s0">True, </span><span class="s1">**kw): 
        </span><span class="s4">&quot;Same as HTTP(S)ConnectionPool.urlopen, ``url`` must be absolute.&quot;</span><span class="s1"> 
        u = parse_url(url) 
 
        </span><span class="s0">if </span><span class="s1">u.scheme == </span><span class="s3">&quot;http&quot;</span><span class="s1">: 
            </span><span class="s2"># For proxied HTTPS requests, httplib sets the necessary headers</span><span class="s1"> 
            </span><span class="s2"># on the CONNECT to the proxy. For HTTP, we'll definitely</span><span class="s1"> 
            </span><span class="s2"># need to set 'Host' at the very least.</span><span class="s1"> 
            headers = kw.get(</span><span class="s3">'headers'</span><span class="s0">, </span><span class="s1">self.headers) 
            kw[</span><span class="s3">'headers'</span><span class="s1">] = self._set_proxy_headers(url</span><span class="s0">, </span><span class="s1">headers) 
 
        </span><span class="s0">return </span><span class="s1">super(ProxyManager</span><span class="s0">, </span><span class="s1">self).urlopen(method</span><span class="s0">, </span><span class="s1">url</span><span class="s0">, </span><span class="s1">redirect=redirect</span><span class="s0">, </span><span class="s1">**kw) 
 
 
</span><span class="s0">def </span><span class="s1">proxy_from_url(url</span><span class="s0">, </span><span class="s1">**kw): 
    </span><span class="s0">return </span><span class="s1">ProxyManager(proxy_url=url</span><span class="s0">, </span><span class="s1">**kw) 
</span></pre>
</body>
</html>