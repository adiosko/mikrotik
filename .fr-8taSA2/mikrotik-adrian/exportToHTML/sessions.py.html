<html>
<head>
<title>sessions.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.ln { color: #606366; font-weight: normal; font-style: normal; }
.s0 { color: rgb(128,128,128); }
.s1 { color: rgb(169,183,198); }
.s2 { color: rgb(98,151,85); font-style: italic; }
.s3 { color: rgb(204,120,50); }
.s4 { color: rgb(104,151,187); }
.s5 { color: rgb(106,135,89); }
</style>
</head>
<BODY BGCOLOR="#2b2b2b">
<TABLE CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<TR><TD><CENTER>
<FONT FACE="Arial, Helvetica" COLOR="#000000">
sessions.py</FONT>
</center></TD></TR></TABLE>
<pre>
<span class="s0"># -*- coding: utf-8 -*-</span><span class="s1"> 
 
</span><span class="s2">&quot;&quot;&quot; 
requests.session 
~~~~~~~~~~~~~~~~ 
 
This module provides a Session object to manage and persist settings across 
requests (cookies, auth, proxies). 
&quot;&quot;&quot;</span><span class="s1"> 
</span><span class="s3">import </span><span class="s1">os 
</span><span class="s3">from </span><span class="s1">collections </span><span class="s3">import </span><span class="s1">Mapping 
</span><span class="s3">from </span><span class="s1">datetime </span><span class="s3">import </span><span class="s1">datetime 
 
</span><span class="s3">from </span><span class="s1">.auth </span><span class="s3">import </span><span class="s1">_basic_auth_str 
</span><span class="s3">from </span><span class="s1">.compat </span><span class="s3">import </span><span class="s1">cookielib</span><span class="s3">, </span><span class="s1">OrderedDict</span><span class="s3">, </span><span class="s1">urljoin</span><span class="s3">, </span><span class="s1">urlparse 
</span><span class="s3">from </span><span class="s1">.cookies </span><span class="s3">import </span><span class="s1">( 
    cookiejar_from_dict</span><span class="s3">, </span><span class="s1">extract_cookies_to_jar</span><span class="s3">, </span><span class="s1">RequestsCookieJar</span><span class="s3">, </span><span class="s1">merge_cookies) 
</span><span class="s3">from </span><span class="s1">.models </span><span class="s3">import </span><span class="s1">Request</span><span class="s3">, </span><span class="s1">PreparedRequest</span><span class="s3">, </span><span class="s1">DEFAULT_REDIRECT_LIMIT 
</span><span class="s3">from </span><span class="s1">.hooks </span><span class="s3">import </span><span class="s1">default_hooks</span><span class="s3">, </span><span class="s1">dispatch_hook 
</span><span class="s3">from </span><span class="s1">.utils </span><span class="s3">import </span><span class="s1">to_key_val_list</span><span class="s3">, </span><span class="s1">default_headers</span><span class="s3">, </span><span class="s1">to_native_string 
</span><span class="s3">from </span><span class="s1">.exceptions </span><span class="s3">import </span><span class="s1">( 
    TooManyRedirects</span><span class="s3">, </span><span class="s1">InvalidSchema</span><span class="s3">, </span><span class="s1">ChunkedEncodingError</span><span class="s3">, </span><span class="s1">ContentDecodingError) 
</span><span class="s3">from </span><span class="s1">.packages.urllib3._collections </span><span class="s3">import </span><span class="s1">RecentlyUsedContainer 
</span><span class="s3">from </span><span class="s1">.structures </span><span class="s3">import </span><span class="s1">CaseInsensitiveDict 
 
</span><span class="s3">from </span><span class="s1">.adapters </span><span class="s3">import </span><span class="s1">HTTPAdapter 
 
</span><span class="s3">from </span><span class="s1">.utils </span><span class="s3">import </span><span class="s1">( 
    requote_uri</span><span class="s3">, </span><span class="s1">get_environ_proxies</span><span class="s3">, </span><span class="s1">get_netrc_auth</span><span class="s3">, </span><span class="s1">should_bypass_proxies</span><span class="s3">,</span><span class="s1"> 
    get_auth_from_url 
) 
 
</span><span class="s3">from </span><span class="s1">.status_codes </span><span class="s3">import </span><span class="s1">codes 
 
</span><span class="s0"># formerly defined here, reexposed here for backward compatibility</span><span class="s1"> 
</span><span class="s3">from </span><span class="s1">.models </span><span class="s3">import </span><span class="s1">REDIRECT_STATI 
 
REDIRECT_CACHE_SIZE = </span><span class="s4">1000</span><span class="s1"> 
 
 
</span><span class="s3">def </span><span class="s1">merge_setting(request_setting</span><span class="s3">, </span><span class="s1">session_setting</span><span class="s3">, </span><span class="s1">dict_class=OrderedDict): 
    </span><span class="s2">&quot;&quot;&quot;Determines appropriate setting for a given request, taking into account 
    the explicit setting on that request, and the setting in the session. If a 
    setting is a dictionary, they will be merged together using `dict_class` 
    &quot;&quot;&quot;</span><span class="s1"> 
 
    </span><span class="s3">if </span><span class="s1">session_setting </span><span class="s3">is None</span><span class="s1">: 
        </span><span class="s3">return </span><span class="s1">request_setting 
 
    </span><span class="s3">if </span><span class="s1">request_setting </span><span class="s3">is None</span><span class="s1">: 
        </span><span class="s3">return </span><span class="s1">session_setting 
 
    </span><span class="s0"># Bypass if not a dictionary (e.g. verify)</span><span class="s1"> 
    </span><span class="s3">if not </span><span class="s1">( 
            isinstance(session_setting</span><span class="s3">, </span><span class="s1">Mapping) </span><span class="s3">and</span><span class="s1"> 
            isinstance(request_setting</span><span class="s3">, </span><span class="s1">Mapping) 
    ): 
        </span><span class="s3">return </span><span class="s1">request_setting 
 
    merged_setting = dict_class(to_key_val_list(session_setting)) 
    merged_setting.update(to_key_val_list(request_setting)) 
 
    </span><span class="s0"># Remove keys that are set to None. Extract keys first to avoid altering</span><span class="s1"> 
    </span><span class="s0"># the dictionary during iteration.</span><span class="s1"> 
    none_keys = [k </span><span class="s3">for </span><span class="s1">(k</span><span class="s3">, </span><span class="s1">v) </span><span class="s3">in </span><span class="s1">merged_setting.items() </span><span class="s3">if </span><span class="s1">v </span><span class="s3">is None</span><span class="s1">] 
    </span><span class="s3">for </span><span class="s1">key </span><span class="s3">in </span><span class="s1">none_keys: 
        </span><span class="s3">del </span><span class="s1">merged_setting[key] 
 
    </span><span class="s3">return </span><span class="s1">merged_setting 
 
 
</span><span class="s3">def </span><span class="s1">merge_hooks(request_hooks</span><span class="s3">, </span><span class="s1">session_hooks</span><span class="s3">, </span><span class="s1">dict_class=OrderedDict): 
    </span><span class="s2">&quot;&quot;&quot;Properly merges both requests and session hooks. 
 
    This is necessary because when request_hooks == {'response': []}, the 
    merge breaks Session hooks entirely. 
    &quot;&quot;&quot;</span><span class="s1"> 
    </span><span class="s3">if </span><span class="s1">session_hooks </span><span class="s3">is None or </span><span class="s1">session_hooks.get(</span><span class="s5">'response'</span><span class="s1">) == []: 
        </span><span class="s3">return </span><span class="s1">request_hooks 
 
    </span><span class="s3">if </span><span class="s1">request_hooks </span><span class="s3">is None or </span><span class="s1">request_hooks.get(</span><span class="s5">'response'</span><span class="s1">) == []: 
        </span><span class="s3">return </span><span class="s1">session_hooks 
 
    </span><span class="s3">return </span><span class="s1">merge_setting(request_hooks</span><span class="s3">, </span><span class="s1">session_hooks</span><span class="s3">, </span><span class="s1">dict_class) 
 
 
</span><span class="s3">class </span><span class="s1">SessionRedirectMixin(object): 
    </span><span class="s3">def </span><span class="s1">resolve_redirects(self</span><span class="s3">, </span><span class="s1">resp</span><span class="s3">, </span><span class="s1">req</span><span class="s3">, </span><span class="s1">stream=</span><span class="s3">False, </span><span class="s1">timeout=</span><span class="s3">None,</span><span class="s1"> 
                          verify=</span><span class="s3">True, </span><span class="s1">cert=</span><span class="s3">None, </span><span class="s1">proxies=</span><span class="s3">None, </span><span class="s1">**adapter_kwargs): 
        </span><span class="s2">&quot;&quot;&quot;Receives a Response. Returns a generator of Responses.&quot;&quot;&quot;</span><span class="s1"> 
 
        i = </span><span class="s4">0</span><span class="s1"> 
        hist = [] </span><span class="s0"># keep track of history</span><span class="s1"> 
 
        </span><span class="s3">while </span><span class="s1">resp.is_redirect: 
            prepared_request = req.copy() 
 
            </span><span class="s3">if </span><span class="s1">i &gt; </span><span class="s4">0</span><span class="s1">: 
                </span><span class="s0"># Update history and keep track of redirects.</span><span class="s1"> 
                hist.append(resp) 
                new_hist = list(hist) 
                resp.history = new_hist 
 
            </span><span class="s3">try</span><span class="s1">: 
                resp.content  </span><span class="s0"># Consume socket so it can be released</span><span class="s1"> 
            </span><span class="s3">except </span><span class="s1">(ChunkedEncodingError</span><span class="s3">, </span><span class="s1">ContentDecodingError</span><span class="s3">, </span><span class="s1">RuntimeError): 
                resp.raw.read(decode_content=</span><span class="s3">False</span><span class="s1">) 
 
            </span><span class="s3">if </span><span class="s1">i &gt;= self.max_redirects: 
                </span><span class="s3">raise </span><span class="s1">TooManyRedirects(</span><span class="s5">'Exceeded %s redirects.' </span><span class="s1">% self.max_redirects</span><span class="s3">, </span><span class="s1">response=resp) 
 
            </span><span class="s0"># Release the connection back into the pool.</span><span class="s1"> 
            resp.close() 
 
            url = resp.headers[</span><span class="s5">'location'</span><span class="s1">] 
 
            </span><span class="s0"># Handle redirection without scheme (see: RFC 1808 Section 4)</span><span class="s1"> 
            </span><span class="s3">if </span><span class="s1">url.startswith(</span><span class="s5">'//'</span><span class="s1">): 
                parsed_rurl = urlparse(resp.url) 
                url = </span><span class="s5">'%s:%s' </span><span class="s1">% (parsed_rurl.scheme</span><span class="s3">, </span><span class="s1">url) 
 
            </span><span class="s0"># The scheme should be lower case...</span><span class="s1"> 
            parsed = urlparse(url) 
            url = parsed.geturl() 
 
            </span><span class="s0"># Facilitate relative 'location' headers, as allowed by RFC 7231.</span><span class="s1"> 
            </span><span class="s0"># (e.g. '/path/to/resource' instead of 'http://domain.tld/path/to/resource')</span><span class="s1"> 
            </span><span class="s0"># Compliant with RFC3986, we percent encode the url.</span><span class="s1"> 
            </span><span class="s3">if not </span><span class="s1">parsed.netloc: 
                url = urljoin(resp.url</span><span class="s3">, </span><span class="s1">requote_uri(url)) 
            </span><span class="s3">else</span><span class="s1">: 
                url = requote_uri(url) 
 
            prepared_request.url = to_native_string(url) 
            </span><span class="s0"># Cache the url, unless it redirects to itself.</span><span class="s1"> 
            </span><span class="s3">if </span><span class="s1">resp.is_permanent_redirect </span><span class="s3">and </span><span class="s1">req.url != prepared_request.url: 
                self.redirect_cache[req.url] = prepared_request.url 
 
            self.rebuild_method(prepared_request</span><span class="s3">, </span><span class="s1">resp) 
 
            </span><span class="s0"># https://github.com/kennethreitz/requests/issues/1084</span><span class="s1"> 
            </span><span class="s3">if </span><span class="s1">resp.status_code </span><span class="s3">not in </span><span class="s1">(codes.temporary_redirect</span><span class="s3">, </span><span class="s1">codes.permanent_redirect): 
                </span><span class="s0"># https://github.com/kennethreitz/requests/issues/3490</span><span class="s1"> 
                purged_headers = (</span><span class="s5">'Content-Length'</span><span class="s3">, </span><span class="s5">'Content-Type'</span><span class="s3">, </span><span class="s5">'Transfer-Encoding'</span><span class="s1">) 
                </span><span class="s3">for </span><span class="s1">header </span><span class="s3">in </span><span class="s1">purged_headers: 
                    prepared_request.headers.pop(header</span><span class="s3">, None</span><span class="s1">) 
                prepared_request.body = </span><span class="s3">None</span><span class="s1"> 
 
            headers = prepared_request.headers 
            </span><span class="s3">try</span><span class="s1">: 
                </span><span class="s3">del </span><span class="s1">headers[</span><span class="s5">'Cookie'</span><span class="s1">] 
            </span><span class="s3">except </span><span class="s1">KeyError: 
                </span><span class="s3">pass</span><span class="s1"> 
 
            </span><span class="s0"># Extract any cookies sent on the response to the cookiejar</span><span class="s1"> 
            </span><span class="s0"># in the new request. Because we've mutated our copied prepared</span><span class="s1"> 
            </span><span class="s0"># request, use the old one that we haven't yet touched.</span><span class="s1"> 
            extract_cookies_to_jar(prepared_request._cookies</span><span class="s3">, </span><span class="s1">req</span><span class="s3">, </span><span class="s1">resp.raw) 
            prepared_request._cookies.update(self.cookies) 
            prepared_request.prepare_cookies(prepared_request._cookies) 
 
            </span><span class="s0"># Rebuild auth and proxy information.</span><span class="s1"> 
            proxies = self.rebuild_proxies(prepared_request</span><span class="s3">, </span><span class="s1">proxies) 
            self.rebuild_auth(prepared_request</span><span class="s3">, </span><span class="s1">resp) 
 
            </span><span class="s0"># Override the original request.</span><span class="s1"> 
            req = prepared_request 
 
            resp = self.send( 
                req</span><span class="s3">,</span><span class="s1"> 
                stream=stream</span><span class="s3">,</span><span class="s1"> 
                timeout=timeout</span><span class="s3">,</span><span class="s1"> 
                verify=verify</span><span class="s3">,</span><span class="s1"> 
                cert=cert</span><span class="s3">,</span><span class="s1"> 
                proxies=proxies</span><span class="s3">,</span><span class="s1"> 
                allow_redirects=</span><span class="s3">False,</span><span class="s1"> 
                **adapter_kwargs 
            ) 
 
            extract_cookies_to_jar(self.cookies</span><span class="s3">, </span><span class="s1">prepared_request</span><span class="s3">, </span><span class="s1">resp.raw) 
 
            i += </span><span class="s4">1</span><span class="s1"> 
            </span><span class="s3">yield </span><span class="s1">resp 
 
    </span><span class="s3">def </span><span class="s1">rebuild_auth(self</span><span class="s3">, </span><span class="s1">prepared_request</span><span class="s3">, </span><span class="s1">response): 
        </span><span class="s2">&quot;&quot;&quot;When being redirected we may want to strip authentication from the 
        request to avoid leaking credentials. This method intelligently removes 
        and reapplies authentication where possible to avoid credential loss. 
        &quot;&quot;&quot;</span><span class="s1"> 
        headers = prepared_request.headers 
        url = prepared_request.url 
 
        </span><span class="s3">if </span><span class="s5">'Authorization' </span><span class="s3">in </span><span class="s1">headers: 
            </span><span class="s0"># If we get redirected to a new host, we should strip out any</span><span class="s1"> 
            </span><span class="s0"># authentication headers.</span><span class="s1"> 
            original_parsed = urlparse(response.request.url) 
            redirect_parsed = urlparse(url) 
 
            </span><span class="s3">if </span><span class="s1">(original_parsed.hostname != redirect_parsed.hostname): 
                </span><span class="s3">del </span><span class="s1">headers[</span><span class="s5">'Authorization'</span><span class="s1">] 
 
        </span><span class="s0"># .netrc might have more auth for us on our new host.</span><span class="s1"> 
        new_auth = get_netrc_auth(url) </span><span class="s3">if </span><span class="s1">self.trust_env </span><span class="s3">else None</span><span class="s1"> 
        </span><span class="s3">if </span><span class="s1">new_auth </span><span class="s3">is not None</span><span class="s1">: 
            prepared_request.prepare_auth(new_auth) 
 
        </span><span class="s3">return</span><span class="s1"> 
 
    </span><span class="s3">def </span><span class="s1">rebuild_proxies(self</span><span class="s3">, </span><span class="s1">prepared_request</span><span class="s3">, </span><span class="s1">proxies): 
        </span><span class="s2">&quot;&quot;&quot;This method re-evaluates the proxy configuration by considering the 
        environment variables. If we are redirected to a URL covered by 
        NO_PROXY, we strip the proxy configuration. Otherwise, we set missing 
        proxy keys for this URL (in case they were stripped by a previous 
        redirect). 
 
        This method also replaces the Proxy-Authorization header where 
        necessary. 
 
        :rtype: dict 
        &quot;&quot;&quot;</span><span class="s1"> 
        headers = prepared_request.headers 
        url = prepared_request.url 
        scheme = urlparse(url).scheme 
        new_proxies = proxies.copy() </span><span class="s3">if </span><span class="s1">proxies </span><span class="s3">is not None else </span><span class="s1">{} 
 
        </span><span class="s3">if </span><span class="s1">self.trust_env </span><span class="s3">and not </span><span class="s1">should_bypass_proxies(url): 
            environ_proxies = get_environ_proxies(url) 
 
            proxy = environ_proxies.get(</span><span class="s5">'all'</span><span class="s3">, </span><span class="s1">environ_proxies.get(scheme)) 
 
            </span><span class="s3">if </span><span class="s1">proxy: 
                new_proxies.setdefault(scheme</span><span class="s3">, </span><span class="s1">proxy) 
 
        </span><span class="s3">if </span><span class="s5">'Proxy-Authorization' </span><span class="s3">in </span><span class="s1">headers: 
            </span><span class="s3">del </span><span class="s1">headers[</span><span class="s5">'Proxy-Authorization'</span><span class="s1">] 
 
        </span><span class="s3">try</span><span class="s1">: 
            username</span><span class="s3">, </span><span class="s1">password = get_auth_from_url(new_proxies[scheme]) 
        </span><span class="s3">except </span><span class="s1">KeyError: 
            username</span><span class="s3">, </span><span class="s1">password = </span><span class="s3">None, None</span><span class="s1"> 
 
        </span><span class="s3">if </span><span class="s1">username </span><span class="s3">and </span><span class="s1">password: 
            headers[</span><span class="s5">'Proxy-Authorization'</span><span class="s1">] = _basic_auth_str(username</span><span class="s3">, </span><span class="s1">password) 
 
        </span><span class="s3">return </span><span class="s1">new_proxies 
 
    </span><span class="s3">def </span><span class="s1">rebuild_method(self</span><span class="s3">, </span><span class="s1">prepared_request</span><span class="s3">, </span><span class="s1">response): 
        </span><span class="s2">&quot;&quot;&quot;When being redirected we may want to change the method of the request 
        based on certain specs or browser behavior. 
        &quot;&quot;&quot;</span><span class="s1"> 
        method = prepared_request.method 
 
        </span><span class="s0"># http://tools.ietf.org/html/rfc7231#section-6.4.4</span><span class="s1"> 
        </span><span class="s3">if </span><span class="s1">response.status_code == codes.see_other </span><span class="s3">and </span><span class="s1">method != </span><span class="s5">'HEAD'</span><span class="s1">: 
            method = </span><span class="s5">'GET'</span><span class="s1"> 
 
        </span><span class="s0"># Do what the browsers do, despite standards...</span><span class="s1"> 
        </span><span class="s0"># First, turn 302s into GETs.</span><span class="s1"> 
        </span><span class="s3">if </span><span class="s1">response.status_code == codes.found </span><span class="s3">and </span><span class="s1">method != </span><span class="s5">'HEAD'</span><span class="s1">: 
            method = </span><span class="s5">'GET'</span><span class="s1"> 
 
        </span><span class="s0"># Second, if a POST is responded to with a 301, turn it into a GET.</span><span class="s1"> 
        </span><span class="s0"># This bizarre behaviour is explained in Issue 1704.</span><span class="s1"> 
        </span><span class="s3">if </span><span class="s1">response.status_code == codes.moved </span><span class="s3">and </span><span class="s1">method == </span><span class="s5">'POST'</span><span class="s1">: 
            method = </span><span class="s5">'GET'</span><span class="s1"> 
 
        prepared_request.method = method 
 
 
</span><span class="s3">class </span><span class="s1">Session(SessionRedirectMixin): 
    </span><span class="s2">&quot;&quot;&quot;A Requests session. 
 
    Provides cookie persistence, connection-pooling, and configuration. 
 
    Basic Usage:: 
 
      &gt;&gt;&gt; import requests 
      &gt;&gt;&gt; s = requests.Session() 
      &gt;&gt;&gt; s.get('http://httpbin.org/get') 
      &lt;Response [200]&gt; 
 
    Or as a context manager:: 
 
      &gt;&gt;&gt; with requests.Session() as s: 
      &gt;&gt;&gt;     s.get('http://httpbin.org/get') 
      &lt;Response [200]&gt; 
    &quot;&quot;&quot;</span><span class="s1"> 
 
    __attrs__ = [ 
        </span><span class="s5">'headers'</span><span class="s3">, </span><span class="s5">'cookies'</span><span class="s3">, </span><span class="s5">'auth'</span><span class="s3">, </span><span class="s5">'proxies'</span><span class="s3">, </span><span class="s5">'hooks'</span><span class="s3">, </span><span class="s5">'params'</span><span class="s3">, </span><span class="s5">'verify'</span><span class="s3">,</span><span class="s1"> 
        </span><span class="s5">'cert'</span><span class="s3">, </span><span class="s5">'prefetch'</span><span class="s3">, </span><span class="s5">'adapters'</span><span class="s3">, </span><span class="s5">'stream'</span><span class="s3">, </span><span class="s5">'trust_env'</span><span class="s3">,</span><span class="s1"> 
        </span><span class="s5">'max_redirects'</span><span class="s3">,</span><span class="s1"> 
    ] 
 
    </span><span class="s3">def </span><span class="s1">__init__(self): 
 
        </span><span class="s0">#: A case-insensitive dictionary of headers to be sent on each</span><span class="s1"> 
        </span><span class="s0">#: :class:`Request &lt;Request&gt;` sent from this</span><span class="s1"> 
        </span><span class="s0">#: :class:`Session &lt;Session&gt;`.</span><span class="s1"> 
        self.headers = default_headers() 
 
        </span><span class="s0">#: Default Authentication tuple or object to attach to</span><span class="s1"> 
        </span><span class="s0">#: :class:`Request &lt;Request&gt;`.</span><span class="s1"> 
        self.auth = </span><span class="s3">None</span><span class="s1"> 
 
        </span><span class="s0">#: Dictionary mapping protocol or protocol and host to the URL of the proxy</span><span class="s1"> 
        </span><span class="s0">#: (e.g. {'http': 'foo.bar:3128', 'http://host.name': 'foo.bar:4012'}) to</span><span class="s1"> 
        </span><span class="s0">#: be used on each :class:`Request &lt;Request&gt;`.</span><span class="s1"> 
        self.proxies = {} 
 
        </span><span class="s0">#: Event-handling hooks.</span><span class="s1"> 
        self.hooks = default_hooks() 
 
        </span><span class="s0">#: Dictionary of querystring data to attach to each</span><span class="s1"> 
        </span><span class="s0">#: :class:`Request &lt;Request&gt;`. The dictionary values may be lists for</span><span class="s1"> 
        </span><span class="s0">#: representing multivalued query parameters.</span><span class="s1"> 
        self.params = {} 
 
        </span><span class="s0">#: Stream response content default.</span><span class="s1"> 
        self.stream = </span><span class="s3">False</span><span class="s1"> 
 
        </span><span class="s0">#: SSL Verification default.</span><span class="s1"> 
        self.verify = </span><span class="s3">True</span><span class="s1"> 
 
        </span><span class="s0">#: SSL certificate default.</span><span class="s1"> 
        self.cert = </span><span class="s3">None</span><span class="s1"> 
 
        </span><span class="s0">#: Maximum number of redirects allowed. If the request exceeds this</span><span class="s1"> 
        </span><span class="s0">#: limit, a :class:`TooManyRedirects` exception is raised.</span><span class="s1"> 
        </span><span class="s0">#: This defaults to requests.models.DEFAULT_REDIRECT_LIMIT, which is</span><span class="s1"> 
        </span><span class="s0">#: 30.</span><span class="s1"> 
        self.max_redirects = DEFAULT_REDIRECT_LIMIT 
 
        </span><span class="s0">#: Trust environment settings for proxy configuration, default</span><span class="s1"> 
        </span><span class="s0">#: authentication and similar.</span><span class="s1"> 
        self.trust_env = </span><span class="s3">True</span><span class="s1"> 
 
        </span><span class="s0">#: A CookieJar containing all currently outstanding cookies set on this</span><span class="s1"> 
        </span><span class="s0">#: session. By default it is a</span><span class="s1"> 
        </span><span class="s0">#: :class:`RequestsCookieJar &lt;requests.cookies.RequestsCookieJar&gt;`, but</span><span class="s1"> 
        </span><span class="s0">#: may be any other ``cookielib.CookieJar`` compatible object.</span><span class="s1"> 
        self.cookies = cookiejar_from_dict({}) 
 
        </span><span class="s0"># Default connection adapters.</span><span class="s1"> 
        self.adapters = OrderedDict() 
        self.mount(</span><span class="s5">'https://'</span><span class="s3">, </span><span class="s1">HTTPAdapter()) 
        self.mount(</span><span class="s5">'http://'</span><span class="s3">, </span><span class="s1">HTTPAdapter()) 
 
        </span><span class="s0"># Only store 1000 redirects to prevent using infinite memory</span><span class="s1"> 
        self.redirect_cache = RecentlyUsedContainer(REDIRECT_CACHE_SIZE) 
 
    </span><span class="s3">def </span><span class="s1">__enter__(self): 
        </span><span class="s3">return </span><span class="s1">self 
 
    </span><span class="s3">def </span><span class="s1">__exit__(self</span><span class="s3">, </span><span class="s1">*args): 
        self.close() 
 
    </span><span class="s3">def </span><span class="s1">prepare_request(self</span><span class="s3">, </span><span class="s1">request): 
        </span><span class="s2">&quot;&quot;&quot;Constructs a :class:`PreparedRequest &lt;PreparedRequest&gt;` for 
        transmission and returns it. The :class:`PreparedRequest` has settings 
        merged from the :class:`Request &lt;Request&gt;` instance and those of the 
        :class:`Session`. 
 
        :param request: :class:`Request` instance to prepare with this 
            session's settings. 
        :rtype: requests.PreparedRequest 
        &quot;&quot;&quot;</span><span class="s1"> 
        cookies = request.cookies </span><span class="s3">or </span><span class="s1">{} 
 
        </span><span class="s0"># Bootstrap CookieJar.</span><span class="s1"> 
        </span><span class="s3">if not </span><span class="s1">isinstance(cookies</span><span class="s3">, </span><span class="s1">cookielib.CookieJar): 
            cookies = cookiejar_from_dict(cookies) 
 
        </span><span class="s0"># Merge with session cookies</span><span class="s1"> 
        merged_cookies = merge_cookies( 
            merge_cookies(RequestsCookieJar()</span><span class="s3">, </span><span class="s1">self.cookies)</span><span class="s3">, </span><span class="s1">cookies) 
 
        </span><span class="s0"># Set environment's basic authentication if not explicitly set.</span><span class="s1"> 
        auth = request.auth 
        </span><span class="s3">if </span><span class="s1">self.trust_env </span><span class="s3">and not </span><span class="s1">auth </span><span class="s3">and not </span><span class="s1">self.auth: 
            auth = get_netrc_auth(request.url) 
 
        p = PreparedRequest() 
        p.prepare( 
            method=request.method.upper()</span><span class="s3">,</span><span class="s1"> 
            url=request.url</span><span class="s3">,</span><span class="s1"> 
            files=request.files</span><span class="s3">,</span><span class="s1"> 
            data=request.data</span><span class="s3">,</span><span class="s1"> 
            json=request.json</span><span class="s3">,</span><span class="s1"> 
            headers=merge_setting(request.headers</span><span class="s3">, </span><span class="s1">self.headers</span><span class="s3">, </span><span class="s1">dict_class=CaseInsensitiveDict)</span><span class="s3">,</span><span class="s1"> 
            params=merge_setting(request.params</span><span class="s3">, </span><span class="s1">self.params)</span><span class="s3">,</span><span class="s1"> 
            auth=merge_setting(auth</span><span class="s3">, </span><span class="s1">self.auth)</span><span class="s3">,</span><span class="s1"> 
            cookies=merged_cookies</span><span class="s3">,</span><span class="s1"> 
            hooks=merge_hooks(request.hooks</span><span class="s3">, </span><span class="s1">self.hooks)</span><span class="s3">,</span><span class="s1"> 
        ) 
        </span><span class="s3">return </span><span class="s1">p 
 
    </span><span class="s3">def </span><span class="s1">request(self</span><span class="s3">, </span><span class="s1">method</span><span class="s3">, </span><span class="s1">url</span><span class="s3">,</span><span class="s1"> 
        params=</span><span class="s3">None,</span><span class="s1"> 
        data=</span><span class="s3">None,</span><span class="s1"> 
        headers=</span><span class="s3">None,</span><span class="s1"> 
        cookies=</span><span class="s3">None,</span><span class="s1"> 
        files=</span><span class="s3">None,</span><span class="s1"> 
        auth=</span><span class="s3">None,</span><span class="s1"> 
        timeout=</span><span class="s3">None,</span><span class="s1"> 
        allow_redirects=</span><span class="s3">True,</span><span class="s1"> 
        proxies=</span><span class="s3">None,</span><span class="s1"> 
        hooks=</span><span class="s3">None,</span><span class="s1"> 
        stream=</span><span class="s3">None,</span><span class="s1"> 
        verify=</span><span class="s3">None,</span><span class="s1"> 
        cert=</span><span class="s3">None,</span><span class="s1"> 
        json=</span><span class="s3">None</span><span class="s1">): 
        </span><span class="s2">&quot;&quot;&quot;Constructs a :class:`Request &lt;Request&gt;`, prepares it and sends it. 
        Returns :class:`Response &lt;Response&gt;` object. 
 
        :param method: method for the new :class:`Request` object. 
        :param url: URL for the new :class:`Request` object. 
        :param params: (optional) Dictionary or bytes to be sent in the query 
            string for the :class:`Request`. 
        :param data: (optional) Dictionary, bytes, or file-like object to send 
            in the body of the :class:`Request`. 
        :param json: (optional) json to send in the body of the 
            :class:`Request`. 
        :param headers: (optional) Dictionary of HTTP Headers to send with the 
            :class:`Request`. 
        :param cookies: (optional) Dict or CookieJar object to send with the 
            :class:`Request`. 
        :param files: (optional) Dictionary of ``'filename': file-like-objects`` 
            for multipart encoding upload. 
        :param auth: (optional) Auth tuple or callable to enable 
            Basic/Digest/Custom HTTP Auth. 
        :param timeout: (optional) How long to wait for the server to send 
            data before giving up, as a float, or a :ref:`(connect timeout, 
            read timeout) &lt;timeouts&gt;` tuple. 
        :type timeout: float or tuple 
        :param allow_redirects: (optional) Set to True by default. 
        :type allow_redirects: bool 
        :param proxies: (optional) Dictionary mapping protocol or protocol and 
            hostname to the URL of the proxy. 
        :param stream: (optional) whether to immediately download the response 
            content. Defaults to ``False``. 
        :param verify: (optional) whether the SSL cert will be verified. 
            A CA_BUNDLE path can also be provided. Defaults to ``True``. 
        :param cert: (optional) if String, path to ssl client cert file (.pem). 
            If Tuple, ('cert', 'key') pair. 
        :rtype: requests.Response 
        &quot;&quot;&quot;</span><span class="s1"> 
        </span><span class="s0"># Create the Request.</span><span class="s1"> 
        req = Request( 
            method = method.upper()</span><span class="s3">,</span><span class="s1"> 
            url = url</span><span class="s3">,</span><span class="s1"> 
            headers = headers</span><span class="s3">,</span><span class="s1"> 
            files = files</span><span class="s3">,</span><span class="s1"> 
            data = data </span><span class="s3">or </span><span class="s1">{}</span><span class="s3">,</span><span class="s1"> 
            json = json</span><span class="s3">,</span><span class="s1"> 
            params = params </span><span class="s3">or </span><span class="s1">{}</span><span class="s3">,</span><span class="s1"> 
            auth = auth</span><span class="s3">,</span><span class="s1"> 
            cookies = cookies</span><span class="s3">,</span><span class="s1"> 
            hooks = hooks</span><span class="s3">,</span><span class="s1"> 
        ) 
        prep = self.prepare_request(req) 
 
        proxies = proxies </span><span class="s3">or </span><span class="s1">{} 
 
        settings = self.merge_environment_settings( 
            prep.url</span><span class="s3">, </span><span class="s1">proxies</span><span class="s3">, </span><span class="s1">stream</span><span class="s3">, </span><span class="s1">verify</span><span class="s3">, </span><span class="s1">cert 
        ) 
 
        </span><span class="s0"># Send the request.</span><span class="s1"> 
        send_kwargs = { 
            </span><span class="s5">'timeout'</span><span class="s1">: timeout</span><span class="s3">,</span><span class="s1"> 
            </span><span class="s5">'allow_redirects'</span><span class="s1">: allow_redirects</span><span class="s3">,</span><span class="s1"> 
        } 
        send_kwargs.update(settings) 
        resp = self.send(prep</span><span class="s3">, </span><span class="s1">**send_kwargs) 
 
        </span><span class="s3">return </span><span class="s1">resp 
 
    </span><span class="s3">def </span><span class="s1">get(self</span><span class="s3">, </span><span class="s1">url</span><span class="s3">, </span><span class="s1">**kwargs): 
        </span><span class="s2">&quot;&quot;&quot;Sends a GET request. Returns :class:`Response` object. 
 
        :param url: URL for the new :class:`Request` object. 
        :param \*\*kwargs: Optional arguments that ``request`` takes. 
        :rtype: requests.Response 
        &quot;&quot;&quot;</span><span class="s1"> 
 
        kwargs.setdefault(</span><span class="s5">'allow_redirects'</span><span class="s3">, True</span><span class="s1">) 
        </span><span class="s3">return </span><span class="s1">self.request(</span><span class="s5">'GET'</span><span class="s3">, </span><span class="s1">url</span><span class="s3">, </span><span class="s1">**kwargs) 
 
    </span><span class="s3">def </span><span class="s1">options(self</span><span class="s3">, </span><span class="s1">url</span><span class="s3">, </span><span class="s1">**kwargs): 
        </span><span class="s2">&quot;&quot;&quot;Sends a OPTIONS request. Returns :class:`Response` object. 
 
        :param url: URL for the new :class:`Request` object. 
        :param \*\*kwargs: Optional arguments that ``request`` takes. 
        :rtype: requests.Response 
        &quot;&quot;&quot;</span><span class="s1"> 
 
        kwargs.setdefault(</span><span class="s5">'allow_redirects'</span><span class="s3">, True</span><span class="s1">) 
        </span><span class="s3">return </span><span class="s1">self.request(</span><span class="s5">'OPTIONS'</span><span class="s3">, </span><span class="s1">url</span><span class="s3">, </span><span class="s1">**kwargs) 
 
    </span><span class="s3">def </span><span class="s1">head(self</span><span class="s3">, </span><span class="s1">url</span><span class="s3">, </span><span class="s1">**kwargs): 
        </span><span class="s2">&quot;&quot;&quot;Sends a HEAD request. Returns :class:`Response` object. 
 
        :param url: URL for the new :class:`Request` object. 
        :param \*\*kwargs: Optional arguments that ``request`` takes. 
        :rtype: requests.Response 
        &quot;&quot;&quot;</span><span class="s1"> 
 
        kwargs.setdefault(</span><span class="s5">'allow_redirects'</span><span class="s3">, False</span><span class="s1">) 
        </span><span class="s3">return </span><span class="s1">self.request(</span><span class="s5">'HEAD'</span><span class="s3">, </span><span class="s1">url</span><span class="s3">, </span><span class="s1">**kwargs) 
 
    </span><span class="s3">def </span><span class="s1">post(self</span><span class="s3">, </span><span class="s1">url</span><span class="s3">, </span><span class="s1">data=</span><span class="s3">None, </span><span class="s1">json=</span><span class="s3">None, </span><span class="s1">**kwargs): 
        </span><span class="s2">&quot;&quot;&quot;Sends a POST request. Returns :class:`Response` object. 
 
        :param url: URL for the new :class:`Request` object. 
        :param data: (optional) Dictionary, bytes, or file-like object to send in the body of the :class:`Request`. 
        :param json: (optional) json to send in the body of the :class:`Request`. 
        :param \*\*kwargs: Optional arguments that ``request`` takes. 
        :rtype: requests.Response 
        &quot;&quot;&quot;</span><span class="s1"> 
 
        </span><span class="s3">return </span><span class="s1">self.request(</span><span class="s5">'POST'</span><span class="s3">, </span><span class="s1">url</span><span class="s3">, </span><span class="s1">data=data</span><span class="s3">, </span><span class="s1">json=json</span><span class="s3">, </span><span class="s1">**kwargs) 
 
    </span><span class="s3">def </span><span class="s1">put(self</span><span class="s3">, </span><span class="s1">url</span><span class="s3">, </span><span class="s1">data=</span><span class="s3">None, </span><span class="s1">**kwargs): 
        </span><span class="s2">&quot;&quot;&quot;Sends a PUT request. Returns :class:`Response` object. 
 
        :param url: URL for the new :class:`Request` object. 
        :param data: (optional) Dictionary, bytes, or file-like object to send in the body of the :class:`Request`. 
        :param \*\*kwargs: Optional arguments that ``request`` takes. 
        :rtype: requests.Response 
        &quot;&quot;&quot;</span><span class="s1"> 
 
        </span><span class="s3">return </span><span class="s1">self.request(</span><span class="s5">'PUT'</span><span class="s3">, </span><span class="s1">url</span><span class="s3">, </span><span class="s1">data=data</span><span class="s3">, </span><span class="s1">**kwargs) 
 
    </span><span class="s3">def </span><span class="s1">patch(self</span><span class="s3">, </span><span class="s1">url</span><span class="s3">, </span><span class="s1">data=</span><span class="s3">None, </span><span class="s1">**kwargs): 
        </span><span class="s2">&quot;&quot;&quot;Sends a PATCH request. Returns :class:`Response` object. 
 
        :param url: URL for the new :class:`Request` object. 
        :param data: (optional) Dictionary, bytes, or file-like object to send in the body of the :class:`Request`. 
        :param \*\*kwargs: Optional arguments that ``request`` takes. 
        :rtype: requests.Response 
        &quot;&quot;&quot;</span><span class="s1"> 
 
        </span><span class="s3">return </span><span class="s1">self.request(</span><span class="s5">'PATCH'</span><span class="s3">, </span><span class="s1">url</span><span class="s3">,  </span><span class="s1">data=data</span><span class="s3">, </span><span class="s1">**kwargs) 
 
    </span><span class="s3">def </span><span class="s1">delete(self</span><span class="s3">, </span><span class="s1">url</span><span class="s3">, </span><span class="s1">**kwargs): 
        </span><span class="s2">&quot;&quot;&quot;Sends a DELETE request. Returns :class:`Response` object. 
 
        :param url: URL for the new :class:`Request` object. 
        :param \*\*kwargs: Optional arguments that ``request`` takes. 
        :rtype: requests.Response 
        &quot;&quot;&quot;</span><span class="s1"> 
 
        </span><span class="s3">return </span><span class="s1">self.request(</span><span class="s5">'DELETE'</span><span class="s3">, </span><span class="s1">url</span><span class="s3">, </span><span class="s1">**kwargs) 
 
    </span><span class="s3">def </span><span class="s1">send(self</span><span class="s3">, </span><span class="s1">request</span><span class="s3">, </span><span class="s1">**kwargs): 
        </span><span class="s2">&quot;&quot;&quot; 
        Send a given PreparedRequest. 
 
        :rtype: requests.Response 
        &quot;&quot;&quot;</span><span class="s1"> 
        </span><span class="s0"># Set defaults that the hooks can utilize to ensure they always have</span><span class="s1"> 
        </span><span class="s0"># the correct parameters to reproduce the previous request.</span><span class="s1"> 
        kwargs.setdefault(</span><span class="s5">'stream'</span><span class="s3">, </span><span class="s1">self.stream) 
        kwargs.setdefault(</span><span class="s5">'verify'</span><span class="s3">, </span><span class="s1">self.verify) 
        kwargs.setdefault(</span><span class="s5">'cert'</span><span class="s3">, </span><span class="s1">self.cert) 
        kwargs.setdefault(</span><span class="s5">'proxies'</span><span class="s3">, </span><span class="s1">self.proxies) 
 
        </span><span class="s0"># It's possible that users might accidentally send a Request object.</span><span class="s1"> 
        </span><span class="s0"># Guard against that specific failure case.</span><span class="s1"> 
        </span><span class="s3">if </span><span class="s1">isinstance(request</span><span class="s3">, </span><span class="s1">Request): 
            </span><span class="s3">raise </span><span class="s1">ValueError(</span><span class="s5">'You can only send PreparedRequests.'</span><span class="s1">) 
 
        </span><span class="s0"># Set up variables needed for resolve_redirects and dispatching of hooks</span><span class="s1"> 
        allow_redirects = kwargs.pop(</span><span class="s5">'allow_redirects'</span><span class="s3">, True</span><span class="s1">) 
        stream = kwargs.get(</span><span class="s5">'stream'</span><span class="s1">) 
        hooks = request.hooks 
 
        </span><span class="s0"># Resolve URL in redirect cache, if available.</span><span class="s1"> 
        </span><span class="s3">if </span><span class="s1">allow_redirects: 
            checked_urls = set() 
            </span><span class="s3">while </span><span class="s1">request.url </span><span class="s3">in </span><span class="s1">self.redirect_cache: 
                checked_urls.add(request.url) 
                new_url = self.redirect_cache.get(request.url) 
                </span><span class="s3">if </span><span class="s1">new_url </span><span class="s3">in </span><span class="s1">checked_urls: 
                    </span><span class="s3">break</span><span class="s1"> 
                request.url = new_url 
 
        </span><span class="s0"># Get the appropriate adapter to use</span><span class="s1"> 
        adapter = self.get_adapter(url=request.url) 
 
        </span><span class="s0"># Start time (approximately) of the request</span><span class="s1"> 
        start = datetime.utcnow() 
 
        </span><span class="s0"># Send the request</span><span class="s1"> 
        r = adapter.send(request</span><span class="s3">, </span><span class="s1">**kwargs) 
 
        </span><span class="s0"># Total elapsed time of the request (approximately)</span><span class="s1"> 
        r.elapsed = datetime.utcnow() - start 
 
        </span><span class="s0"># Response manipulation hooks</span><span class="s1"> 
        r = dispatch_hook(</span><span class="s5">'response'</span><span class="s3">, </span><span class="s1">hooks</span><span class="s3">, </span><span class="s1">r</span><span class="s3">, </span><span class="s1">**kwargs) 
 
        </span><span class="s0"># Persist cookies</span><span class="s1"> 
        </span><span class="s3">if </span><span class="s1">r.history: 
 
            </span><span class="s0"># If the hooks create history then we want those cookies too</span><span class="s1"> 
            </span><span class="s3">for </span><span class="s1">resp </span><span class="s3">in </span><span class="s1">r.history: 
                extract_cookies_to_jar(self.cookies</span><span class="s3">, </span><span class="s1">resp.request</span><span class="s3">, </span><span class="s1">resp.raw) 
 
        extract_cookies_to_jar(self.cookies</span><span class="s3">, </span><span class="s1">request</span><span class="s3">, </span><span class="s1">r.raw) 
 
        </span><span class="s0"># Redirect resolving generator.</span><span class="s1"> 
        gen = self.resolve_redirects(r</span><span class="s3">, </span><span class="s1">request</span><span class="s3">, </span><span class="s1">**kwargs) 
 
        </span><span class="s0"># Resolve redirects if allowed.</span><span class="s1"> 
        history = [resp </span><span class="s3">for </span><span class="s1">resp </span><span class="s3">in </span><span class="s1">gen] </span><span class="s3">if </span><span class="s1">allow_redirects </span><span class="s3">else </span><span class="s1">[] 
 
        </span><span class="s0"># Shuffle things around if there's history.</span><span class="s1"> 
        </span><span class="s3">if </span><span class="s1">history: 
            </span><span class="s0"># Insert the first (original) request at the start</span><span class="s1"> 
            history.insert(</span><span class="s4">0</span><span class="s3">, </span><span class="s1">r) 
            </span><span class="s0"># Get the last request made</span><span class="s1"> 
            r = history.pop() 
            r.history = history 
 
        </span><span class="s3">if not </span><span class="s1">stream: 
            r.content 
 
        </span><span class="s3">return </span><span class="s1">r 
 
    </span><span class="s3">def </span><span class="s1">merge_environment_settings(self</span><span class="s3">, </span><span class="s1">url</span><span class="s3">, </span><span class="s1">proxies</span><span class="s3">, </span><span class="s1">stream</span><span class="s3">, </span><span class="s1">verify</span><span class="s3">, </span><span class="s1">cert): 
        </span><span class="s2">&quot;&quot;&quot; 
        Check the environment and merge it with some settings. 
 
        :rtype: dict 
        &quot;&quot;&quot;</span><span class="s1"> 
        </span><span class="s0"># Gather clues from the surrounding environment.</span><span class="s1"> 
        </span><span class="s3">if </span><span class="s1">self.trust_env: 
            </span><span class="s0"># Set environment's proxies.</span><span class="s1"> 
            env_proxies = get_environ_proxies(url) </span><span class="s3">or </span><span class="s1">{} 
            </span><span class="s3">for </span><span class="s1">(k</span><span class="s3">, </span><span class="s1">v) </span><span class="s3">in </span><span class="s1">env_proxies.items(): 
                proxies.setdefault(k</span><span class="s3">, </span><span class="s1">v) 
 
            </span><span class="s0"># Look for requests environment configuration and be compatible</span><span class="s1"> 
            </span><span class="s0"># with cURL.</span><span class="s1"> 
            </span><span class="s3">if </span><span class="s1">verify </span><span class="s3">is True or </span><span class="s1">verify </span><span class="s3">is None</span><span class="s1">: 
                verify = (os.environ.get(</span><span class="s5">'REQUESTS_CA_BUNDLE'</span><span class="s1">) </span><span class="s3">or</span><span class="s1"> 
                          os.environ.get(</span><span class="s5">'CURL_CA_BUNDLE'</span><span class="s1">)) 
 
        </span><span class="s0"># Merge all the kwargs.</span><span class="s1"> 
        proxies = merge_setting(proxies</span><span class="s3">, </span><span class="s1">self.proxies) 
        stream = merge_setting(stream</span><span class="s3">, </span><span class="s1">self.stream) 
        verify = merge_setting(verify</span><span class="s3">, </span><span class="s1">self.verify) 
        cert = merge_setting(cert</span><span class="s3">, </span><span class="s1">self.cert) 
 
        </span><span class="s3">return </span><span class="s1">{</span><span class="s5">'verify'</span><span class="s1">: verify</span><span class="s3">, </span><span class="s5">'proxies'</span><span class="s1">: proxies</span><span class="s3">, </span><span class="s5">'stream'</span><span class="s1">: stream</span><span class="s3">,</span><span class="s1"> 
                </span><span class="s5">'cert'</span><span class="s1">: cert} 
 
    </span><span class="s3">def </span><span class="s1">get_adapter(self</span><span class="s3">, </span><span class="s1">url): 
        </span><span class="s2">&quot;&quot;&quot; 
        Returns the appropriate connection adapter for the given URL. 
 
        :rtype: requests.adapters.BaseAdapter 
        &quot;&quot;&quot;</span><span class="s1"> 
        </span><span class="s3">for </span><span class="s1">(prefix</span><span class="s3">, </span><span class="s1">adapter) </span><span class="s3">in </span><span class="s1">self.adapters.items(): 
 
            </span><span class="s3">if </span><span class="s1">url.lower().startswith(prefix): 
                </span><span class="s3">return </span><span class="s1">adapter 
 
        </span><span class="s0"># Nothing matches :-/</span><span class="s1"> 
        </span><span class="s3">raise </span><span class="s1">InvalidSchema(</span><span class="s5">&quot;No connection adapters were found for '%s'&quot; </span><span class="s1">% url) 
 
    </span><span class="s3">def </span><span class="s1">close(self): 
        </span><span class="s2">&quot;&quot;&quot;Closes all adapters and as such the session&quot;&quot;&quot;</span><span class="s1"> 
        </span><span class="s3">for </span><span class="s1">v </span><span class="s3">in </span><span class="s1">self.adapters.values(): 
            v.close() 
 
    </span><span class="s3">def </span><span class="s1">mount(self</span><span class="s3">, </span><span class="s1">prefix</span><span class="s3">, </span><span class="s1">adapter): 
        </span><span class="s2">&quot;&quot;&quot;Registers a connection adapter to a prefix. 
 
        Adapters are sorted in descending order by key length. 
        &quot;&quot;&quot;</span><span class="s1"> 
        self.adapters[prefix] = adapter 
        keys_to_move = [k </span><span class="s3">for </span><span class="s1">k </span><span class="s3">in </span><span class="s1">self.adapters </span><span class="s3">if </span><span class="s1">len(k) &lt; len(prefix)] 
 
        </span><span class="s3">for </span><span class="s1">key </span><span class="s3">in </span><span class="s1">keys_to_move: 
            self.adapters[key] = self.adapters.pop(key) 
 
    </span><span class="s3">def </span><span class="s1">__getstate__(self): 
        state = dict((attr</span><span class="s3">, </span><span class="s1">getattr(self</span><span class="s3">, </span><span class="s1">attr</span><span class="s3">, None</span><span class="s1">)) </span><span class="s3">for </span><span class="s1">attr </span><span class="s3">in </span><span class="s1">self.__attrs__) 
        state[</span><span class="s5">'redirect_cache'</span><span class="s1">] = dict(self.redirect_cache) 
        </span><span class="s3">return </span><span class="s1">state 
 
    </span><span class="s3">def </span><span class="s1">__setstate__(self</span><span class="s3">, </span><span class="s1">state): 
        redirect_cache = state.pop(</span><span class="s5">'redirect_cache'</span><span class="s3">, </span><span class="s1">{}) 
        </span><span class="s3">for </span><span class="s1">attr</span><span class="s3">, </span><span class="s1">value </span><span class="s3">in </span><span class="s1">state.items(): 
            setattr(self</span><span class="s3">, </span><span class="s1">attr</span><span class="s3">, </span><span class="s1">value) 
 
        self.redirect_cache = RecentlyUsedContainer(REDIRECT_CACHE_SIZE) 
        </span><span class="s3">for </span><span class="s1">redirect</span><span class="s3">, </span><span class="s1">to </span><span class="s3">in </span><span class="s1">redirect_cache.items(): 
            self.redirect_cache[redirect] = to 
 
 
</span><span class="s3">def </span><span class="s1">session(): 
    </span><span class="s2">&quot;&quot;&quot; 
    Returns a :class:`Session` for context-management. 
 
    :rtype: Session 
    &quot;&quot;&quot;</span><span class="s1"> 
 
    </span><span class="s3">return </span><span class="s1">Session() 
</span></pre>
</body>
</html>