<html>
<head>
<title>ssl_support.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.ln { color: #606366; font-weight: normal; font-style: normal; }
.s0 { color: rgb(204,120,50); }
.s1 { color: rgb(169,183,198); }
.s2 { color: rgb(106,135,89); }
.s3 { color: rgb(104,151,187); }
.s4 { color: rgb(98,151,85); font-style: italic; }
.s5 { color: rgb(128,128,128); }
</style>
</head>
<BODY BGCOLOR="#2b2b2b">
<TABLE CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<TR><TD><CENTER>
<FONT FACE="Arial, Helvetica" COLOR="#000000">
ssl_support.py</FONT>
</center></TD></TR></TABLE>
<pre>
<span class="s0">import </span><span class="s1">os 
</span><span class="s0">import </span><span class="s1">socket 
</span><span class="s0">import </span><span class="s1">atexit 
</span><span class="s0">import </span><span class="s1">re 
</span><span class="s0">import </span><span class="s1">functools 
 
</span><span class="s0">from </span><span class="s1">setuptools.extern.six.moves </span><span class="s0">import </span><span class="s1">urllib</span><span class="s0">, </span><span class="s1">http_client</span><span class="s0">, </span><span class="s1">map</span><span class="s0">, </span><span class="s1">filter 
 
</span><span class="s0">from </span><span class="s1">pkg_resources </span><span class="s0">import </span><span class="s1">ResolutionError</span><span class="s0">, </span><span class="s1">ExtractionError 
 
</span><span class="s0">try</span><span class="s1">: 
    </span><span class="s0">import </span><span class="s1">ssl 
</span><span class="s0">except </span><span class="s1">ImportError: 
    ssl = </span><span class="s0">None</span><span class="s1"> 
 
__all__ = [ 
    </span><span class="s2">'VerifyingHTTPSHandler'</span><span class="s0">, </span><span class="s2">'find_ca_bundle'</span><span class="s0">, </span><span class="s2">'is_available'</span><span class="s0">, </span><span class="s2">'cert_paths'</span><span class="s0">,</span><span class="s1"> 
    </span><span class="s2">'opener_for'</span><span class="s1"> 
] 
 
cert_paths = </span><span class="s2">&quot;&quot;&quot; 
/etc/pki/tls/certs/ca-bundle.crt 
/etc/ssl/certs/ca-certificates.crt 
/usr/share/ssl/certs/ca-bundle.crt 
/usr/local/share/certs/ca-root.crt 
/etc/ssl/cert.pem 
/System/Library/OpenSSL/certs/cert.pem 
/usr/local/share/certs/ca-root-nss.crt 
/etc/ssl/ca-bundle.pem 
&quot;&quot;&quot;</span><span class="s1">.strip().split() 
 
</span><span class="s0">try</span><span class="s1">: 
    HTTPSHandler = urllib.request.HTTPSHandler 
    HTTPSConnection = http_client.HTTPSConnection 
</span><span class="s0">except </span><span class="s1">AttributeError: 
    HTTPSHandler = HTTPSConnection = object 
 
is_available = ssl </span><span class="s0">is not None and </span><span class="s1">object </span><span class="s0">not in </span><span class="s1">(HTTPSHandler</span><span class="s0">, </span><span class="s1">HTTPSConnection) 
 
 
</span><span class="s0">try</span><span class="s1">: 
    </span><span class="s0">from </span><span class="s1">ssl </span><span class="s0">import </span><span class="s1">CertificateError</span><span class="s0">, </span><span class="s1">match_hostname 
</span><span class="s0">except </span><span class="s1">ImportError: 
    </span><span class="s0">try</span><span class="s1">: 
        </span><span class="s0">from </span><span class="s1">backports.ssl_match_hostname </span><span class="s0">import </span><span class="s1">CertificateError 
        </span><span class="s0">from </span><span class="s1">backports.ssl_match_hostname </span><span class="s0">import </span><span class="s1">match_hostname 
    </span><span class="s0">except </span><span class="s1">ImportError: 
        CertificateError = </span><span class="s0">None</span><span class="s1"> 
        match_hostname = </span><span class="s0">None</span><span class="s1"> 
 
</span><span class="s0">if not </span><span class="s1">CertificateError: 
 
    </span><span class="s0">class </span><span class="s1">CertificateError(ValueError): 
        </span><span class="s0">pass</span><span class="s1"> 
 
 
</span><span class="s0">if not </span><span class="s1">match_hostname: 
 
    </span><span class="s0">def </span><span class="s1">_dnsname_match(dn</span><span class="s0">, </span><span class="s1">hostname</span><span class="s0">, </span><span class="s1">max_wildcards=</span><span class="s3">1</span><span class="s1">): 
        </span><span class="s4">&quot;&quot;&quot;Matching according to RFC 6125, section 6.4.3 
 
        http://tools.ietf.org/html/rfc6125#section-6.4.3 
        &quot;&quot;&quot;</span><span class="s1"> 
        pats = [] 
        </span><span class="s0">if not </span><span class="s1">dn: 
            </span><span class="s0">return False</span><span class="s1"> 
 
        </span><span class="s5"># Ported from python3-syntax:</span><span class="s1"> 
        </span><span class="s5"># leftmost, *remainder = dn.split(r'.')</span><span class="s1"> 
        parts = dn.split(</span><span class="s2">r'.'</span><span class="s1">) 
        leftmost = parts[</span><span class="s3">0</span><span class="s1">] 
        remainder = parts[</span><span class="s3">1</span><span class="s1">:] 
 
        wildcards = leftmost.count(</span><span class="s2">'*'</span><span class="s1">) 
        </span><span class="s0">if </span><span class="s1">wildcards &gt; max_wildcards: 
            </span><span class="s5"># Issue #17980: avoid denials of service by refusing more</span><span class="s1"> 
            </span><span class="s5"># than one wildcard per fragment.  A survey of established</span><span class="s1"> 
            </span><span class="s5"># policy among SSL implementations showed it to be a</span><span class="s1"> 
            </span><span class="s5"># reasonable choice.</span><span class="s1"> 
            </span><span class="s0">raise </span><span class="s1">CertificateError( 
                </span><span class="s2">&quot;too many wildcards in certificate DNS name: &quot; </span><span class="s1">+ repr(dn)) 
 
        </span><span class="s5"># speed up common case w/o wildcards</span><span class="s1"> 
        </span><span class="s0">if not </span><span class="s1">wildcards: 
            </span><span class="s0">return </span><span class="s1">dn.lower() == hostname.lower() 
 
        </span><span class="s5"># RFC 6125, section 6.4.3, subitem 1.</span><span class="s1"> 
        </span><span class="s5"># The client SHOULD NOT attempt to match a presented identifier in which</span><span class="s1"> 
        </span><span class="s5"># the wildcard character comprises a label other than the left-most label.</span><span class="s1"> 
        </span><span class="s0">if </span><span class="s1">leftmost == </span><span class="s2">'*'</span><span class="s1">: 
            </span><span class="s5"># When '*' is a fragment by itself, it matches a non-empty dotless</span><span class="s1"> 
            </span><span class="s5"># fragment.</span><span class="s1"> 
            pats.append(</span><span class="s2">'[^.]+'</span><span class="s1">) 
        </span><span class="s0">elif </span><span class="s1">leftmost.startswith(</span><span class="s2">'xn--'</span><span class="s1">) </span><span class="s0">or </span><span class="s1">hostname.startswith(</span><span class="s2">'xn--'</span><span class="s1">): 
            </span><span class="s5"># RFC 6125, section 6.4.3, subitem 3.</span><span class="s1"> 
            </span><span class="s5"># The client SHOULD NOT attempt to match a presented identifier</span><span class="s1"> 
            </span><span class="s5"># where the wildcard character is embedded within an A-label or</span><span class="s1"> 
            </span><span class="s5"># U-label of an internationalized domain name.</span><span class="s1"> 
            pats.append(re.escape(leftmost)) 
        </span><span class="s0">else</span><span class="s1">: 
            </span><span class="s5"># Otherwise, '*' matches any dotless string, e.g. www*</span><span class="s1"> 
            pats.append(re.escape(leftmost).replace(</span><span class="s2">r'\*'</span><span class="s0">, </span><span class="s2">'[^.]*'</span><span class="s1">)) 
 
        </span><span class="s5"># add the remaining fragments, ignore any wildcards</span><span class="s1"> 
        </span><span class="s0">for </span><span class="s1">frag </span><span class="s0">in </span><span class="s1">remainder: 
            pats.append(re.escape(frag)) 
 
        pat = re.compile(</span><span class="s2">r'\A' </span><span class="s1">+ </span><span class="s2">r'\.'</span><span class="s1">.join(pats) + </span><span class="s2">r'\Z'</span><span class="s0">, </span><span class="s1">re.IGNORECASE) 
        </span><span class="s0">return </span><span class="s1">pat.match(hostname) 
 
    </span><span class="s0">def </span><span class="s1">match_hostname(cert</span><span class="s0">, </span><span class="s1">hostname): 
        </span><span class="s4">&quot;&quot;&quot;Verify that *cert* (in decoded format as returned by 
        SSLSocket.getpeercert()) matches the *hostname*.  RFC 2818 and RFC 6125 
        rules are followed, but IP addresses are not accepted for *hostname*. 
 
        CertificateError is raised on failure. On success, the function 
        returns nothing. 
        &quot;&quot;&quot;</span><span class="s1"> 
        </span><span class="s0">if not </span><span class="s1">cert: 
            </span><span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;empty or no certificate&quot;</span><span class="s1">) 
        dnsnames = [] 
        san = cert.get(</span><span class="s2">'subjectAltName'</span><span class="s0">, </span><span class="s1">()) 
        </span><span class="s0">for </span><span class="s1">key</span><span class="s0">, </span><span class="s1">value </span><span class="s0">in </span><span class="s1">san: 
            </span><span class="s0">if </span><span class="s1">key == </span><span class="s2">'DNS'</span><span class="s1">: 
                </span><span class="s0">if </span><span class="s1">_dnsname_match(value</span><span class="s0">, </span><span class="s1">hostname): 
                    </span><span class="s0">return</span><span class="s1"> 
                dnsnames.append(value) 
        </span><span class="s0">if not </span><span class="s1">dnsnames: 
            </span><span class="s5"># The subject is only checked when there is no dNSName entry</span><span class="s1"> 
            </span><span class="s5"># in subjectAltName</span><span class="s1"> 
            </span><span class="s0">for </span><span class="s1">sub </span><span class="s0">in </span><span class="s1">cert.get(</span><span class="s2">'subject'</span><span class="s0">, </span><span class="s1">()): 
                </span><span class="s0">for </span><span class="s1">key</span><span class="s0">, </span><span class="s1">value </span><span class="s0">in </span><span class="s1">sub: 
                    </span><span class="s5"># XXX according to RFC 2818, the most specific Common Name</span><span class="s1"> 
                    </span><span class="s5"># must be used.</span><span class="s1"> 
                    </span><span class="s0">if </span><span class="s1">key == </span><span class="s2">'commonName'</span><span class="s1">: 
                        </span><span class="s0">if </span><span class="s1">_dnsname_match(value</span><span class="s0">, </span><span class="s1">hostname): 
                            </span><span class="s0">return</span><span class="s1"> 
                        dnsnames.append(value) 
        </span><span class="s0">if </span><span class="s1">len(dnsnames) &gt; </span><span class="s3">1</span><span class="s1">: 
            </span><span class="s0">raise </span><span class="s1">CertificateError(</span><span class="s2">&quot;hostname %r &quot;</span><span class="s1"> 
                </span><span class="s2">&quot;doesn't match either of %s&quot;</span><span class="s1"> 
                % (hostname</span><span class="s0">, </span><span class="s2">', '</span><span class="s1">.join(map(repr</span><span class="s0">, </span><span class="s1">dnsnames)))) 
        </span><span class="s0">elif </span><span class="s1">len(dnsnames) == </span><span class="s3">1</span><span class="s1">: 
            </span><span class="s0">raise </span><span class="s1">CertificateError(</span><span class="s2">&quot;hostname %r &quot;</span><span class="s1"> 
                </span><span class="s2">&quot;doesn't match %r&quot;</span><span class="s1"> 
                % (hostname</span><span class="s0">, </span><span class="s1">dnsnames[</span><span class="s3">0</span><span class="s1">])) 
        </span><span class="s0">else</span><span class="s1">: 
            </span><span class="s0">raise </span><span class="s1">CertificateError(</span><span class="s2">&quot;no appropriate commonName or &quot;</span><span class="s1"> 
                </span><span class="s2">&quot;subjectAltName fields were found&quot;</span><span class="s1">) 
 
 
</span><span class="s0">class </span><span class="s1">VerifyingHTTPSHandler(HTTPSHandler): 
    </span><span class="s4">&quot;&quot;&quot;Simple verifying handler: no auth, subclasses, timeouts, etc.&quot;&quot;&quot;</span><span class="s1"> 
 
    </span><span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">ca_bundle): 
        self.ca_bundle = ca_bundle 
        HTTPSHandler.__init__(self) 
 
    </span><span class="s0">def </span><span class="s1">https_open(self</span><span class="s0">, </span><span class="s1">req): 
        </span><span class="s0">return </span><span class="s1">self.do_open( 
            </span><span class="s0">lambda </span><span class="s1">host</span><span class="s0">, </span><span class="s1">**kw: VerifyingHTTPSConn(host</span><span class="s0">, </span><span class="s1">self.ca_bundle</span><span class="s0">, </span><span class="s1">**kw)</span><span class="s0">, </span><span class="s1">req 
        ) 
 
 
</span><span class="s0">class </span><span class="s1">VerifyingHTTPSConn(HTTPSConnection): 
    </span><span class="s4">&quot;&quot;&quot;Simple verifying connection: no auth, subclasses, timeouts, etc.&quot;&quot;&quot;</span><span class="s1"> 
 
    </span><span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">host</span><span class="s0">, </span><span class="s1">ca_bundle</span><span class="s0">, </span><span class="s1">**kw): 
        HTTPSConnection.__init__(self</span><span class="s0">, </span><span class="s1">host</span><span class="s0">, </span><span class="s1">**kw) 
        self.ca_bundle = ca_bundle 
 
    </span><span class="s0">def </span><span class="s1">connect(self): 
        sock = socket.create_connection( 
            (self.host</span><span class="s0">, </span><span class="s1">self.port)</span><span class="s0">, </span><span class="s1">getattr(self</span><span class="s0">, </span><span class="s2">'source_address'</span><span class="s0">, None</span><span class="s1">) 
        ) 
 
        </span><span class="s5"># Handle the socket if a (proxy) tunnel is present</span><span class="s1"> 
        </span><span class="s0">if </span><span class="s1">hasattr(self</span><span class="s0">, </span><span class="s2">'_tunnel'</span><span class="s1">) </span><span class="s0">and </span><span class="s1">getattr(self</span><span class="s0">, </span><span class="s2">'_tunnel_host'</span><span class="s0">, None</span><span class="s1">): 
            self.sock = sock 
            self._tunnel() 
            </span><span class="s5"># http://bugs.python.org/issue7776: Python&gt;=3.4.1 and &gt;=2.7.7</span><span class="s1"> 
            </span><span class="s5"># change self.host to mean the proxy server host when tunneling is</span><span class="s1"> 
            </span><span class="s5"># being used. Adapt, since we are interested in the destination</span><span class="s1"> 
            </span><span class="s5"># host for the match_hostname() comparison.</span><span class="s1"> 
            actual_host = self._tunnel_host 
        </span><span class="s0">else</span><span class="s1">: 
            actual_host = self.host 
 
        </span><span class="s0">if </span><span class="s1">hasattr(ssl</span><span class="s0">, </span><span class="s2">'create_default_context'</span><span class="s1">): 
            ctx = ssl.create_default_context(cafile=self.ca_bundle) 
            self.sock = ctx.wrap_socket(sock</span><span class="s0">, </span><span class="s1">server_hostname=actual_host) 
        </span><span class="s0">else</span><span class="s1">: 
            </span><span class="s5"># This is for python &lt; 2.7.9 and &lt; 3.4?</span><span class="s1"> 
            self.sock = ssl.wrap_socket( 
                sock</span><span class="s0">, </span><span class="s1">cert_reqs=ssl.CERT_REQUIRED</span><span class="s0">, </span><span class="s1">ca_certs=self.ca_bundle 
            ) 
        </span><span class="s0">try</span><span class="s1">: 
            match_hostname(self.sock.getpeercert()</span><span class="s0">, </span><span class="s1">actual_host) 
        </span><span class="s0">except </span><span class="s1">CertificateError: 
            self.sock.shutdown(socket.SHUT_RDWR) 
            self.sock.close() 
            </span><span class="s0">raise</span><span class="s1"> 
 
 
</span><span class="s0">def </span><span class="s1">opener_for(ca_bundle=</span><span class="s0">None</span><span class="s1">): 
    </span><span class="s4">&quot;&quot;&quot;Get a urlopen() replacement that uses ca_bundle for verification&quot;&quot;&quot;</span><span class="s1"> 
    </span><span class="s0">return </span><span class="s1">urllib.request.build_opener( 
        VerifyingHTTPSHandler(ca_bundle </span><span class="s0">or </span><span class="s1">find_ca_bundle()) 
    ).open 
 
 
</span><span class="s5"># from jaraco.functools</span><span class="s1"> 
</span><span class="s0">def </span><span class="s1">once(func): 
    @functools.wraps(func) 
    </span><span class="s0">def </span><span class="s1">wrapper(*args</span><span class="s0">, </span><span class="s1">**kwargs): 
        </span><span class="s0">if not </span><span class="s1">hasattr(func</span><span class="s0">, </span><span class="s2">'always_returns'</span><span class="s1">): 
            func.always_returns = func(*args</span><span class="s0">, </span><span class="s1">**kwargs) 
        </span><span class="s0">return </span><span class="s1">func.always_returns 
    </span><span class="s0">return </span><span class="s1">wrapper 
 
 
@once 
</span><span class="s0">def </span><span class="s1">get_win_certfile(): 
    </span><span class="s0">try</span><span class="s1">: 
        </span><span class="s0">import </span><span class="s1">wincertstore 
    </span><span class="s0">except </span><span class="s1">ImportError: 
        </span><span class="s0">return None</span><span class="s1"> 
 
    </span><span class="s0">class </span><span class="s1">CertFile(wincertstore.CertFile): 
        </span><span class="s0">def </span><span class="s1">__init__(self): 
            super(CertFile</span><span class="s0">, </span><span class="s1">self).__init__() 
            atexit.register(self.close) 
 
        </span><span class="s0">def </span><span class="s1">close(self): 
            </span><span class="s0">try</span><span class="s1">: 
                super(CertFile</span><span class="s0">, </span><span class="s1">self).close() 
            </span><span class="s0">except </span><span class="s1">OSError: 
                </span><span class="s0">pass</span><span class="s1"> 
 
    _wincerts = CertFile() 
    _wincerts.addstore(</span><span class="s2">'CA'</span><span class="s1">) 
    _wincerts.addstore(</span><span class="s2">'ROOT'</span><span class="s1">) 
    </span><span class="s0">return </span><span class="s1">_wincerts.name 
 
 
</span><span class="s0">def </span><span class="s1">find_ca_bundle(): 
    </span><span class="s4">&quot;&quot;&quot;Return an existing CA bundle path, or None&quot;&quot;&quot;</span><span class="s1"> 
    extant_cert_paths = filter(os.path.isfile</span><span class="s0">, </span><span class="s1">cert_paths) 
    </span><span class="s0">return </span><span class="s1">( 
        get_win_certfile() 
        </span><span class="s0">or </span><span class="s1">next(extant_cert_paths</span><span class="s0">, None</span><span class="s1">) 
        </span><span class="s0">or </span><span class="s1">_certifi_where() 
    ) 
 
 
</span><span class="s0">def </span><span class="s1">_certifi_where(): 
    </span><span class="s0">try</span><span class="s1">: 
        </span><span class="s0">return </span><span class="s1">__import__(</span><span class="s2">'certifi'</span><span class="s1">).where() 
    </span><span class="s0">except </span><span class="s1">(ImportError</span><span class="s0">, </span><span class="s1">ResolutionError</span><span class="s0">, </span><span class="s1">ExtractionError): 
        </span><span class="s0">pass</span><span class="s1"> 
</span></pre>
</body>
</html>