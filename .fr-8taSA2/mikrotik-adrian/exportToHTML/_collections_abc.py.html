<html>
<head>
<title>_collections_abc.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.ln { color: #606366; font-weight: normal; font-style: normal; }
.s0 { color: rgb(128,128,128); }
.s1 { color: rgb(169,183,198); }
.s2 { color: rgb(98,151,85); font-style: italic; }
.s3 { color: rgb(204,120,50); }
.s4 { color: rgb(106,135,89); }
.s5 { color: rgb(165,194,97); }
.s6 { color: rgb(104,151,187); }
</style>
</head>
<BODY BGCOLOR="#2b2b2b">
<TABLE CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<TR><TD><CENTER>
<FONT FACE="Arial, Helvetica" COLOR="#000000">
_collections_abc.py</FONT>
</center></TD></TR></TABLE>
<pre>
<span class="s0"># Copyright 2007 Google, Inc. All Rights Reserved.</span><span class="s1"> 
</span><span class="s0"># Licensed to PSF under a Contributor Agreement.</span><span class="s1"> 
 
</span><span class="s2">&quot;&quot;&quot;Abstract Base Classes (ABCs) for collections, according to PEP 3119. 
 
Unit tests are in test_collections. 
&quot;&quot;&quot;</span><span class="s1"> 
 
</span><span class="s3">from </span><span class="s1">abc </span><span class="s3">import </span><span class="s1">ABCMeta</span><span class="s3">, </span><span class="s1">abstractmethod 
</span><span class="s3">import </span><span class="s1">sys 
 
__all__ = [</span><span class="s4">&quot;Awaitable&quot;</span><span class="s3">, </span><span class="s4">&quot;Coroutine&quot;</span><span class="s3">, </span><span class="s4">&quot;AsyncIterable&quot;</span><span class="s3">, </span><span class="s4">&quot;AsyncIterator&quot;</span><span class="s3">,</span><span class="s1"> 
           </span><span class="s4">&quot;Hashable&quot;</span><span class="s3">, </span><span class="s4">&quot;Iterable&quot;</span><span class="s3">, </span><span class="s4">&quot;Iterator&quot;</span><span class="s3">, </span><span class="s4">&quot;Generator&quot;</span><span class="s3">,</span><span class="s1"> 
           </span><span class="s4">&quot;Sized&quot;</span><span class="s3">, </span><span class="s4">&quot;Container&quot;</span><span class="s3">, </span><span class="s4">&quot;Callable&quot;</span><span class="s3">,</span><span class="s1"> 
           </span><span class="s4">&quot;Set&quot;</span><span class="s3">, </span><span class="s4">&quot;MutableSet&quot;</span><span class="s3">,</span><span class="s1"> 
           </span><span class="s4">&quot;Mapping&quot;</span><span class="s3">, </span><span class="s4">&quot;MutableMapping&quot;</span><span class="s3">,</span><span class="s1"> 
           </span><span class="s4">&quot;MappingView&quot;</span><span class="s3">, </span><span class="s4">&quot;KeysView&quot;</span><span class="s3">, </span><span class="s4">&quot;ItemsView&quot;</span><span class="s3">, </span><span class="s4">&quot;ValuesView&quot;</span><span class="s3">,</span><span class="s1"> 
           </span><span class="s4">&quot;Sequence&quot;</span><span class="s3">, </span><span class="s4">&quot;MutableSequence&quot;</span><span class="s3">,</span><span class="s1"> 
           </span><span class="s4">&quot;ByteString&quot;</span><span class="s3">,</span><span class="s1"> 
           ] 
 
</span><span class="s0"># This module has been renamed from collections.abc to _collections_abc to</span><span class="s1"> 
</span><span class="s0"># speed up interpreter startup. Some of the types such as MutableMapping are</span><span class="s1"> 
</span><span class="s0"># required early but collections module imports a lot of other modules.</span><span class="s1"> 
</span><span class="s0"># See issue #19218</span><span class="s1"> 
__name__ = </span><span class="s4">&quot;collections.abc&quot;</span><span class="s1"> 
 
</span><span class="s0"># Private list of types that we want to register with the various ABCs</span><span class="s1"> 
</span><span class="s0"># so that they will pass tests like:</span><span class="s1"> 
</span><span class="s0">#       it = iter(somebytearray)</span><span class="s1"> 
</span><span class="s0">#       assert isinstance(it, Iterable)</span><span class="s1"> 
</span><span class="s0"># Note:  in other implementations, these types many not be distinct</span><span class="s1"> 
</span><span class="s0"># and they make have their own implementation specific types that</span><span class="s1"> 
</span><span class="s0"># are not included on this list.</span><span class="s1"> 
bytes_iterator = type(iter(</span><span class="s5">b''</span><span class="s1">)) 
bytearray_iterator = type(iter(bytearray())) 
</span><span class="s0">#callable_iterator = ???</span><span class="s1"> 
dict_keyiterator = type(iter({}.keys())) 
dict_valueiterator = type(iter({}.values())) 
dict_itemiterator = type(iter({}.items())) 
list_iterator = type(iter([])) 
list_reverseiterator = type(iter(reversed([]))) 
range_iterator = type(iter(range(</span><span class="s6">0</span><span class="s1">))) 
set_iterator = type(iter(set())) 
str_iterator = type(iter(</span><span class="s4">&quot;&quot;</span><span class="s1">)) 
tuple_iterator = type(iter(())) 
zip_iterator = type(iter(zip())) 
</span><span class="s0">## views ##</span><span class="s1"> 
dict_keys = type({}.keys()) 
dict_values = type({}.values()) 
dict_items = type({}.items()) 
</span><span class="s0">## misc ##</span><span class="s1"> 
mappingproxy = type(type.__dict__) 
generator = type((</span><span class="s3">lambda</span><span class="s1">: (</span><span class="s3">yield</span><span class="s1">))()) 
</span><span class="s0">## coroutine ##</span><span class="s1"> 
async </span><span class="s3">def </span><span class="s1">_coro(): </span><span class="s3">pass</span><span class="s1"> 
_coro = _coro() 
coroutine = type(_coro) 
_coro.close()  </span><span class="s0"># Prevent ResourceWarning</span><span class="s1"> 
</span><span class="s3">del </span><span class="s1">_coro 
 
 
</span><span class="s0">### ONE-TRICK PONIES ###</span><span class="s1"> 
 
</span><span class="s3">class </span><span class="s1">Hashable(metaclass=ABCMeta): 
 
    __slots__ = () 
 
    @abstractmethod 
    </span><span class="s3">def </span><span class="s1">__hash__(self): 
        </span><span class="s3">return </span><span class="s6">0</span><span class="s1"> 
 
    @classmethod 
    </span><span class="s3">def </span><span class="s1">__subclasshook__(cls</span><span class="s3">, </span><span class="s1">C): 
        </span><span class="s3">if </span><span class="s1">cls </span><span class="s3">is </span><span class="s1">Hashable: 
            </span><span class="s3">for </span><span class="s1">B </span><span class="s3">in </span><span class="s1">C.__mro__: 
                </span><span class="s3">if </span><span class="s4">&quot;__hash__&quot; </span><span class="s3">in </span><span class="s1">B.__dict__: 
                    </span><span class="s3">if </span><span class="s1">B.__dict__[</span><span class="s4">&quot;__hash__&quot;</span><span class="s1">]: 
                        </span><span class="s3">return True</span><span class="s1"> 
                    </span><span class="s3">break</span><span class="s1"> 
        </span><span class="s3">return </span><span class="s1">NotImplemented 
 
 
</span><span class="s3">class </span><span class="s1">Awaitable(metaclass=ABCMeta): 
 
    __slots__ = () 
 
    @abstractmethod 
    </span><span class="s3">def </span><span class="s1">__await__(self): 
        </span><span class="s3">yield</span><span class="s1"> 
 
    @classmethod 
    </span><span class="s3">def </span><span class="s1">__subclasshook__(cls</span><span class="s3">, </span><span class="s1">C): 
        </span><span class="s3">if </span><span class="s1">cls </span><span class="s3">is </span><span class="s1">Awaitable: 
            </span><span class="s3">for </span><span class="s1">B </span><span class="s3">in </span><span class="s1">C.__mro__: 
                </span><span class="s3">if </span><span class="s4">&quot;__await__&quot; </span><span class="s3">in </span><span class="s1">B.__dict__: 
                    </span><span class="s3">if </span><span class="s1">B.__dict__[</span><span class="s4">&quot;__await__&quot;</span><span class="s1">]: 
                        </span><span class="s3">return True</span><span class="s1"> 
                    </span><span class="s3">break</span><span class="s1"> 
        </span><span class="s3">return </span><span class="s1">NotImplemented 
 
 
</span><span class="s3">class </span><span class="s1">Coroutine(Awaitable): 
 
    __slots__ = () 
 
    @abstractmethod 
    </span><span class="s3">def </span><span class="s1">send(self</span><span class="s3">, </span><span class="s1">value): 
        </span><span class="s2">&quot;&quot;&quot;Send a value into the coroutine. 
        Return next yielded value or raise StopIteration. 
        &quot;&quot;&quot;</span><span class="s1"> 
        </span><span class="s3">raise </span><span class="s1">StopIteration 
 
    @abstractmethod 
    </span><span class="s3">def </span><span class="s1">throw(self</span><span class="s3">, </span><span class="s1">typ</span><span class="s3">, </span><span class="s1">val=</span><span class="s3">None, </span><span class="s1">tb=</span><span class="s3">None</span><span class="s1">): 
        </span><span class="s2">&quot;&quot;&quot;Raise an exception in the coroutine. 
        Return next yielded value or raise StopIteration. 
        &quot;&quot;&quot;</span><span class="s1"> 
        </span><span class="s3">if </span><span class="s1">val </span><span class="s3">is None</span><span class="s1">: 
            </span><span class="s3">if </span><span class="s1">tb </span><span class="s3">is None</span><span class="s1">: 
                </span><span class="s3">raise </span><span class="s1">typ 
            val = typ() 
        </span><span class="s3">if </span><span class="s1">tb </span><span class="s3">is not None</span><span class="s1">: 
            val = val.with_traceback(tb) 
        </span><span class="s3">raise </span><span class="s1">val 
 
    </span><span class="s3">def </span><span class="s1">close(self): 
        </span><span class="s2">&quot;&quot;&quot;Raise GeneratorExit inside coroutine. 
        &quot;&quot;&quot;</span><span class="s1"> 
        </span><span class="s3">try</span><span class="s1">: 
            self.throw(GeneratorExit) 
        </span><span class="s3">except </span><span class="s1">(GeneratorExit</span><span class="s3">, </span><span class="s1">StopIteration): 
            </span><span class="s3">pass</span><span class="s1"> 
        </span><span class="s3">else</span><span class="s1">: 
            </span><span class="s3">raise </span><span class="s1">RuntimeError(</span><span class="s4">&quot;coroutine ignored GeneratorExit&quot;</span><span class="s1">) 
 
    @classmethod 
    </span><span class="s3">def </span><span class="s1">__subclasshook__(cls</span><span class="s3">, </span><span class="s1">C): 
        </span><span class="s3">if </span><span class="s1">cls </span><span class="s3">is </span><span class="s1">Coroutine: 
            mro = C.__mro__ 
            </span><span class="s3">for </span><span class="s1">method </span><span class="s3">in </span><span class="s1">(</span><span class="s4">'__await__'</span><span class="s3">, </span><span class="s4">'send'</span><span class="s3">, </span><span class="s4">'throw'</span><span class="s3">, </span><span class="s4">'close'</span><span class="s1">): 
                </span><span class="s3">for </span><span class="s1">base </span><span class="s3">in </span><span class="s1">mro: 
                    </span><span class="s3">if </span><span class="s1">method </span><span class="s3">in </span><span class="s1">base.__dict__: 
                        </span><span class="s3">break</span><span class="s1"> 
                </span><span class="s3">else</span><span class="s1">: 
                    </span><span class="s3">return </span><span class="s1">NotImplemented 
            </span><span class="s3">return True</span><span class="s1"> 
        </span><span class="s3">return </span><span class="s1">NotImplemented 
 
 
Coroutine.register(coroutine) 
 
 
</span><span class="s3">class </span><span class="s1">AsyncIterable(metaclass=ABCMeta): 
 
    __slots__ = () 
 
    @abstractmethod 
    </span><span class="s3">def </span><span class="s1">__aiter__(self): 
        </span><span class="s3">return </span><span class="s1">AsyncIterator() 
 
    @classmethod 
    </span><span class="s3">def </span><span class="s1">__subclasshook__(cls</span><span class="s3">, </span><span class="s1">C): 
        </span><span class="s3">if </span><span class="s1">cls </span><span class="s3">is </span><span class="s1">AsyncIterable: 
            </span><span class="s3">if </span><span class="s1">any(</span><span class="s4">&quot;__aiter__&quot; </span><span class="s3">in </span><span class="s1">B.__dict__ </span><span class="s3">for </span><span class="s1">B </span><span class="s3">in </span><span class="s1">C.__mro__): 
                </span><span class="s3">return True</span><span class="s1"> 
        </span><span class="s3">return </span><span class="s1">NotImplemented 
 
 
</span><span class="s3">class </span><span class="s1">AsyncIterator(AsyncIterable): 
 
    __slots__ = () 
 
    @abstractmethod 
    async </span><span class="s3">def </span><span class="s1">__anext__(self): 
        </span><span class="s2">&quot;&quot;&quot;Return the next item or raise StopAsyncIteration when exhausted.&quot;&quot;&quot;</span><span class="s1"> 
        </span><span class="s3">raise </span><span class="s1">StopAsyncIteration 
 
    </span><span class="s3">def </span><span class="s1">__aiter__(self): 
        </span><span class="s3">return </span><span class="s1">self 
 
    @classmethod 
    </span><span class="s3">def </span><span class="s1">__subclasshook__(cls</span><span class="s3">, </span><span class="s1">C): 
        </span><span class="s3">if </span><span class="s1">cls </span><span class="s3">is </span><span class="s1">AsyncIterator: 
            </span><span class="s3">if </span><span class="s1">(any(</span><span class="s4">&quot;__anext__&quot; </span><span class="s3">in </span><span class="s1">B.__dict__ </span><span class="s3">for </span><span class="s1">B </span><span class="s3">in </span><span class="s1">C.__mro__) </span><span class="s3">and</span><span class="s1"> 
                any(</span><span class="s4">&quot;__aiter__&quot; </span><span class="s3">in </span><span class="s1">B.__dict__ </span><span class="s3">for </span><span class="s1">B </span><span class="s3">in </span><span class="s1">C.__mro__)): 
                </span><span class="s3">return True</span><span class="s1"> 
        </span><span class="s3">return </span><span class="s1">NotImplemented 
 
 
</span><span class="s3">class </span><span class="s1">Iterable(metaclass=ABCMeta): 
 
    __slots__ = () 
 
    @abstractmethod 
    </span><span class="s3">def </span><span class="s1">__iter__(self): 
        </span><span class="s3">while False</span><span class="s1">: 
            </span><span class="s3">yield None</span><span class="s1"> 
 
    @classmethod 
    </span><span class="s3">def </span><span class="s1">__subclasshook__(cls</span><span class="s3">, </span><span class="s1">C): 
        </span><span class="s3">if </span><span class="s1">cls </span><span class="s3">is </span><span class="s1">Iterable: 
            </span><span class="s3">if </span><span class="s1">any(</span><span class="s4">&quot;__iter__&quot; </span><span class="s3">in </span><span class="s1">B.__dict__ </span><span class="s3">for </span><span class="s1">B </span><span class="s3">in </span><span class="s1">C.__mro__): 
                </span><span class="s3">return True</span><span class="s1"> 
        </span><span class="s3">return </span><span class="s1">NotImplemented 
 
 
</span><span class="s3">class </span><span class="s1">Iterator(Iterable): 
 
    __slots__ = () 
 
    @abstractmethod 
    </span><span class="s3">def </span><span class="s1">__next__(self): 
        </span><span class="s2">'Return the next item from the iterator. When exhausted, raise StopIteration'</span><span class="s1"> 
        </span><span class="s3">raise </span><span class="s1">StopIteration 
 
    </span><span class="s3">def </span><span class="s1">__iter__(self): 
        </span><span class="s3">return </span><span class="s1">self 
 
    @classmethod 
    </span><span class="s3">def </span><span class="s1">__subclasshook__(cls</span><span class="s3">, </span><span class="s1">C): 
        </span><span class="s3">if </span><span class="s1">cls </span><span class="s3">is </span><span class="s1">Iterator: 
            </span><span class="s3">if </span><span class="s1">(any(</span><span class="s4">&quot;__next__&quot; </span><span class="s3">in </span><span class="s1">B.__dict__ </span><span class="s3">for </span><span class="s1">B </span><span class="s3">in </span><span class="s1">C.__mro__) </span><span class="s3">and</span><span class="s1"> 
                any(</span><span class="s4">&quot;__iter__&quot; </span><span class="s3">in </span><span class="s1">B.__dict__ </span><span class="s3">for </span><span class="s1">B </span><span class="s3">in </span><span class="s1">C.__mro__)): 
                </span><span class="s3">return True</span><span class="s1"> 
        </span><span class="s3">return </span><span class="s1">NotImplemented 
 
Iterator.register(bytes_iterator) 
Iterator.register(bytearray_iterator) 
</span><span class="s0">#Iterator.register(callable_iterator)</span><span class="s1"> 
Iterator.register(dict_keyiterator) 
Iterator.register(dict_valueiterator) 
Iterator.register(dict_itemiterator) 
Iterator.register(list_iterator) 
Iterator.register(list_reverseiterator) 
Iterator.register(range_iterator) 
Iterator.register(set_iterator) 
Iterator.register(str_iterator) 
Iterator.register(tuple_iterator) 
Iterator.register(zip_iterator) 
 
 
</span><span class="s3">class </span><span class="s1">Generator(Iterator): 
 
    __slots__ = () 
 
    </span><span class="s3">def </span><span class="s1">__next__(self): 
        </span><span class="s2">&quot;&quot;&quot;Return the next item from the generator. 
        When exhausted, raise StopIteration. 
        &quot;&quot;&quot;</span><span class="s1"> 
        </span><span class="s3">return </span><span class="s1">self.send(</span><span class="s3">None</span><span class="s1">) 
 
    @abstractmethod 
    </span><span class="s3">def </span><span class="s1">send(self</span><span class="s3">, </span><span class="s1">value): 
        </span><span class="s2">&quot;&quot;&quot;Send a value into the generator. 
        Return next yielded value or raise StopIteration. 
        &quot;&quot;&quot;</span><span class="s1"> 
        </span><span class="s3">raise </span><span class="s1">StopIteration 
 
    @abstractmethod 
    </span><span class="s3">def </span><span class="s1">throw(self</span><span class="s3">, </span><span class="s1">typ</span><span class="s3">, </span><span class="s1">val=</span><span class="s3">None, </span><span class="s1">tb=</span><span class="s3">None</span><span class="s1">): 
        </span><span class="s2">&quot;&quot;&quot;Raise an exception in the generator. 
        Return next yielded value or raise StopIteration. 
        &quot;&quot;&quot;</span><span class="s1"> 
        </span><span class="s3">if </span><span class="s1">val </span><span class="s3">is None</span><span class="s1">: 
            </span><span class="s3">if </span><span class="s1">tb </span><span class="s3">is None</span><span class="s1">: 
                </span><span class="s3">raise </span><span class="s1">typ 
            val = typ() 
        </span><span class="s3">if </span><span class="s1">tb </span><span class="s3">is not None</span><span class="s1">: 
            val = val.with_traceback(tb) 
        </span><span class="s3">raise </span><span class="s1">val 
 
    </span><span class="s3">def </span><span class="s1">close(self): 
        </span><span class="s2">&quot;&quot;&quot;Raise GeneratorExit inside generator. 
        &quot;&quot;&quot;</span><span class="s1"> 
        </span><span class="s3">try</span><span class="s1">: 
            self.throw(GeneratorExit) 
        </span><span class="s3">except </span><span class="s1">(GeneratorExit</span><span class="s3">, </span><span class="s1">StopIteration): 
            </span><span class="s3">pass</span><span class="s1"> 
        </span><span class="s3">else</span><span class="s1">: 
            </span><span class="s3">raise </span><span class="s1">RuntimeError(</span><span class="s4">&quot;generator ignored GeneratorExit&quot;</span><span class="s1">) 
 
    @classmethod 
    </span><span class="s3">def </span><span class="s1">__subclasshook__(cls</span><span class="s3">, </span><span class="s1">C): 
        </span><span class="s3">if </span><span class="s1">cls </span><span class="s3">is </span><span class="s1">Generator: 
            mro = C.__mro__ 
            </span><span class="s3">for </span><span class="s1">method </span><span class="s3">in </span><span class="s1">(</span><span class="s4">'__iter__'</span><span class="s3">, </span><span class="s4">'__next__'</span><span class="s3">, </span><span class="s4">'send'</span><span class="s3">, </span><span class="s4">'throw'</span><span class="s3">, </span><span class="s4">'close'</span><span class="s1">): 
                </span><span class="s3">for </span><span class="s1">base </span><span class="s3">in </span><span class="s1">mro: 
                    </span><span class="s3">if </span><span class="s1">method </span><span class="s3">in </span><span class="s1">base.__dict__: 
                        </span><span class="s3">break</span><span class="s1"> 
                </span><span class="s3">else</span><span class="s1">: 
                    </span><span class="s3">return </span><span class="s1">NotImplemented 
            </span><span class="s3">return True</span><span class="s1"> 
        </span><span class="s3">return </span><span class="s1">NotImplemented 
 
 
Generator.register(generator) 
 
 
</span><span class="s3">class </span><span class="s1">Sized(metaclass=ABCMeta): 
 
    __slots__ = () 
 
    @abstractmethod 
    </span><span class="s3">def </span><span class="s1">__len__(self): 
        </span><span class="s3">return </span><span class="s6">0</span><span class="s1"> 
 
    @classmethod 
    </span><span class="s3">def </span><span class="s1">__subclasshook__(cls</span><span class="s3">, </span><span class="s1">C): 
        </span><span class="s3">if </span><span class="s1">cls </span><span class="s3">is </span><span class="s1">Sized: 
            </span><span class="s3">if </span><span class="s1">any(</span><span class="s4">&quot;__len__&quot; </span><span class="s3">in </span><span class="s1">B.__dict__ </span><span class="s3">for </span><span class="s1">B </span><span class="s3">in </span><span class="s1">C.__mro__): 
                </span><span class="s3">return True</span><span class="s1"> 
        </span><span class="s3">return </span><span class="s1">NotImplemented 
 
 
</span><span class="s3">class </span><span class="s1">Container(metaclass=ABCMeta): 
 
    __slots__ = () 
 
    @abstractmethod 
    </span><span class="s3">def </span><span class="s1">__contains__(self</span><span class="s3">, </span><span class="s1">x): 
        </span><span class="s3">return False</span><span class="s1"> 
 
    @classmethod 
    </span><span class="s3">def </span><span class="s1">__subclasshook__(cls</span><span class="s3">, </span><span class="s1">C): 
        </span><span class="s3">if </span><span class="s1">cls </span><span class="s3">is </span><span class="s1">Container: 
            </span><span class="s3">if </span><span class="s1">any(</span><span class="s4">&quot;__contains__&quot; </span><span class="s3">in </span><span class="s1">B.__dict__ </span><span class="s3">for </span><span class="s1">B </span><span class="s3">in </span><span class="s1">C.__mro__): 
                </span><span class="s3">return True</span><span class="s1"> 
        </span><span class="s3">return </span><span class="s1">NotImplemented 
 
 
</span><span class="s3">class </span><span class="s1">Callable(metaclass=ABCMeta): 
 
    __slots__ = () 
 
    @abstractmethod 
    </span><span class="s3">def </span><span class="s1">__call__(self</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kwds): 
        </span><span class="s3">return False</span><span class="s1"> 
 
    @classmethod 
    </span><span class="s3">def </span><span class="s1">__subclasshook__(cls</span><span class="s3">, </span><span class="s1">C): 
        </span><span class="s3">if </span><span class="s1">cls </span><span class="s3">is </span><span class="s1">Callable: 
            </span><span class="s3">if </span><span class="s1">any(</span><span class="s4">&quot;__call__&quot; </span><span class="s3">in </span><span class="s1">B.__dict__ </span><span class="s3">for </span><span class="s1">B </span><span class="s3">in </span><span class="s1">C.__mro__): 
                </span><span class="s3">return True</span><span class="s1"> 
        </span><span class="s3">return </span><span class="s1">NotImplemented 
 
 
</span><span class="s0">### SETS ###</span><span class="s1"> 
 
 
</span><span class="s3">class </span><span class="s1">Set(Sized</span><span class="s3">, </span><span class="s1">Iterable</span><span class="s3">, </span><span class="s1">Container): 
 
    </span><span class="s2">&quot;&quot;&quot;A set is a finite, iterable container. 
 
    This class provides concrete generic implementations of all 
    methods except for __contains__, __iter__ and __len__. 
 
    To override the comparisons (presumably for speed, as the 
    semantics are fixed), redefine __le__ and __ge__, 
    then the other operations will automatically follow suit. 
    &quot;&quot;&quot;</span><span class="s1"> 
 
    __slots__ = () 
 
    </span><span class="s3">def </span><span class="s1">__le__(self</span><span class="s3">, </span><span class="s1">other): 
        </span><span class="s3">if not </span><span class="s1">isinstance(other</span><span class="s3">, </span><span class="s1">Set): 
            </span><span class="s3">return </span><span class="s1">NotImplemented 
        </span><span class="s3">if </span><span class="s1">len(self) &gt; len(other): 
            </span><span class="s3">return False</span><span class="s1"> 
        </span><span class="s3">for </span><span class="s1">elem </span><span class="s3">in </span><span class="s1">self: 
            </span><span class="s3">if </span><span class="s1">elem </span><span class="s3">not in </span><span class="s1">other: 
                </span><span class="s3">return False</span><span class="s1"> 
        </span><span class="s3">return True</span><span class="s1"> 
 
    </span><span class="s3">def </span><span class="s1">__lt__(self</span><span class="s3">, </span><span class="s1">other): 
        </span><span class="s3">if not </span><span class="s1">isinstance(other</span><span class="s3">, </span><span class="s1">Set): 
            </span><span class="s3">return </span><span class="s1">NotImplemented 
        </span><span class="s3">return </span><span class="s1">len(self) &lt; len(other) </span><span class="s3">and </span><span class="s1">self.__le__(other) 
 
    </span><span class="s3">def </span><span class="s1">__gt__(self</span><span class="s3">, </span><span class="s1">other): 
        </span><span class="s3">if not </span><span class="s1">isinstance(other</span><span class="s3">, </span><span class="s1">Set): 
            </span><span class="s3">return </span><span class="s1">NotImplemented 
        </span><span class="s3">return </span><span class="s1">len(self) &gt; len(other) </span><span class="s3">and </span><span class="s1">self.__ge__(other) 
 
    </span><span class="s3">def </span><span class="s1">__ge__(self</span><span class="s3">, </span><span class="s1">other): 
        </span><span class="s3">if not </span><span class="s1">isinstance(other</span><span class="s3">, </span><span class="s1">Set): 
            </span><span class="s3">return </span><span class="s1">NotImplemented 
        </span><span class="s3">if </span><span class="s1">len(self) &lt; len(other): 
            </span><span class="s3">return False</span><span class="s1"> 
        </span><span class="s3">for </span><span class="s1">elem </span><span class="s3">in </span><span class="s1">other: 
            </span><span class="s3">if </span><span class="s1">elem </span><span class="s3">not in </span><span class="s1">self: 
                </span><span class="s3">return False</span><span class="s1"> 
        </span><span class="s3">return True</span><span class="s1"> 
 
    </span><span class="s3">def </span><span class="s1">__eq__(self</span><span class="s3">, </span><span class="s1">other): 
        </span><span class="s3">if not </span><span class="s1">isinstance(other</span><span class="s3">, </span><span class="s1">Set): 
            </span><span class="s3">return </span><span class="s1">NotImplemented 
        </span><span class="s3">return </span><span class="s1">len(self) == len(other) </span><span class="s3">and </span><span class="s1">self.__le__(other) 
 
    @classmethod 
    </span><span class="s3">def </span><span class="s1">_from_iterable(cls</span><span class="s3">, </span><span class="s1">it): 
        </span><span class="s2">'''Construct an instance of the class from any iterable input. 
 
        Must override this method if the class constructor signature 
        does not accept an iterable for an input. 
        '''</span><span class="s1"> 
        </span><span class="s3">return </span><span class="s1">cls(it) 
 
    </span><span class="s3">def </span><span class="s1">__and__(self</span><span class="s3">, </span><span class="s1">other): 
        </span><span class="s3">if not </span><span class="s1">isinstance(other</span><span class="s3">, </span><span class="s1">Iterable): 
            </span><span class="s3">return </span><span class="s1">NotImplemented 
        </span><span class="s3">return </span><span class="s1">self._from_iterable(value </span><span class="s3">for </span><span class="s1">value </span><span class="s3">in </span><span class="s1">other </span><span class="s3">if </span><span class="s1">value </span><span class="s3">in </span><span class="s1">self) 
 
    __rand__ = __and__ 
 
    </span><span class="s3">def </span><span class="s1">isdisjoint(self</span><span class="s3">, </span><span class="s1">other): 
        </span><span class="s2">'Return True if two sets have a null intersection.'</span><span class="s1"> 
        </span><span class="s3">for </span><span class="s1">value </span><span class="s3">in </span><span class="s1">other: 
            </span><span class="s3">if </span><span class="s1">value </span><span class="s3">in </span><span class="s1">self: 
                </span><span class="s3">return False</span><span class="s1"> 
        </span><span class="s3">return True</span><span class="s1"> 
 
    </span><span class="s3">def </span><span class="s1">__or__(self</span><span class="s3">, </span><span class="s1">other): 
        </span><span class="s3">if not </span><span class="s1">isinstance(other</span><span class="s3">, </span><span class="s1">Iterable): 
            </span><span class="s3">return </span><span class="s1">NotImplemented 
        chain = (e </span><span class="s3">for </span><span class="s1">s </span><span class="s3">in </span><span class="s1">(self</span><span class="s3">, </span><span class="s1">other) </span><span class="s3">for </span><span class="s1">e </span><span class="s3">in </span><span class="s1">s) 
        </span><span class="s3">return </span><span class="s1">self._from_iterable(chain) 
 
    __ror__ = __or__ 
 
    </span><span class="s3">def </span><span class="s1">__sub__(self</span><span class="s3">, </span><span class="s1">other): 
        </span><span class="s3">if not </span><span class="s1">isinstance(other</span><span class="s3">, </span><span class="s1">Set): 
            </span><span class="s3">if not </span><span class="s1">isinstance(other</span><span class="s3">, </span><span class="s1">Iterable): 
                </span><span class="s3">return </span><span class="s1">NotImplemented 
            other = self._from_iterable(other) 
        </span><span class="s3">return </span><span class="s1">self._from_iterable(value </span><span class="s3">for </span><span class="s1">value </span><span class="s3">in </span><span class="s1">self 
                                   </span><span class="s3">if </span><span class="s1">value </span><span class="s3">not in </span><span class="s1">other) 
 
    </span><span class="s3">def </span><span class="s1">__rsub__(self</span><span class="s3">, </span><span class="s1">other): 
        </span><span class="s3">if not </span><span class="s1">isinstance(other</span><span class="s3">, </span><span class="s1">Set): 
            </span><span class="s3">if not </span><span class="s1">isinstance(other</span><span class="s3">, </span><span class="s1">Iterable): 
                </span><span class="s3">return </span><span class="s1">NotImplemented 
            other = self._from_iterable(other) 
        </span><span class="s3">return </span><span class="s1">self._from_iterable(value </span><span class="s3">for </span><span class="s1">value </span><span class="s3">in </span><span class="s1">other 
                                   </span><span class="s3">if </span><span class="s1">value </span><span class="s3">not in </span><span class="s1">self) 
 
    </span><span class="s3">def </span><span class="s1">__xor__(self</span><span class="s3">, </span><span class="s1">other): 
        </span><span class="s3">if not </span><span class="s1">isinstance(other</span><span class="s3">, </span><span class="s1">Set): 
            </span><span class="s3">if not </span><span class="s1">isinstance(other</span><span class="s3">, </span><span class="s1">Iterable): 
                </span><span class="s3">return </span><span class="s1">NotImplemented 
            other = self._from_iterable(other) 
        </span><span class="s3">return </span><span class="s1">(self - other) | (other - self) 
 
    __rxor__ = __xor__ 
 
    </span><span class="s3">def </span><span class="s1">_hash(self): 
        </span><span class="s2">&quot;&quot;&quot;Compute the hash value of a set. 
 
        Note that we don't define __hash__: not all sets are hashable. 
        But if you define a hashable set type, its __hash__ should 
        call this function. 
 
        This must be compatible __eq__. 
 
        All sets ought to compare equal if they contain the same 
        elements, regardless of how they are implemented, and 
        regardless of the order of the elements; so there's not much 
        freedom for __eq__ or __hash__.  We match the algorithm used 
        by the built-in frozenset type. 
        &quot;&quot;&quot;</span><span class="s1"> 
        MAX = sys.maxsize 
        MASK = </span><span class="s6">2 </span><span class="s1">* MAX + </span><span class="s6">1</span><span class="s1"> 
        n = len(self) 
        h = </span><span class="s6">1927868237 </span><span class="s1">* (n + </span><span class="s6">1</span><span class="s1">) 
        h &amp;= MASK 
        </span><span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">self: 
            hx = hash(x) 
            h ^= (hx ^ (hx &lt;&lt; </span><span class="s6">16</span><span class="s1">) ^ </span><span class="s6">89869747</span><span class="s1">)  * </span><span class="s6">3644798167</span><span class="s1"> 
            h &amp;= MASK 
        h = h * </span><span class="s6">69069 </span><span class="s1">+ </span><span class="s6">907133923</span><span class="s1"> 
        h &amp;= MASK 
        </span><span class="s3">if </span><span class="s1">h &gt; MAX: 
            h -= MASK + </span><span class="s6">1</span><span class="s1"> 
        </span><span class="s3">if </span><span class="s1">h == -</span><span class="s6">1</span><span class="s1">: 
            h = </span><span class="s6">590923713</span><span class="s1"> 
        </span><span class="s3">return </span><span class="s1">h 
 
Set.register(frozenset) 
 
 
</span><span class="s3">class </span><span class="s1">MutableSet(Set): 
    </span><span class="s2">&quot;&quot;&quot;A mutable set is a finite, iterable container. 
 
    This class provides concrete generic implementations of all 
    methods except for __contains__, __iter__, __len__, 
    add(), and discard(). 
 
    To override the comparisons (presumably for speed, as the 
    semantics are fixed), all you have to do is redefine __le__ and 
    then the other operations will automatically follow suit. 
    &quot;&quot;&quot;</span><span class="s1"> 
 
    __slots__ = () 
 
    @abstractmethod 
    </span><span class="s3">def </span><span class="s1">add(self</span><span class="s3">, </span><span class="s1">value): 
        </span><span class="s2">&quot;&quot;&quot;Add an element.&quot;&quot;&quot;</span><span class="s1"> 
        </span><span class="s3">raise </span><span class="s1">NotImplementedError 
 
    @abstractmethod 
    </span><span class="s3">def </span><span class="s1">discard(self</span><span class="s3">, </span><span class="s1">value): 
        </span><span class="s2">&quot;&quot;&quot;Remove an element.  Do not raise an exception if absent.&quot;&quot;&quot;</span><span class="s1"> 
        </span><span class="s3">raise </span><span class="s1">NotImplementedError 
 
    </span><span class="s3">def </span><span class="s1">remove(self</span><span class="s3">, </span><span class="s1">value): 
        </span><span class="s2">&quot;&quot;&quot;Remove an element. If not a member, raise a KeyError.&quot;&quot;&quot;</span><span class="s1"> 
        </span><span class="s3">if </span><span class="s1">value </span><span class="s3">not in </span><span class="s1">self: 
            </span><span class="s3">raise </span><span class="s1">KeyError(value) 
        self.discard(value) 
 
    </span><span class="s3">def </span><span class="s1">pop(self): 
        </span><span class="s2">&quot;&quot;&quot;Return the popped value.  Raise KeyError if empty.&quot;&quot;&quot;</span><span class="s1"> 
        it = iter(self) 
        </span><span class="s3">try</span><span class="s1">: 
            value = next(it) 
        </span><span class="s3">except </span><span class="s1">StopIteration: 
            </span><span class="s3">raise </span><span class="s1">KeyError 
        self.discard(value) 
        </span><span class="s3">return </span><span class="s1">value 
 
    </span><span class="s3">def </span><span class="s1">clear(self): 
        </span><span class="s2">&quot;&quot;&quot;This is slow (creates N new iterators!) but effective.&quot;&quot;&quot;</span><span class="s1"> 
        </span><span class="s3">try</span><span class="s1">: 
            </span><span class="s3">while True</span><span class="s1">: 
                self.pop() 
        </span><span class="s3">except </span><span class="s1">KeyError: 
            </span><span class="s3">pass</span><span class="s1"> 
 
    </span><span class="s3">def </span><span class="s1">__ior__(self</span><span class="s3">, </span><span class="s1">it): 
        </span><span class="s3">for </span><span class="s1">value </span><span class="s3">in </span><span class="s1">it: 
            self.add(value) 
        </span><span class="s3">return </span><span class="s1">self 
 
    </span><span class="s3">def </span><span class="s1">__iand__(self</span><span class="s3">, </span><span class="s1">it): 
        </span><span class="s3">for </span><span class="s1">value </span><span class="s3">in </span><span class="s1">(self - it): 
            self.discard(value) 
        </span><span class="s3">return </span><span class="s1">self 
 
    </span><span class="s3">def </span><span class="s1">__ixor__(self</span><span class="s3">, </span><span class="s1">it): 
        </span><span class="s3">if </span><span class="s1">it </span><span class="s3">is </span><span class="s1">self: 
            self.clear() 
        </span><span class="s3">else</span><span class="s1">: 
            </span><span class="s3">if not </span><span class="s1">isinstance(it</span><span class="s3">, </span><span class="s1">Set): 
                it = self._from_iterable(it) 
            </span><span class="s3">for </span><span class="s1">value </span><span class="s3">in </span><span class="s1">it: 
                </span><span class="s3">if </span><span class="s1">value </span><span class="s3">in </span><span class="s1">self: 
                    self.discard(value) 
                </span><span class="s3">else</span><span class="s1">: 
                    self.add(value) 
        </span><span class="s3">return </span><span class="s1">self 
 
    </span><span class="s3">def </span><span class="s1">__isub__(self</span><span class="s3">, </span><span class="s1">it): 
        </span><span class="s3">if </span><span class="s1">it </span><span class="s3">is </span><span class="s1">self: 
            self.clear() 
        </span><span class="s3">else</span><span class="s1">: 
            </span><span class="s3">for </span><span class="s1">value </span><span class="s3">in </span><span class="s1">it: 
                self.discard(value) 
        </span><span class="s3">return </span><span class="s1">self 
 
MutableSet.register(set) 
 
 
</span><span class="s0">### MAPPINGS ###</span><span class="s1"> 
 
 
</span><span class="s3">class </span><span class="s1">Mapping(Sized</span><span class="s3">, </span><span class="s1">Iterable</span><span class="s3">, </span><span class="s1">Container): 
 
    __slots__ = () 
 
    </span><span class="s4">&quot;&quot;&quot;A Mapping is a generic container for associating key/value 
    pairs. 
 
    This class provides concrete generic implementations of all 
    methods except for __getitem__, __iter__, and __len__. 
 
    &quot;&quot;&quot;</span><span class="s1"> 
 
    @abstractmethod 
    </span><span class="s3">def </span><span class="s1">__getitem__(self</span><span class="s3">, </span><span class="s1">key): 
        </span><span class="s3">raise </span><span class="s1">KeyError 
 
    </span><span class="s3">def </span><span class="s1">get(self</span><span class="s3">, </span><span class="s1">key</span><span class="s3">, </span><span class="s1">default=</span><span class="s3">None</span><span class="s1">): 
        </span><span class="s2">'D.get(k[,d]) -&gt; D[k] if k in D, else d.  d defaults to None.'</span><span class="s1"> 
        </span><span class="s3">try</span><span class="s1">: 
            </span><span class="s3">return </span><span class="s1">self[key] 
        </span><span class="s3">except </span><span class="s1">KeyError: 
            </span><span class="s3">return </span><span class="s1">default 
 
    </span><span class="s3">def </span><span class="s1">__contains__(self</span><span class="s3">, </span><span class="s1">key): 
        </span><span class="s3">try</span><span class="s1">: 
            self[key] 
        </span><span class="s3">except </span><span class="s1">KeyError: 
            </span><span class="s3">return False</span><span class="s1"> 
        </span><span class="s3">else</span><span class="s1">: 
            </span><span class="s3">return True</span><span class="s1"> 
 
    </span><span class="s3">def </span><span class="s1">keys(self): 
        </span><span class="s2">&quot;D.keys() -&gt; a set-like object providing a view on D's keys&quot;</span><span class="s1"> 
        </span><span class="s3">return </span><span class="s1">KeysView(self) 
 
    </span><span class="s3">def </span><span class="s1">items(self): 
        </span><span class="s2">&quot;D.items() -&gt; a set-like object providing a view on D's items&quot;</span><span class="s1"> 
        </span><span class="s3">return </span><span class="s1">ItemsView(self) 
 
    </span><span class="s3">def </span><span class="s1">values(self): 
        </span><span class="s2">&quot;D.values() -&gt; an object providing a view on D's values&quot;</span><span class="s1"> 
        </span><span class="s3">return </span><span class="s1">ValuesView(self) 
 
    </span><span class="s3">def </span><span class="s1">__eq__(self</span><span class="s3">, </span><span class="s1">other): 
        </span><span class="s3">if not </span><span class="s1">isinstance(other</span><span class="s3">, </span><span class="s1">Mapping): 
            </span><span class="s3">return </span><span class="s1">NotImplemented 
        </span><span class="s3">return </span><span class="s1">dict(self.items()) == dict(other.items()) 
 
Mapping.register(mappingproxy) 
 
 
</span><span class="s3">class </span><span class="s1">MappingView(Sized): 
 
    __slots__ = </span><span class="s4">'_mapping'</span><span class="s3">,</span><span class="s1"> 
 
    </span><span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">mapping): 
        self._mapping = mapping 
 
    </span><span class="s3">def </span><span class="s1">__len__(self): 
        </span><span class="s3">return </span><span class="s1">len(self._mapping) 
 
    </span><span class="s3">def </span><span class="s1">__repr__(self): 
        </span><span class="s3">return </span><span class="s4">'{0.__class__.__name__}({0._mapping!r})'</span><span class="s1">.format(self) 
 
 
</span><span class="s3">class </span><span class="s1">KeysView(MappingView</span><span class="s3">, </span><span class="s1">Set): 
 
    __slots__ = () 
 
    @classmethod 
    </span><span class="s3">def </span><span class="s1">_from_iterable(self</span><span class="s3">, </span><span class="s1">it): 
        </span><span class="s3">return </span><span class="s1">set(it) 
 
    </span><span class="s3">def </span><span class="s1">__contains__(self</span><span class="s3">, </span><span class="s1">key): 
        </span><span class="s3">return </span><span class="s1">key </span><span class="s3">in </span><span class="s1">self._mapping 
 
    </span><span class="s3">def </span><span class="s1">__iter__(self): 
        </span><span class="s3">yield from </span><span class="s1">self._mapping 
 
KeysView.register(dict_keys) 
 
 
</span><span class="s3">class </span><span class="s1">ItemsView(MappingView</span><span class="s3">, </span><span class="s1">Set): 
 
    __slots__ = () 
 
    @classmethod 
    </span><span class="s3">def </span><span class="s1">_from_iterable(self</span><span class="s3">, </span><span class="s1">it): 
        </span><span class="s3">return </span><span class="s1">set(it) 
 
    </span><span class="s3">def </span><span class="s1">__contains__(self</span><span class="s3">, </span><span class="s1">item): 
        key</span><span class="s3">, </span><span class="s1">value = item 
        </span><span class="s3">try</span><span class="s1">: 
            v = self._mapping[key] 
        </span><span class="s3">except </span><span class="s1">KeyError: 
            </span><span class="s3">return False</span><span class="s1"> 
        </span><span class="s3">else</span><span class="s1">: 
            </span><span class="s3">return </span><span class="s1">v == value 
 
    </span><span class="s3">def </span><span class="s1">__iter__(self): 
        </span><span class="s3">for </span><span class="s1">key </span><span class="s3">in </span><span class="s1">self._mapping: 
            </span><span class="s3">yield </span><span class="s1">(key</span><span class="s3">, </span><span class="s1">self._mapping[key]) 
 
ItemsView.register(dict_items) 
 
 
</span><span class="s3">class </span><span class="s1">ValuesView(MappingView): 
 
    __slots__ = () 
 
    </span><span class="s3">def </span><span class="s1">__contains__(self</span><span class="s3">, </span><span class="s1">value): 
        </span><span class="s3">for </span><span class="s1">key </span><span class="s3">in </span><span class="s1">self._mapping: 
            </span><span class="s3">if </span><span class="s1">value == self._mapping[key]: 
                </span><span class="s3">return True</span><span class="s1"> 
        </span><span class="s3">return False</span><span class="s1"> 
 
    </span><span class="s3">def </span><span class="s1">__iter__(self): 
        </span><span class="s3">for </span><span class="s1">key </span><span class="s3">in </span><span class="s1">self._mapping: 
            </span><span class="s3">yield </span><span class="s1">self._mapping[key] 
 
ValuesView.register(dict_values) 
 
 
</span><span class="s3">class </span><span class="s1">MutableMapping(Mapping): 
 
    __slots__ = () 
 
    </span><span class="s4">&quot;&quot;&quot;A MutableMapping is a generic container for associating 
    key/value pairs. 
 
    This class provides concrete generic implementations of all 
    methods except for __getitem__, __setitem__, __delitem__, 
    __iter__, and __len__. 
 
    &quot;&quot;&quot;</span><span class="s1"> 
 
    @abstractmethod 
    </span><span class="s3">def </span><span class="s1">__setitem__(self</span><span class="s3">, </span><span class="s1">key</span><span class="s3">, </span><span class="s1">value): 
        </span><span class="s3">raise </span><span class="s1">KeyError 
 
    @abstractmethod 
    </span><span class="s3">def </span><span class="s1">__delitem__(self</span><span class="s3">, </span><span class="s1">key): 
        </span><span class="s3">raise </span><span class="s1">KeyError 
 
    __marker = object() 
 
    </span><span class="s3">def </span><span class="s1">pop(self</span><span class="s3">, </span><span class="s1">key</span><span class="s3">, </span><span class="s1">default=__marker): 
        </span><span class="s2">'''D.pop(k[,d]) -&gt; v, remove specified key and return the corresponding value. 
          If key is not found, d is returned if given, otherwise KeyError is raised. 
        '''</span><span class="s1"> 
        </span><span class="s3">try</span><span class="s1">: 
            value = self[key] 
        </span><span class="s3">except </span><span class="s1">KeyError: 
            </span><span class="s3">if </span><span class="s1">default </span><span class="s3">is </span><span class="s1">self.__marker: 
                </span><span class="s3">raise</span><span class="s1"> 
            </span><span class="s3">return </span><span class="s1">default 
        </span><span class="s3">else</span><span class="s1">: 
            </span><span class="s3">del </span><span class="s1">self[key] 
            </span><span class="s3">return </span><span class="s1">value 
 
    </span><span class="s3">def </span><span class="s1">popitem(self): 
        </span><span class="s2">'''D.popitem() -&gt; (k, v), remove and return some (key, value) pair 
           as a 2-tuple; but raise KeyError if D is empty. 
        '''</span><span class="s1"> 
        </span><span class="s3">try</span><span class="s1">: 
            key = next(iter(self)) 
        </span><span class="s3">except </span><span class="s1">StopIteration: 
            </span><span class="s3">raise </span><span class="s1">KeyError 
        value = self[key] 
        </span><span class="s3">del </span><span class="s1">self[key] 
        </span><span class="s3">return </span><span class="s1">key</span><span class="s3">, </span><span class="s1">value 
 
    </span><span class="s3">def </span><span class="s1">clear(self): 
        </span><span class="s2">'D.clear() -&gt; None.  Remove all items from D.'</span><span class="s1"> 
        </span><span class="s3">try</span><span class="s1">: 
            </span><span class="s3">while True</span><span class="s1">: 
                self.popitem() 
        </span><span class="s3">except </span><span class="s1">KeyError: 
            </span><span class="s3">pass</span><span class="s1"> 
 
    </span><span class="s3">def </span><span class="s1">update(*args</span><span class="s3">, </span><span class="s1">**kwds): 
        </span><span class="s2">''' D.update([E, ]**F) -&gt; None.  Update D from mapping/iterable E and F. 
            If E present and has a .keys() method, does:     for k in E: D[k] = E[k] 
            If E present and lacks .keys() method, does:     for (k, v) in E: D[k] = v 
            In either case, this is followed by: for k, v in F.items(): D[k] = v 
        '''</span><span class="s1"> 
        </span><span class="s3">if not </span><span class="s1">args: 
            </span><span class="s3">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;descriptor 'update' of 'MutableMapping' object &quot;</span><span class="s1"> 
                            </span><span class="s4">&quot;needs an argument&quot;</span><span class="s1">) 
        self</span><span class="s3">, </span><span class="s1">*args = args 
        </span><span class="s3">if </span><span class="s1">len(args) &gt; </span><span class="s6">1</span><span class="s1">: 
            </span><span class="s3">raise </span><span class="s1">TypeError(</span><span class="s4">'update expected at most 1 arguments, got %d' </span><span class="s1">% 
                            len(args)) 
        </span><span class="s3">if </span><span class="s1">args: 
            other = args[</span><span class="s6">0</span><span class="s1">] 
            </span><span class="s3">if </span><span class="s1">isinstance(other</span><span class="s3">, </span><span class="s1">Mapping): 
                </span><span class="s3">for </span><span class="s1">key </span><span class="s3">in </span><span class="s1">other: 
                    self[key] = other[key] 
            </span><span class="s3">elif </span><span class="s1">hasattr(other</span><span class="s3">, </span><span class="s4">&quot;keys&quot;</span><span class="s1">): 
                </span><span class="s3">for </span><span class="s1">key </span><span class="s3">in </span><span class="s1">other.keys(): 
                    self[key] = other[key] 
            </span><span class="s3">else</span><span class="s1">: 
                </span><span class="s3">for </span><span class="s1">key</span><span class="s3">, </span><span class="s1">value </span><span class="s3">in </span><span class="s1">other: 
                    self[key] = value 
        </span><span class="s3">for </span><span class="s1">key</span><span class="s3">, </span><span class="s1">value </span><span class="s3">in </span><span class="s1">kwds.items(): 
            self[key] = value 
 
    </span><span class="s3">def </span><span class="s1">setdefault(self</span><span class="s3">, </span><span class="s1">key</span><span class="s3">, </span><span class="s1">default=</span><span class="s3">None</span><span class="s1">): 
        </span><span class="s2">'D.setdefault(k[,d]) -&gt; D.get(k,d), also set D[k]=d if k not in D'</span><span class="s1"> 
        </span><span class="s3">try</span><span class="s1">: 
            </span><span class="s3">return </span><span class="s1">self[key] 
        </span><span class="s3">except </span><span class="s1">KeyError: 
            self[key] = default 
        </span><span class="s3">return </span><span class="s1">default 
 
MutableMapping.register(dict) 
 
 
</span><span class="s0">### SEQUENCES ###</span><span class="s1"> 
 
 
</span><span class="s3">class </span><span class="s1">Sequence(Sized</span><span class="s3">, </span><span class="s1">Iterable</span><span class="s3">, </span><span class="s1">Container): 
 
    </span><span class="s2">&quot;&quot;&quot;All the operations on a read-only sequence. 
 
    Concrete subclasses must override __new__ or __init__, 
    __getitem__, and __len__. 
    &quot;&quot;&quot;</span><span class="s1"> 
 
    __slots__ = () 
 
    @abstractmethod 
    </span><span class="s3">def </span><span class="s1">__getitem__(self</span><span class="s3">, </span><span class="s1">index): 
        </span><span class="s3">raise </span><span class="s1">IndexError 
 
    </span><span class="s3">def </span><span class="s1">__iter__(self): 
        i = </span><span class="s6">0</span><span class="s1"> 
        </span><span class="s3">try</span><span class="s1">: 
            </span><span class="s3">while True</span><span class="s1">: 
                v = self[i] 
                </span><span class="s3">yield </span><span class="s1">v 
                i += </span><span class="s6">1</span><span class="s1"> 
        </span><span class="s3">except </span><span class="s1">IndexError: 
            </span><span class="s3">return</span><span class="s1"> 
 
    </span><span class="s3">def </span><span class="s1">__contains__(self</span><span class="s3">, </span><span class="s1">value): 
        </span><span class="s3">for </span><span class="s1">v </span><span class="s3">in </span><span class="s1">self: 
            </span><span class="s3">if </span><span class="s1">v == value: 
                </span><span class="s3">return True</span><span class="s1"> 
        </span><span class="s3">return False</span><span class="s1"> 
 
    </span><span class="s3">def </span><span class="s1">__reversed__(self): 
        </span><span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">reversed(range(len(self))): 
            </span><span class="s3">yield </span><span class="s1">self[i] 
 
    </span><span class="s3">def </span><span class="s1">index(self</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">start=</span><span class="s6">0</span><span class="s3">, </span><span class="s1">stop=</span><span class="s3">None</span><span class="s1">): 
        </span><span class="s2">'''S.index(value, [start, [stop]]) -&gt; integer -- return first index of value. 
           Raises ValueError if the value is not present. 
        '''</span><span class="s1"> 
        </span><span class="s3">if </span><span class="s1">start </span><span class="s3">is not None and </span><span class="s1">start &lt; </span><span class="s6">0</span><span class="s1">: 
            start = max(len(self) + start</span><span class="s3">, </span><span class="s6">0</span><span class="s1">) 
        </span><span class="s3">if </span><span class="s1">stop </span><span class="s3">is not None and </span><span class="s1">stop &lt; </span><span class="s6">0</span><span class="s1">: 
            stop += len(self) 
 
        i = start 
        </span><span class="s3">while </span><span class="s1">stop </span><span class="s3">is None or </span><span class="s1">i &lt; stop: 
            </span><span class="s3">try</span><span class="s1">: 
                </span><span class="s3">if </span><span class="s1">self[i] == value: 
                    </span><span class="s3">return </span><span class="s1">i 
            </span><span class="s3">except </span><span class="s1">IndexError: 
                </span><span class="s3">break</span><span class="s1"> 
            i += </span><span class="s6">1</span><span class="s1"> 
        </span><span class="s3">raise </span><span class="s1">ValueError 
 
    </span><span class="s3">def </span><span class="s1">count(self</span><span class="s3">, </span><span class="s1">value): 
        </span><span class="s2">'S.count(value) -&gt; integer -- return number of occurrences of value'</span><span class="s1"> 
        </span><span class="s3">return </span><span class="s1">sum(</span><span class="s6">1 </span><span class="s3">for </span><span class="s1">v </span><span class="s3">in </span><span class="s1">self </span><span class="s3">if </span><span class="s1">v == value) 
 
Sequence.register(tuple) 
Sequence.register(str) 
Sequence.register(range) 
Sequence.register(memoryview) 
 
 
</span><span class="s3">class </span><span class="s1">ByteString(Sequence): 
 
    </span><span class="s2">&quot;&quot;&quot;This unifies bytes and bytearray. 
 
    XXX Should add all their methods. 
    &quot;&quot;&quot;</span><span class="s1"> 
 
    __slots__ = () 
 
ByteString.register(bytes) 
ByteString.register(bytearray) 
 
 
</span><span class="s3">class </span><span class="s1">MutableSequence(Sequence): 
 
    __slots__ = () 
 
    </span><span class="s4">&quot;&quot;&quot;All the operations on a read-write sequence. 
 
    Concrete subclasses must provide __new__ or __init__, 
    __getitem__, __setitem__, __delitem__, __len__, and insert(). 
 
    &quot;&quot;&quot;</span><span class="s1"> 
 
    @abstractmethod 
    </span><span class="s3">def </span><span class="s1">__setitem__(self</span><span class="s3">, </span><span class="s1">index</span><span class="s3">, </span><span class="s1">value): 
        </span><span class="s3">raise </span><span class="s1">IndexError 
 
    @abstractmethod 
    </span><span class="s3">def </span><span class="s1">__delitem__(self</span><span class="s3">, </span><span class="s1">index): 
        </span><span class="s3">raise </span><span class="s1">IndexError 
 
    @abstractmethod 
    </span><span class="s3">def </span><span class="s1">insert(self</span><span class="s3">, </span><span class="s1">index</span><span class="s3">, </span><span class="s1">value): 
        </span><span class="s2">'S.insert(index, value) -- insert value before index'</span><span class="s1"> 
        </span><span class="s3">raise </span><span class="s1">IndexError 
 
    </span><span class="s3">def </span><span class="s1">append(self</span><span class="s3">, </span><span class="s1">value): 
        </span><span class="s2">'S.append(value) -- append value to the end of the sequence'</span><span class="s1"> 
        self.insert(len(self)</span><span class="s3">, </span><span class="s1">value) 
 
    </span><span class="s3">def </span><span class="s1">clear(self): 
        </span><span class="s2">'S.clear() -&gt; None -- remove all items from S'</span><span class="s1"> 
        </span><span class="s3">try</span><span class="s1">: 
            </span><span class="s3">while True</span><span class="s1">: 
                self.pop() 
        </span><span class="s3">except </span><span class="s1">IndexError: 
            </span><span class="s3">pass</span><span class="s1"> 
 
    </span><span class="s3">def </span><span class="s1">reverse(self): 
        </span><span class="s2">'S.reverse() -- reverse *IN PLACE*'</span><span class="s1"> 
        n = len(self) 
        </span><span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(n//</span><span class="s6">2</span><span class="s1">): 
            self[i]</span><span class="s3">, </span><span class="s1">self[n-i-</span><span class="s6">1</span><span class="s1">] = self[n-i-</span><span class="s6">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">self[i] 
 
    </span><span class="s3">def </span><span class="s1">extend(self</span><span class="s3">, </span><span class="s1">values): 
        </span><span class="s2">'S.extend(iterable) -- extend sequence by appending elements from the iterable'</span><span class="s1"> 
        </span><span class="s3">for </span><span class="s1">v </span><span class="s3">in </span><span class="s1">values: 
            self.append(v) 
 
    </span><span class="s3">def </span><span class="s1">pop(self</span><span class="s3">, </span><span class="s1">index=-</span><span class="s6">1</span><span class="s1">): 
        </span><span class="s2">'''S.pop([index]) -&gt; item -- remove and return item at index (default last). 
           Raise IndexError if list is empty or index is out of range. 
        '''</span><span class="s1"> 
        v = self[index] 
        </span><span class="s3">del </span><span class="s1">self[index] 
        </span><span class="s3">return </span><span class="s1">v 
 
    </span><span class="s3">def </span><span class="s1">remove(self</span><span class="s3">, </span><span class="s1">value): 
        </span><span class="s2">'''S.remove(value) -- remove first occurrence of value. 
           Raise ValueError if the value is not present. 
        '''</span><span class="s1"> 
        </span><span class="s3">del </span><span class="s1">self[self.index(value)] 
 
    </span><span class="s3">def </span><span class="s1">__iadd__(self</span><span class="s3">, </span><span class="s1">values): 
        self.extend(values) 
        </span><span class="s3">return </span><span class="s1">self 
 
MutableSequence.register(list) 
MutableSequence.register(bytearray)  </span><span class="s0"># Multiply inheriting, see ByteString</span><span class="s1"> 
</span></pre>
</body>
</html>