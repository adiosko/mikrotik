<html>
<head>
<title>fnmatch.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.ln { color: #606366; font-weight: normal; font-style: normal; }
.s0 { color: rgb(98,151,85); font-style: italic; }
.s1 { color: rgb(169,183,198); }
.s2 { color: rgb(204,120,50); }
.s3 { color: rgb(106,135,89); }
.s4 { color: rgb(104,151,187); }
.s5 { color: rgb(128,128,128); }
</style>
</head>
<BODY BGCOLOR="#2b2b2b">
<TABLE CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<TR><TD><CENTER>
<FONT FACE="Arial, Helvetica" COLOR="#000000">
fnmatch.py</FONT>
</center></TD></TR></TABLE>
<pre>
<span class="s0">&quot;&quot;&quot;Filename matching with shell patterns. 
 
fnmatch(FILENAME, PATTERN) matches according to the local convention. 
fnmatchcase(FILENAME, PATTERN) always takes case in account. 
 
The functions operate by translating the pattern into a regular 
expression.  They cache the compiled regular expressions for speed. 
 
The function translate(PATTERN) returns a regular expression 
corresponding to PATTERN.  (It does not compile it.) 
&quot;&quot;&quot;</span><span class="s1"> 
</span><span class="s2">import </span><span class="s1">os 
</span><span class="s2">import </span><span class="s1">posixpath 
</span><span class="s2">import </span><span class="s1">re 
</span><span class="s2">import </span><span class="s1">functools 
 
__all__ = [</span><span class="s3">&quot;filter&quot;</span><span class="s2">, </span><span class="s3">&quot;fnmatch&quot;</span><span class="s2">, </span><span class="s3">&quot;fnmatchcase&quot;</span><span class="s2">, </span><span class="s3">&quot;translate&quot;</span><span class="s1">] 
 
</span><span class="s2">def </span><span class="s1">fnmatch(name</span><span class="s2">, </span><span class="s1">pat): 
    </span><span class="s0">&quot;&quot;&quot;Test whether FILENAME matches PATTERN. 
 
    Patterns are Unix shell style: 
 
    *       matches everything 
    ?       matches any single character 
    [seq]   matches any character in seq 
    [!seq]  matches any char not in seq 
 
    An initial period in FILENAME is not special. 
    Both FILENAME and PATTERN are first case-normalized 
    if the operating system requires it. 
    If you don't want this, use fnmatchcase(FILENAME, PATTERN). 
    &quot;&quot;&quot;</span><span class="s1"> 
    name = os.path.normcase(name) 
    pat = os.path.normcase(pat) 
    </span><span class="s2">return </span><span class="s1">fnmatchcase(name</span><span class="s2">, </span><span class="s1">pat) 
 
@functools.lru_cache(maxsize=</span><span class="s4">256</span><span class="s2">, </span><span class="s1">typed=</span><span class="s2">True</span><span class="s1">) 
</span><span class="s2">def </span><span class="s1">_compile_pattern(pat): 
    </span><span class="s2">if </span><span class="s1">isinstance(pat</span><span class="s2">, </span><span class="s1">bytes): 
        pat_str = str(pat</span><span class="s2">, </span><span class="s3">'ISO-8859-1'</span><span class="s1">) 
        res_str = translate(pat_str) 
        res = bytes(res_str</span><span class="s2">, </span><span class="s3">'ISO-8859-1'</span><span class="s1">) 
    </span><span class="s2">else</span><span class="s1">: 
        res = translate(pat) 
    </span><span class="s2">return </span><span class="s1">re.compile(res).match 
 
</span><span class="s2">def </span><span class="s1">filter(names</span><span class="s2">, </span><span class="s1">pat): 
    </span><span class="s0">&quot;&quot;&quot;Return the subset of the list NAMES that match PAT.&quot;&quot;&quot;</span><span class="s1"> 
    result = [] 
    pat = os.path.normcase(pat) 
    match = _compile_pattern(pat) 
    </span><span class="s2">if </span><span class="s1">os.path </span><span class="s2">is </span><span class="s1">posixpath: 
        </span><span class="s5"># normcase on posix is NOP. Optimize it away from the loop.</span><span class="s1"> 
        </span><span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">names: 
            </span><span class="s2">if </span><span class="s1">match(name): 
                result.append(name) 
    </span><span class="s2">else</span><span class="s1">: 
        </span><span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">names: 
            </span><span class="s2">if </span><span class="s1">match(os.path.normcase(name)): 
                result.append(name) 
    </span><span class="s2">return </span><span class="s1">result 
 
</span><span class="s2">def </span><span class="s1">fnmatchcase(name</span><span class="s2">, </span><span class="s1">pat): 
    </span><span class="s0">&quot;&quot;&quot;Test whether FILENAME matches PATTERN, including case. 
 
    This is a version of fnmatch() which doesn't case-normalize 
    its arguments. 
    &quot;&quot;&quot;</span><span class="s1"> 
    match = _compile_pattern(pat) 
    </span><span class="s2">return </span><span class="s1">match(name) </span><span class="s2">is not None</span><span class="s1"> 
 
 
</span><span class="s2">def </span><span class="s1">translate(pat): 
    </span><span class="s0">&quot;&quot;&quot;Translate a shell PATTERN to a regular expression. 
 
    There is no way to quote meta-characters. 
    &quot;&quot;&quot;</span><span class="s1"> 
 
    i</span><span class="s2">, </span><span class="s1">n = </span><span class="s4">0</span><span class="s2">, </span><span class="s1">len(pat) 
    res = </span><span class="s3">''</span><span class="s1"> 
    </span><span class="s2">while </span><span class="s1">i &lt; n: 
        c = pat[i] 
        i = i+</span><span class="s4">1</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">c == </span><span class="s3">'*'</span><span class="s1">: 
            res = res + </span><span class="s3">'.*'</span><span class="s1"> 
        </span><span class="s2">elif </span><span class="s1">c == </span><span class="s3">'?'</span><span class="s1">: 
            res = res + </span><span class="s3">'.'</span><span class="s1"> 
        </span><span class="s2">elif </span><span class="s1">c == </span><span class="s3">'['</span><span class="s1">: 
            j = i 
            </span><span class="s2">if </span><span class="s1">j &lt; n </span><span class="s2">and </span><span class="s1">pat[j] == </span><span class="s3">'!'</span><span class="s1">: 
                j = j+</span><span class="s4">1</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">j &lt; n </span><span class="s2">and </span><span class="s1">pat[j] == </span><span class="s3">']'</span><span class="s1">: 
                j = j+</span><span class="s4">1</span><span class="s1"> 
            </span><span class="s2">while </span><span class="s1">j &lt; n </span><span class="s2">and </span><span class="s1">pat[j] != </span><span class="s3">']'</span><span class="s1">: 
                j = j+</span><span class="s4">1</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">j &gt;= n: 
                res = res + </span><span class="s3">'</span><span class="s2">\\</span><span class="s3">['</span><span class="s1"> 
            </span><span class="s2">else</span><span class="s1">: 
                stuff = pat[i:j].replace(</span><span class="s3">'</span><span class="s2">\\</span><span class="s3">'</span><span class="s2">,</span><span class="s3">'</span><span class="s2">\\\\</span><span class="s3">'</span><span class="s1">) 
                i = j+</span><span class="s4">1</span><span class="s1"> 
                </span><span class="s2">if </span><span class="s1">stuff[</span><span class="s4">0</span><span class="s1">] == </span><span class="s3">'!'</span><span class="s1">: 
                    stuff = </span><span class="s3">'^' </span><span class="s1">+ stuff[</span><span class="s4">1</span><span class="s1">:] 
                </span><span class="s2">elif </span><span class="s1">stuff[</span><span class="s4">0</span><span class="s1">] == </span><span class="s3">'^'</span><span class="s1">: 
                    stuff = </span><span class="s3">'</span><span class="s2">\\</span><span class="s3">' </span><span class="s1">+ stuff 
                res = </span><span class="s3">'%s[%s]' </span><span class="s1">% (res</span><span class="s2">, </span><span class="s1">stuff) 
        </span><span class="s2">else</span><span class="s1">: 
            res = res + re.escape(c) 
    </span><span class="s2">return </span><span class="s1">res + </span><span class="s3">'\Z(?ms)'</span><span class="s1"> 
</span></pre>
</body>
</html>