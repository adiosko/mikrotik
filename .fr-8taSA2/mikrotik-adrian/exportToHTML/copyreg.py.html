<html>
<head>
<title>copyreg.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.ln { color: #606366; font-weight: normal; font-style: normal; }
.s0 { color: rgb(98,151,85); font-style: italic; }
.s1 { color: rgb(169,183,198); }
.s2 { color: rgb(106,135,89); }
.s3 { color: rgb(204,120,50); }
.s4 { color: rgb(128,128,128); }
.s5 { color: rgb(104,151,187); }
</style>
</head>
<BODY BGCOLOR="#2b2b2b">
<TABLE CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<TR><TD><CENTER>
<FONT FACE="Arial, Helvetica" COLOR="#000000">
copyreg.py</FONT>
</center></TD></TR></TABLE>
<pre>
<span class="s0">&quot;&quot;&quot;Helper to provide extensibility for pickle. 
 
This is only useful to add pickle support for extension types defined in 
C, not for instances of user-defined classes. 
&quot;&quot;&quot;</span><span class="s1"> 
 
__all__ = [</span><span class="s2">&quot;pickle&quot;</span><span class="s3">, </span><span class="s2">&quot;constructor&quot;</span><span class="s3">,</span><span class="s1"> 
           </span><span class="s2">&quot;add_extension&quot;</span><span class="s3">, </span><span class="s2">&quot;remove_extension&quot;</span><span class="s3">, </span><span class="s2">&quot;clear_extension_cache&quot;</span><span class="s1">] 
 
dispatch_table = {} 
 
</span><span class="s3">def </span><span class="s1">pickle(ob_type</span><span class="s3">, </span><span class="s1">pickle_function</span><span class="s3">, </span><span class="s1">constructor_ob=</span><span class="s3">None</span><span class="s1">): 
    </span><span class="s3">if not </span><span class="s1">callable(pickle_function): 
        </span><span class="s3">raise </span><span class="s1">TypeError(</span><span class="s2">&quot;reduction functions must be callable&quot;</span><span class="s1">) 
    dispatch_table[ob_type] = pickle_function 
 
    </span><span class="s4"># The constructor_ob function is a vestige of safe for unpickling.</span><span class="s1"> 
    </span><span class="s4"># There is no reason for the caller to pass it anymore.</span><span class="s1"> 
    </span><span class="s3">if </span><span class="s1">constructor_ob </span><span class="s3">is not None</span><span class="s1">: 
        constructor(constructor_ob) 
 
</span><span class="s3">def </span><span class="s1">constructor(object): 
    </span><span class="s3">if not </span><span class="s1">callable(object): 
        </span><span class="s3">raise </span><span class="s1">TypeError(</span><span class="s2">&quot;constructors must be callable&quot;</span><span class="s1">) 
 
</span><span class="s4"># Example: provide pickling support for complex numbers.</span><span class="s1"> 
 
</span><span class="s3">try</span><span class="s1">: 
    complex 
</span><span class="s3">except </span><span class="s1">NameError: 
    </span><span class="s3">pass</span><span class="s1"> 
</span><span class="s3">else</span><span class="s1">: 
 
    </span><span class="s3">def </span><span class="s1">pickle_complex(c): 
        </span><span class="s3">return </span><span class="s1">complex</span><span class="s3">, </span><span class="s1">(c.real</span><span class="s3">, </span><span class="s1">c.imag) 
 
    pickle(complex</span><span class="s3">, </span><span class="s1">pickle_complex</span><span class="s3">, </span><span class="s1">complex) 
 
</span><span class="s4"># Support for pickling new-style objects</span><span class="s1"> 
 
</span><span class="s3">def </span><span class="s1">_reconstructor(cls</span><span class="s3">, </span><span class="s1">base</span><span class="s3">, </span><span class="s1">state): 
    </span><span class="s3">if </span><span class="s1">base </span><span class="s3">is </span><span class="s1">object: 
        obj = object.__new__(cls) 
    </span><span class="s3">else</span><span class="s1">: 
        obj = base.__new__(cls</span><span class="s3">, </span><span class="s1">state) 
        </span><span class="s3">if </span><span class="s1">base.__init__ != object.__init__: 
            base.__init__(obj</span><span class="s3">, </span><span class="s1">state) 
    </span><span class="s3">return </span><span class="s1">obj 
 
_HEAPTYPE = </span><span class="s5">1</span><span class="s1">&lt;&lt;</span><span class="s5">9</span><span class="s1"> 
 
</span><span class="s4"># Python code for object.__reduce_ex__ for protocols 0 and 1</span><span class="s1"> 
 
</span><span class="s3">def </span><span class="s1">_reduce_ex(self</span><span class="s3">, </span><span class="s1">proto): 
    </span><span class="s3">assert </span><span class="s1">proto &lt; </span><span class="s5">2</span><span class="s1"> 
    </span><span class="s3">for </span><span class="s1">base </span><span class="s3">in </span><span class="s1">self.__class__.__mro__: 
        </span><span class="s3">if </span><span class="s1">hasattr(base</span><span class="s3">, </span><span class="s2">'__flags__'</span><span class="s1">) </span><span class="s3">and not </span><span class="s1">base.__flags__ &amp; _HEAPTYPE: 
            </span><span class="s3">break</span><span class="s1"> 
    </span><span class="s3">else</span><span class="s1">: 
        base = object </span><span class="s4"># not really reachable</span><span class="s1"> 
    </span><span class="s3">if </span><span class="s1">base </span><span class="s3">is </span><span class="s1">object: 
        state = </span><span class="s3">None</span><span class="s1"> 
    </span><span class="s3">else</span><span class="s1">: 
        </span><span class="s3">if </span><span class="s1">base </span><span class="s3">is </span><span class="s1">self.__class__: 
            </span><span class="s3">raise </span><span class="s1">TypeError(</span><span class="s2">&quot;can't pickle %s objects&quot; </span><span class="s1">% base.__name__) 
        state = base(self) 
    args = (self.__class__</span><span class="s3">, </span><span class="s1">base</span><span class="s3">, </span><span class="s1">state) 
    </span><span class="s3">try</span><span class="s1">: 
        getstate = self.__getstate__ 
    </span><span class="s3">except </span><span class="s1">AttributeError: 
        </span><span class="s3">if </span><span class="s1">getattr(self</span><span class="s3">, </span><span class="s2">&quot;__slots__&quot;</span><span class="s3">, None</span><span class="s1">): 
            </span><span class="s3">raise </span><span class="s1">TypeError(</span><span class="s2">&quot;a class that defines __slots__ without &quot;</span><span class="s1"> 
                            </span><span class="s2">&quot;defining __getstate__ cannot be pickled&quot;</span><span class="s1">) 
        </span><span class="s3">try</span><span class="s1">: 
            dict = self.__dict__ 
        </span><span class="s3">except </span><span class="s1">AttributeError: 
            dict = </span><span class="s3">None</span><span class="s1"> 
    </span><span class="s3">else</span><span class="s1">: 
        dict = getstate() 
    </span><span class="s3">if </span><span class="s1">dict: 
        </span><span class="s3">return </span><span class="s1">_reconstructor</span><span class="s3">, </span><span class="s1">args</span><span class="s3">, </span><span class="s1">dict 
    </span><span class="s3">else</span><span class="s1">: 
        </span><span class="s3">return </span><span class="s1">_reconstructor</span><span class="s3">, </span><span class="s1">args 
 
</span><span class="s4"># Helper for __reduce_ex__ protocol 2</span><span class="s1"> 
 
</span><span class="s3">def </span><span class="s1">__newobj__(cls</span><span class="s3">, </span><span class="s1">*args): 
    </span><span class="s3">return </span><span class="s1">cls.__new__(cls</span><span class="s3">, </span><span class="s1">*args) 
 
</span><span class="s3">def </span><span class="s1">__newobj_ex__(cls</span><span class="s3">, </span><span class="s1">args</span><span class="s3">, </span><span class="s1">kwargs): 
    </span><span class="s0">&quot;&quot;&quot;Used by pickle protocol 4, instead of __newobj__ to allow classes with 
    keyword-only arguments to be pickled correctly. 
    &quot;&quot;&quot;</span><span class="s1"> 
    </span><span class="s3">return </span><span class="s1">cls.__new__(cls</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kwargs) 
 
</span><span class="s3">def </span><span class="s1">_slotnames(cls): 
    </span><span class="s0">&quot;&quot;&quot;Return a list of slot names for a given class. 
 
    This needs to find slots defined by the class and its bases, so we 
    can't simply return the __slots__ attribute.  We must walk down 
    the Method Resolution Order and concatenate the __slots__ of each 
    class found there.  (This assumes classes don't modify their 
    __slots__ attribute to misrepresent their slots after the class is 
    defined.) 
    &quot;&quot;&quot;</span><span class="s1"> 
 
    </span><span class="s4"># Get the value from a cache in the class if possible</span><span class="s1"> 
    names = cls.__dict__.get(</span><span class="s2">&quot;__slotnames__&quot;</span><span class="s1">) 
    </span><span class="s3">if </span><span class="s1">names </span><span class="s3">is not None</span><span class="s1">: 
        </span><span class="s3">return </span><span class="s1">names 
 
    </span><span class="s4"># Not cached -- calculate the value</span><span class="s1"> 
    names = [] 
    </span><span class="s3">if not </span><span class="s1">hasattr(cls</span><span class="s3">, </span><span class="s2">&quot;__slots__&quot;</span><span class="s1">): 
        </span><span class="s4"># This class has no slots</span><span class="s1"> 
        </span><span class="s3">pass</span><span class="s1"> 
    </span><span class="s3">else</span><span class="s1">: 
        </span><span class="s4"># Slots found -- gather slot names from all base classes</span><span class="s1"> 
        </span><span class="s3">for </span><span class="s1">c </span><span class="s3">in </span><span class="s1">cls.__mro__: 
            </span><span class="s3">if </span><span class="s2">&quot;__slots__&quot; </span><span class="s3">in </span><span class="s1">c.__dict__: 
                slots = c.__dict__[</span><span class="s2">'__slots__'</span><span class="s1">] 
                </span><span class="s4"># if class has a single slot, it can be given as a string</span><span class="s1"> 
                </span><span class="s3">if </span><span class="s1">isinstance(slots</span><span class="s3">, </span><span class="s1">str): 
                    slots = (slots</span><span class="s3">,</span><span class="s1">) 
                </span><span class="s3">for </span><span class="s1">name </span><span class="s3">in </span><span class="s1">slots: 
                    </span><span class="s4"># special descriptors</span><span class="s1"> 
                    </span><span class="s3">if </span><span class="s1">name </span><span class="s3">in </span><span class="s1">(</span><span class="s2">&quot;__dict__&quot;</span><span class="s3">, </span><span class="s2">&quot;__weakref__&quot;</span><span class="s1">): 
                        </span><span class="s3">continue</span><span class="s1"> 
                    </span><span class="s4"># mangled names</span><span class="s1"> 
                    </span><span class="s3">elif </span><span class="s1">name.startswith(</span><span class="s2">'__'</span><span class="s1">) </span><span class="s3">and not </span><span class="s1">name.endswith(</span><span class="s2">'__'</span><span class="s1">): 
                        names.append(</span><span class="s2">'_%s%s' </span><span class="s1">% (c.__name__</span><span class="s3">, </span><span class="s1">name)) 
                    </span><span class="s3">else</span><span class="s1">: 
                        names.append(name) 
 
    </span><span class="s4"># Cache the outcome in the class if at all possible</span><span class="s1"> 
    </span><span class="s3">try</span><span class="s1">: 
        cls.__slotnames__ = names 
    </span><span class="s3">except</span><span class="s1">: 
        </span><span class="s3">pass </span><span class="s4"># But don't die if we can't</span><span class="s1"> 
 
    </span><span class="s3">return </span><span class="s1">names 
 
</span><span class="s4"># A registry of extension codes.  This is an ad-hoc compression</span><span class="s1"> 
</span><span class="s4"># mechanism.  Whenever a global reference to &lt;module&gt;, &lt;name&gt; is about</span><span class="s1"> 
</span><span class="s4"># to be pickled, the (&lt;module&gt;, &lt;name&gt;) tuple is looked up here to see</span><span class="s1"> 
</span><span class="s4"># if it is a registered extension code for it.  Extension codes are</span><span class="s1"> 
</span><span class="s4"># universal, so that the meaning of a pickle does not depend on</span><span class="s1"> 
</span><span class="s4"># context.  (There are also some codes reserved for local use that</span><span class="s1"> 
</span><span class="s4"># don't have this restriction.)  Codes are positive ints; 0 is</span><span class="s1"> 
</span><span class="s4"># reserved.</span><span class="s1"> 
 
_extension_registry = {}                </span><span class="s4"># key -&gt; code</span><span class="s1"> 
_inverted_registry = {}                 </span><span class="s4"># code -&gt; key</span><span class="s1"> 
_extension_cache = {}                   </span><span class="s4"># code -&gt; object</span><span class="s1"> 
</span><span class="s4"># Don't ever rebind those names:  pickling grabs a reference to them when</span><span class="s1"> 
</span><span class="s4"># it's initialized, and won't see a rebinding.</span><span class="s1"> 
 
</span><span class="s3">def </span><span class="s1">add_extension(module</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">code): 
    </span><span class="s0">&quot;&quot;&quot;Register an extension code.&quot;&quot;&quot;</span><span class="s1"> 
    code = int(code) 
    </span><span class="s3">if not </span><span class="s5">1 </span><span class="s1">&lt;= code &lt;= </span><span class="s5">0x7fffffff</span><span class="s1">: 
        </span><span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;code out of range&quot;</span><span class="s1">) 
    key = (module</span><span class="s3">, </span><span class="s1">name) 
    </span><span class="s3">if </span><span class="s1">(_extension_registry.get(key) == code </span><span class="s3">and</span><span class="s1"> 
        _inverted_registry.get(code) == key): 
        </span><span class="s3">return </span><span class="s4"># Redundant registrations are benign</span><span class="s1"> 
    </span><span class="s3">if </span><span class="s1">key </span><span class="s3">in </span><span class="s1">_extension_registry: 
        </span><span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;key %s is already registered with code %s&quot; </span><span class="s1">% 
                         (key</span><span class="s3">, </span><span class="s1">_extension_registry[key])) 
    </span><span class="s3">if </span><span class="s1">code </span><span class="s3">in </span><span class="s1">_inverted_registry: 
        </span><span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;code %s is already in use for key %s&quot; </span><span class="s1">% 
                         (code</span><span class="s3">, </span><span class="s1">_inverted_registry[code])) 
    _extension_registry[key] = code 
    _inverted_registry[code] = key 
 
</span><span class="s3">def </span><span class="s1">remove_extension(module</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">code): 
    </span><span class="s0">&quot;&quot;&quot;Unregister an extension code.  For testing only.&quot;&quot;&quot;</span><span class="s1"> 
    key = (module</span><span class="s3">, </span><span class="s1">name) 
    </span><span class="s3">if </span><span class="s1">(_extension_registry.get(key) != code </span><span class="s3">or</span><span class="s1"> 
        _inverted_registry.get(code) != key): 
        </span><span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;key %s is not registered with code %s&quot; </span><span class="s1">% 
                         (key</span><span class="s3">, </span><span class="s1">code)) 
    </span><span class="s3">del </span><span class="s1">_extension_registry[key] 
    </span><span class="s3">del </span><span class="s1">_inverted_registry[code] 
    </span><span class="s3">if </span><span class="s1">code </span><span class="s3">in </span><span class="s1">_extension_cache: 
        </span><span class="s3">del </span><span class="s1">_extension_cache[code] 
 
</span><span class="s3">def </span><span class="s1">clear_extension_cache(): 
    _extension_cache.clear() 
 
</span><span class="s4"># Standard extension code assignments</span><span class="s1"> 
 
</span><span class="s4"># Reserved ranges</span><span class="s1"> 
 
</span><span class="s4"># First  Last Count  Purpose</span><span class="s1"> 
</span><span class="s4">#     1   127   127  Reserved for Python standard library</span><span class="s1"> 
</span><span class="s4">#   128   191    64  Reserved for Zope</span><span class="s1"> 
</span><span class="s4">#   192   239    48  Reserved for 3rd parties</span><span class="s1"> 
</span><span class="s4">#   240   255    16  Reserved for private use (will never be assigned)</span><span class="s1"> 
</span><span class="s4">#   256   Inf   Inf  Reserved for future assignment</span><span class="s1"> 
 
</span><span class="s4"># Extension codes are assigned by the Python Software Foundation.</span><span class="s1"> 
</span></pre>
</body>
</html>