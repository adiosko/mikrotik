<html>
<head>
<title>config.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.ln { color: #606366; font-weight: normal; font-style: normal; }
.s0 { color: rgb(204,120,50); }
.s1 { color: rgb(169,183,198); }
.s2 { color: rgb(98,151,85); font-style: italic; }
.s3 { color: rgb(106,135,89); }
.s4 { color: rgb(128,128,128); }
.s5 { color: rgb(104,151,187); }
</style>
</head>
<BODY BGCOLOR="#2b2b2b">
<TABLE CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<TR><TD><CENTER>
<FONT FACE="Arial, Helvetica" COLOR="#000000">
config.py</FONT>
</center></TD></TR></TABLE>
<pre>
<span class="s0">from </span><span class="s1">__future__ </span><span class="s0">import </span><span class="s1">absolute_import</span><span class="s0">, </span><span class="s1">unicode_literals 
</span><span class="s0">import </span><span class="s1">io 
</span><span class="s0">import </span><span class="s1">os 
</span><span class="s0">import </span><span class="s1">sys 
</span><span class="s0">from </span><span class="s1">collections </span><span class="s0">import </span><span class="s1">defaultdict 
</span><span class="s0">from </span><span class="s1">functools </span><span class="s0">import </span><span class="s1">partial 
</span><span class="s0">from </span><span class="s1">importlib </span><span class="s0">import </span><span class="s1">import_module 
 
</span><span class="s0">from </span><span class="s1">distutils.errors </span><span class="s0">import </span><span class="s1">DistutilsOptionError</span><span class="s0">, </span><span class="s1">DistutilsFileError 
</span><span class="s0">from </span><span class="s1">setuptools.extern.six </span><span class="s0">import </span><span class="s1">string_types 
 
 
</span><span class="s0">def </span><span class="s1">read_configuration( 
        filepath</span><span class="s0">, </span><span class="s1">find_others=</span><span class="s0">False, </span><span class="s1">ignore_option_errors=</span><span class="s0">False</span><span class="s1">): 
    </span><span class="s2">&quot;&quot;&quot;Read given configuration file and returns options from it as a dict. 
 
    :param str|unicode filepath: Path to configuration file 
        to get options from. 
 
    :param bool find_others: Whether to search for other configuration files 
        which could be on in various places. 
 
    :param bool ignore_option_errors: Whether to silently ignore 
        options, values of which could not be resolved (e.g. due to exceptions 
        in directives such as file:, attr:, etc.). 
        If False exceptions are propagated as expected. 
 
    :rtype: dict 
    &quot;&quot;&quot;</span><span class="s1"> 
    </span><span class="s0">from </span><span class="s1">setuptools.dist </span><span class="s0">import </span><span class="s1">Distribution</span><span class="s0">, </span><span class="s1">_Distribution 
 
    filepath = os.path.abspath(filepath) 
 
    </span><span class="s0">if not </span><span class="s1">os.path.isfile(filepath): 
        </span><span class="s0">raise </span><span class="s1">DistutilsFileError( 
            </span><span class="s3">'Configuration file %s does not exist.' </span><span class="s1">% filepath) 
 
    current_directory = os.getcwd() 
    os.chdir(os.path.dirname(filepath)) 
 
    </span><span class="s0">try</span><span class="s1">: 
        dist = Distribution() 
 
        filenames = dist.find_config_files() </span><span class="s0">if </span><span class="s1">find_others </span><span class="s0">else </span><span class="s1">[] 
        </span><span class="s0">if </span><span class="s1">filepath </span><span class="s0">not in </span><span class="s1">filenames: 
            filenames.append(filepath) 
 
        _Distribution.parse_config_files(dist</span><span class="s0">, </span><span class="s1">filenames=filenames) 
 
        handlers = parse_configuration( 
            dist</span><span class="s0">, </span><span class="s1">dist.command_options</span><span class="s0">,</span><span class="s1"> 
            ignore_option_errors=ignore_option_errors) 
 
    </span><span class="s0">finally</span><span class="s1">: 
        os.chdir(current_directory) 
 
    </span><span class="s0">return </span><span class="s1">configuration_to_dict(handlers) 
 
 
</span><span class="s0">def </span><span class="s1">configuration_to_dict(handlers): 
    </span><span class="s2">&quot;&quot;&quot;Returns configuration data gathered by given handlers as a dict. 
 
    :param list[ConfigHandler] handlers: Handlers list, 
        usually from parse_configuration() 
 
    :rtype: dict 
    &quot;&quot;&quot;</span><span class="s1"> 
    config_dict = defaultdict(dict) 
 
    </span><span class="s0">for </span><span class="s1">handler </span><span class="s0">in </span><span class="s1">handlers: 
 
        obj_alias = handler.section_prefix 
        target_obj = handler.target_obj 
 
        </span><span class="s0">for </span><span class="s1">option </span><span class="s0">in </span><span class="s1">handler.set_options: 
            getter = getattr(target_obj</span><span class="s0">, </span><span class="s3">'get_%s' </span><span class="s1">% option</span><span class="s0">, None</span><span class="s1">) 
 
            </span><span class="s0">if </span><span class="s1">getter </span><span class="s0">is None</span><span class="s1">: 
                value = getattr(target_obj</span><span class="s0">, </span><span class="s1">option) 
 
            </span><span class="s0">else</span><span class="s1">: 
                value = getter() 
 
            config_dict[obj_alias][option] = value 
 
    </span><span class="s0">return </span><span class="s1">config_dict 
 
 
</span><span class="s0">def </span><span class="s1">parse_configuration( 
        distribution</span><span class="s0">, </span><span class="s1">command_options</span><span class="s0">, </span><span class="s1">ignore_option_errors=</span><span class="s0">False</span><span class="s1">): 
    </span><span class="s2">&quot;&quot;&quot;Performs additional parsing of configuration options 
    for a distribution. 
 
    Returns a list of used option handlers. 
 
    :param Distribution distribution: 
    :param dict command_options: 
    :param bool ignore_option_errors: Whether to silently ignore 
        options, values of which could not be resolved (e.g. due to exceptions 
        in directives such as file:, attr:, etc.). 
        If False exceptions are propagated as expected. 
    :rtype: list 
    &quot;&quot;&quot;</span><span class="s1"> 
    meta = ConfigMetadataHandler( 
        distribution.metadata</span><span class="s0">, </span><span class="s1">command_options</span><span class="s0">, </span><span class="s1">ignore_option_errors) 
    meta.parse() 
 
    options = ConfigOptionsHandler( 
        distribution</span><span class="s0">, </span><span class="s1">command_options</span><span class="s0">, </span><span class="s1">ignore_option_errors) 
    options.parse() 
 
    </span><span class="s0">return </span><span class="s1">[meta</span><span class="s0">, </span><span class="s1">options] 
 
 
</span><span class="s0">class </span><span class="s1">ConfigHandler(object): 
    </span><span class="s2">&quot;&quot;&quot;Handles metadata supplied in configuration files.&quot;&quot;&quot;</span><span class="s1"> 
 
    section_prefix = </span><span class="s0">None</span><span class="s1"> 
    </span><span class="s3">&quot;&quot;&quot;Prefix for config sections handled by this handler. 
    Must be provided by class heirs. 
 
    &quot;&quot;&quot;</span><span class="s1"> 
 
    aliases = {} 
    </span><span class="s3">&quot;&quot;&quot;Options aliases. 
    For compatibility with various packages. E.g.: d2to1 and pbr. 
    Note: `-` in keys is replaced with `_` by config parser. 
 
    &quot;&quot;&quot;</span><span class="s1"> 
 
    </span><span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">target_obj</span><span class="s0">, </span><span class="s1">options</span><span class="s0">, </span><span class="s1">ignore_option_errors=</span><span class="s0">False</span><span class="s1">): 
        sections = {} 
 
        section_prefix = self.section_prefix 
        </span><span class="s0">for </span><span class="s1">section_name</span><span class="s0">, </span><span class="s1">section_options </span><span class="s0">in </span><span class="s1">options.items(): 
            </span><span class="s0">if not </span><span class="s1">section_name.startswith(section_prefix): 
                </span><span class="s0">continue</span><span class="s1"> 
 
            section_name = section_name.replace(section_prefix</span><span class="s0">, </span><span class="s3">''</span><span class="s1">).strip(</span><span class="s3">'.'</span><span class="s1">) 
            sections[section_name] = section_options 
 
        self.ignore_option_errors = ignore_option_errors 
        self.target_obj = target_obj 
        self.sections = sections 
        self.set_options = [] 
 
    @property 
    </span><span class="s0">def </span><span class="s1">parsers(self): 
        </span><span class="s2">&quot;&quot;&quot;Metadata item name to parser function mapping.&quot;&quot;&quot;</span><span class="s1"> 
        </span><span class="s0">raise </span><span class="s1">NotImplementedError( 
            </span><span class="s3">'%s must provide .parsers property' </span><span class="s1">% self.__class__.__name__) 
 
    </span><span class="s0">def </span><span class="s1">__setitem__(self</span><span class="s0">, </span><span class="s1">option_name</span><span class="s0">, </span><span class="s1">value): 
        unknown = tuple() 
        target_obj = self.target_obj 
 
        </span><span class="s4"># Translate alias into real name.</span><span class="s1"> 
        option_name = self.aliases.get(option_name</span><span class="s0">, </span><span class="s1">option_name) 
 
        current_value = getattr(target_obj</span><span class="s0">, </span><span class="s1">option_name</span><span class="s0">, </span><span class="s1">unknown) 
 
        </span><span class="s0">if </span><span class="s1">current_value </span><span class="s0">is </span><span class="s1">unknown: 
            </span><span class="s0">raise </span><span class="s1">KeyError(option_name) 
 
        </span><span class="s0">if </span><span class="s1">current_value: 
            </span><span class="s4"># Already inhabited. Skipping.</span><span class="s1"> 
            </span><span class="s0">return</span><span class="s1"> 
 
        skip_option = </span><span class="s0">False</span><span class="s1"> 
        parser = self.parsers.get(option_name) 
        </span><span class="s0">if </span><span class="s1">parser: 
            </span><span class="s0">try</span><span class="s1">: 
                value = parser(value) 
 
            </span><span class="s0">except </span><span class="s1">Exception: 
                skip_option = </span><span class="s0">True</span><span class="s1"> 
                </span><span class="s0">if not </span><span class="s1">self.ignore_option_errors: 
                    </span><span class="s0">raise</span><span class="s1"> 
 
        </span><span class="s0">if </span><span class="s1">skip_option: 
            </span><span class="s0">return</span><span class="s1"> 
 
        setter = getattr(target_obj</span><span class="s0">, </span><span class="s3">'set_%s' </span><span class="s1">% option_name</span><span class="s0">, None</span><span class="s1">) 
        </span><span class="s0">if </span><span class="s1">setter </span><span class="s0">is None</span><span class="s1">: 
            setattr(target_obj</span><span class="s0">, </span><span class="s1">option_name</span><span class="s0">, </span><span class="s1">value) 
        </span><span class="s0">else</span><span class="s1">: 
            setter(value) 
 
        self.set_options.append(option_name) 
 
    @classmethod 
    </span><span class="s0">def </span><span class="s1">_parse_list(cls</span><span class="s0">, </span><span class="s1">value</span><span class="s0">, </span><span class="s1">separator=</span><span class="s3">','</span><span class="s1">): 
        </span><span class="s2">&quot;&quot;&quot;Represents value as a list. 
 
        Value is split either by separator (defaults to comma) or by lines. 
 
        :param value: 
        :param separator: List items separator character. 
        :rtype: list 
        &quot;&quot;&quot;</span><span class="s1"> 
        </span><span class="s0">if </span><span class="s1">isinstance(value</span><span class="s0">, </span><span class="s1">list):  </span><span class="s4"># _get_parser_compound case</span><span class="s1"> 
            </span><span class="s0">return </span><span class="s1">value 
 
        </span><span class="s0">if </span><span class="s3">'</span><span class="s0">\n</span><span class="s3">' </span><span class="s0">in </span><span class="s1">value: 
            value = value.splitlines() 
        </span><span class="s0">else</span><span class="s1">: 
            value = value.split(separator) 
 
        </span><span class="s0">return </span><span class="s1">[chunk.strip() </span><span class="s0">for </span><span class="s1">chunk </span><span class="s0">in </span><span class="s1">value </span><span class="s0">if </span><span class="s1">chunk.strip()] 
 
    @classmethod 
    </span><span class="s0">def </span><span class="s1">_parse_dict(cls</span><span class="s0">, </span><span class="s1">value): 
        </span><span class="s2">&quot;&quot;&quot;Represents value as a dict. 
 
        :param value: 
        :rtype: dict 
        &quot;&quot;&quot;</span><span class="s1"> 
        separator = </span><span class="s3">'='</span><span class="s1"> 
        result = {} 
        </span><span class="s0">for </span><span class="s1">line </span><span class="s0">in </span><span class="s1">cls._parse_list(value): 
            key</span><span class="s0">, </span><span class="s1">sep</span><span class="s0">, </span><span class="s1">val = line.partition(separator) 
            </span><span class="s0">if </span><span class="s1">sep != separator: 
                </span><span class="s0">raise </span><span class="s1">DistutilsOptionError( 
                    </span><span class="s3">'Unable to parse option value to dict: %s' </span><span class="s1">% value) 
            result[key.strip()] = val.strip() 
 
        </span><span class="s0">return </span><span class="s1">result 
 
    @classmethod 
    </span><span class="s0">def </span><span class="s1">_parse_bool(cls</span><span class="s0">, </span><span class="s1">value): 
        </span><span class="s2">&quot;&quot;&quot;Represents value as boolean. 
 
        :param value: 
        :rtype: bool 
        &quot;&quot;&quot;</span><span class="s1"> 
        value = value.lower() 
        </span><span class="s0">return </span><span class="s1">value </span><span class="s0">in </span><span class="s1">(</span><span class="s3">'1'</span><span class="s0">, </span><span class="s3">'true'</span><span class="s0">, </span><span class="s3">'yes'</span><span class="s1">) 
 
    @classmethod 
    </span><span class="s0">def </span><span class="s1">_parse_file(cls</span><span class="s0">, </span><span class="s1">value): 
        </span><span class="s2">&quot;&quot;&quot;Represents value as a string, allowing including text 
        from nearest files using `file:` directive. 
 
        Directive is sandboxed and won't reach anything outside 
        directory with setup.py. 
 
        Examples: 
            file: LICENSE 
            file: README.rst, CHANGELOG.md, src/file.txt 
 
        :param str value: 
        :rtype: str 
        &quot;&quot;&quot;</span><span class="s1"> 
        include_directive = </span><span class="s3">'file:'</span><span class="s1"> 
 
        </span><span class="s0">if not </span><span class="s1">isinstance(value</span><span class="s0">, </span><span class="s1">string_types): 
            </span><span class="s0">return </span><span class="s1">value 
 
        </span><span class="s0">if not </span><span class="s1">value.startswith(include_directive): 
            </span><span class="s0">return </span><span class="s1">value 
 
        spec = value[len(include_directive):] 
        filepaths = (os.path.abspath(path.strip()) </span><span class="s0">for </span><span class="s1">path </span><span class="s0">in </span><span class="s1">spec.split(</span><span class="s3">','</span><span class="s1">)) 
        </span><span class="s0">return </span><span class="s3">'</span><span class="s0">\n</span><span class="s3">'</span><span class="s1">.join( 
            cls._read_file(path) 
            </span><span class="s0">for </span><span class="s1">path </span><span class="s0">in </span><span class="s1">filepaths 
            </span><span class="s0">if </span><span class="s1">(cls._assert_local(path) </span><span class="s0">or True</span><span class="s1">) 
            </span><span class="s0">and </span><span class="s1">os.path.isfile(path) 
        ) 
 
    @staticmethod 
    </span><span class="s0">def </span><span class="s1">_assert_local(filepath): 
        </span><span class="s0">if not </span><span class="s1">filepath.startswith(os.getcwd()): 
            </span><span class="s0">raise </span><span class="s1">DistutilsOptionError( 
                </span><span class="s3">'`file:` directive can not access %s' </span><span class="s1">% filepath) 
 
    @staticmethod 
    </span><span class="s0">def </span><span class="s1">_read_file(filepath): 
        </span><span class="s0">with </span><span class="s1">io.open(filepath</span><span class="s0">, </span><span class="s1">encoding=</span><span class="s3">'utf-8'</span><span class="s1">) </span><span class="s0">as </span><span class="s1">f: 
            </span><span class="s0">return </span><span class="s1">f.read() 
 
    @classmethod 
    </span><span class="s0">def </span><span class="s1">_parse_attr(cls</span><span class="s0">, </span><span class="s1">value): 
        </span><span class="s2">&quot;&quot;&quot;Represents value as a module attribute. 
 
        Examples: 
            attr: package.attr 
            attr: package.module.attr 
 
        :param str value: 
        :rtype: str 
        &quot;&quot;&quot;</span><span class="s1"> 
        attr_directive = </span><span class="s3">'attr:'</span><span class="s1"> 
        </span><span class="s0">if not </span><span class="s1">value.startswith(attr_directive): 
            </span><span class="s0">return </span><span class="s1">value 
 
        attrs_path = value.replace(attr_directive</span><span class="s0">, </span><span class="s3">''</span><span class="s1">).strip().split(</span><span class="s3">'.'</span><span class="s1">) 
        attr_name = attrs_path.pop() 
 
        module_name = </span><span class="s3">'.'</span><span class="s1">.join(attrs_path) 
        module_name = module_name </span><span class="s0">or </span><span class="s3">'__init__'</span><span class="s1"> 
 
        sys.path.insert(</span><span class="s5">0</span><span class="s0">, </span><span class="s1">os.getcwd()) 
        </span><span class="s0">try</span><span class="s1">: 
            module = import_module(module_name) 
            value = getattr(module</span><span class="s0">, </span><span class="s1">attr_name) 
 
        </span><span class="s0">finally</span><span class="s1">: 
            sys.path = sys.path[</span><span class="s5">1</span><span class="s1">:] 
 
        </span><span class="s0">return </span><span class="s1">value 
 
    @classmethod 
    </span><span class="s0">def </span><span class="s1">_get_parser_compound(cls</span><span class="s0">, </span><span class="s1">*parse_methods): 
        </span><span class="s2">&quot;&quot;&quot;Returns parser function to represents value as a list. 
 
        Parses a value applying given methods one after another. 
 
        :param parse_methods: 
        :rtype: callable 
        &quot;&quot;&quot;</span><span class="s1"> 
        </span><span class="s0">def </span><span class="s1">parse(value): 
            parsed = value 
 
            </span><span class="s0">for </span><span class="s1">method </span><span class="s0">in </span><span class="s1">parse_methods: 
                parsed = method(parsed) 
 
            </span><span class="s0">return </span><span class="s1">parsed 
 
        </span><span class="s0">return </span><span class="s1">parse 
 
    @classmethod 
    </span><span class="s0">def </span><span class="s1">_parse_section_to_dict(cls</span><span class="s0">, </span><span class="s1">section_options</span><span class="s0">, </span><span class="s1">values_parser=</span><span class="s0">None</span><span class="s1">): 
        </span><span class="s2">&quot;&quot;&quot;Parses section options into a dictionary. 
 
        Optionally applies a given parser to values. 
 
        :param dict section_options: 
        :param callable values_parser: 
        :rtype: dict 
        &quot;&quot;&quot;</span><span class="s1"> 
        value = {} 
        values_parser = values_parser </span><span class="s0">or </span><span class="s1">(</span><span class="s0">lambda </span><span class="s1">val: val) 
        </span><span class="s0">for </span><span class="s1">key</span><span class="s0">, </span><span class="s1">(_</span><span class="s0">, </span><span class="s1">val) </span><span class="s0">in </span><span class="s1">section_options.items(): 
            value[key] = values_parser(val) 
        </span><span class="s0">return </span><span class="s1">value 
 
    </span><span class="s0">def </span><span class="s1">parse_section(self</span><span class="s0">, </span><span class="s1">section_options): 
        </span><span class="s2">&quot;&quot;&quot;Parses configuration file section. 
 
        :param dict section_options: 
        &quot;&quot;&quot;</span><span class="s1"> 
        </span><span class="s0">for </span><span class="s1">(name</span><span class="s0">, </span><span class="s1">(_</span><span class="s0">, </span><span class="s1">value)) </span><span class="s0">in </span><span class="s1">section_options.items(): 
            </span><span class="s0">try</span><span class="s1">: 
                self[name] = value 
 
            </span><span class="s0">except </span><span class="s1">KeyError: 
                </span><span class="s0">pass  </span><span class="s4"># Keep silent for a new option may appear anytime.</span><span class="s1"> 
 
    </span><span class="s0">def </span><span class="s1">parse(self): 
        </span><span class="s2">&quot;&quot;&quot;Parses configuration file items from one 
        or more related sections. 
 
        &quot;&quot;&quot;</span><span class="s1"> 
        </span><span class="s0">for </span><span class="s1">section_name</span><span class="s0">, </span><span class="s1">section_options </span><span class="s0">in </span><span class="s1">self.sections.items(): 
 
            method_postfix = </span><span class="s3">''</span><span class="s1"> 
            </span><span class="s0">if </span><span class="s1">section_name:  </span><span class="s4"># [section.option] variant</span><span class="s1"> 
                method_postfix = </span><span class="s3">'_%s' </span><span class="s1">% section_name 
 
            section_parser_method = getattr( 
                self</span><span class="s0">,</span><span class="s1"> 
                </span><span class="s4"># Dots in section names are tranlsated into dunderscores.</span><span class="s1"> 
                (</span><span class="s3">'parse_section%s' </span><span class="s1">% method_postfix).replace(</span><span class="s3">'.'</span><span class="s0">, </span><span class="s3">'__'</span><span class="s1">)</span><span class="s0">,</span><span class="s1"> 
                </span><span class="s0">None</span><span class="s1">) 
 
            </span><span class="s0">if </span><span class="s1">section_parser_method </span><span class="s0">is None</span><span class="s1">: 
                </span><span class="s0">raise </span><span class="s1">DistutilsOptionError( 
                    </span><span class="s3">'Unsupported distribution option section: [%s.%s]' </span><span class="s1">% ( 
                        self.section_prefix</span><span class="s0">, </span><span class="s1">section_name)) 
 
            section_parser_method(section_options) 
 
 
</span><span class="s0">class </span><span class="s1">ConfigMetadataHandler(ConfigHandler): 
 
    section_prefix = </span><span class="s3">'metadata'</span><span class="s1"> 
 
    aliases = { 
        </span><span class="s3">'home_page'</span><span class="s1">: </span><span class="s3">'url'</span><span class="s0">,</span><span class="s1"> 
        </span><span class="s3">'summary'</span><span class="s1">: </span><span class="s3">'description'</span><span class="s0">,</span><span class="s1"> 
        </span><span class="s3">'classifier'</span><span class="s1">: </span><span class="s3">'classifiers'</span><span class="s0">,</span><span class="s1"> 
        </span><span class="s3">'platform'</span><span class="s1">: </span><span class="s3">'platforms'</span><span class="s0">,</span><span class="s1"> 
    } 
 
    strict_mode = </span><span class="s0">False</span><span class="s1"> 
    </span><span class="s3">&quot;&quot;&quot;We need to keep it loose, to be partially compatible with 
    `pbr` and `d2to1` packages which also uses `metadata` section. 
 
    &quot;&quot;&quot;</span><span class="s1"> 
 
    @property 
    </span><span class="s0">def </span><span class="s1">parsers(self): 
        </span><span class="s2">&quot;&quot;&quot;Metadata item name to parser function mapping.&quot;&quot;&quot;</span><span class="s1"> 
        parse_list = self._parse_list 
        parse_file = self._parse_file 
        parse_dict = self._parse_dict 
 
        </span><span class="s0">return </span><span class="s1">{ 
            </span><span class="s3">'platforms'</span><span class="s1">: parse_list</span><span class="s0">,</span><span class="s1"> 
            </span><span class="s3">'keywords'</span><span class="s1">: parse_list</span><span class="s0">,</span><span class="s1"> 
            </span><span class="s3">'provides'</span><span class="s1">: parse_list</span><span class="s0">,</span><span class="s1"> 
            </span><span class="s3">'requires'</span><span class="s1">: parse_list</span><span class="s0">,</span><span class="s1"> 
            </span><span class="s3">'obsoletes'</span><span class="s1">: parse_list</span><span class="s0">,</span><span class="s1"> 
            </span><span class="s3">'classifiers'</span><span class="s1">: self._get_parser_compound(parse_file</span><span class="s0">, </span><span class="s1">parse_list)</span><span class="s0">,</span><span class="s1"> 
            </span><span class="s3">'license'</span><span class="s1">: parse_file</span><span class="s0">,</span><span class="s1"> 
            </span><span class="s3">'description'</span><span class="s1">: parse_file</span><span class="s0">,</span><span class="s1"> 
            </span><span class="s3">'long_description'</span><span class="s1">: parse_file</span><span class="s0">,</span><span class="s1"> 
            </span><span class="s3">'version'</span><span class="s1">: self._parse_version</span><span class="s0">,</span><span class="s1"> 
            </span><span class="s3">'project_urls'</span><span class="s1">: parse_dict</span><span class="s0">,</span><span class="s1"> 
        } 
 
    </span><span class="s0">def </span><span class="s1">_parse_version(self</span><span class="s0">, </span><span class="s1">value): 
        </span><span class="s2">&quot;&quot;&quot;Parses `version` option value. 
 
        :param value: 
        :rtype: str 
 
        &quot;&quot;&quot;</span><span class="s1"> 
        version = self._parse_attr(value) 
 
        </span><span class="s0">if </span><span class="s1">callable(version): 
            version = version() 
 
        </span><span class="s0">if not </span><span class="s1">isinstance(version</span><span class="s0">, </span><span class="s1">string_types): 
            </span><span class="s0">if </span><span class="s1">hasattr(version</span><span class="s0">, </span><span class="s3">'__iter__'</span><span class="s1">): 
                version = </span><span class="s3">'.'</span><span class="s1">.join(map(str</span><span class="s0">, </span><span class="s1">version)) 
            </span><span class="s0">else</span><span class="s1">: 
                version = </span><span class="s3">'%s' </span><span class="s1">% version 
 
        </span><span class="s0">return </span><span class="s1">version 
 
 
</span><span class="s0">class </span><span class="s1">ConfigOptionsHandler(ConfigHandler): 
 
    section_prefix = </span><span class="s3">'options'</span><span class="s1"> 
 
    @property 
    </span><span class="s0">def </span><span class="s1">parsers(self): 
        </span><span class="s2">&quot;&quot;&quot;Metadata item name to parser function mapping.&quot;&quot;&quot;</span><span class="s1"> 
        parse_list = self._parse_list 
        parse_list_semicolon = partial(self._parse_list</span><span class="s0">, </span><span class="s1">separator=</span><span class="s3">';'</span><span class="s1">) 
        parse_bool = self._parse_bool 
        parse_dict = self._parse_dict 
 
        </span><span class="s0">return </span><span class="s1">{ 
            </span><span class="s3">'zip_safe'</span><span class="s1">: parse_bool</span><span class="s0">,</span><span class="s1"> 
            </span><span class="s3">'use_2to3'</span><span class="s1">: parse_bool</span><span class="s0">,</span><span class="s1"> 
            </span><span class="s3">'include_package_data'</span><span class="s1">: parse_bool</span><span class="s0">,</span><span class="s1"> 
            </span><span class="s3">'package_dir'</span><span class="s1">: parse_dict</span><span class="s0">,</span><span class="s1"> 
            </span><span class="s3">'use_2to3_fixers'</span><span class="s1">: parse_list</span><span class="s0">,</span><span class="s1"> 
            </span><span class="s3">'use_2to3_exclude_fixers'</span><span class="s1">: parse_list</span><span class="s0">,</span><span class="s1"> 
            </span><span class="s3">'convert_2to3_doctests'</span><span class="s1">: parse_list</span><span class="s0">,</span><span class="s1"> 
            </span><span class="s3">'scripts'</span><span class="s1">: parse_list</span><span class="s0">,</span><span class="s1"> 
            </span><span class="s3">'eager_resources'</span><span class="s1">: parse_list</span><span class="s0">,</span><span class="s1"> 
            </span><span class="s3">'dependency_links'</span><span class="s1">: parse_list</span><span class="s0">,</span><span class="s1"> 
            </span><span class="s3">'namespace_packages'</span><span class="s1">: parse_list</span><span class="s0">,</span><span class="s1"> 
            </span><span class="s3">'install_requires'</span><span class="s1">: parse_list_semicolon</span><span class="s0">,</span><span class="s1"> 
            </span><span class="s3">'setup_requires'</span><span class="s1">: parse_list_semicolon</span><span class="s0">,</span><span class="s1"> 
            </span><span class="s3">'tests_require'</span><span class="s1">: parse_list_semicolon</span><span class="s0">,</span><span class="s1"> 
            </span><span class="s3">'packages'</span><span class="s1">: self._parse_packages</span><span class="s0">,</span><span class="s1"> 
            </span><span class="s3">'entry_points'</span><span class="s1">: self._parse_file</span><span class="s0">,</span><span class="s1"> 
            </span><span class="s3">'py_modules'</span><span class="s1">: parse_list</span><span class="s0">,</span><span class="s1"> 
        } 
 
    </span><span class="s0">def </span><span class="s1">_parse_packages(self</span><span class="s0">, </span><span class="s1">value): 
        </span><span class="s2">&quot;&quot;&quot;Parses `packages` option value. 
 
        :param value: 
        :rtype: list 
        &quot;&quot;&quot;</span><span class="s1"> 
        find_directive = </span><span class="s3">'find:'</span><span class="s1"> 
 
        </span><span class="s0">if not </span><span class="s1">value.startswith(find_directive): 
            </span><span class="s0">return </span><span class="s1">self._parse_list(value) 
 
        </span><span class="s4"># Read function arguments from a dedicated section.</span><span class="s1"> 
        find_kwargs = self.parse_section_packages__find( 
            self.sections.get(</span><span class="s3">'packages.find'</span><span class="s0">, </span><span class="s1">{})) 
 
        </span><span class="s0">from </span><span class="s1">setuptools </span><span class="s0">import </span><span class="s1">find_packages 
 
        </span><span class="s0">return </span><span class="s1">find_packages(**find_kwargs) 
 
    </span><span class="s0">def </span><span class="s1">parse_section_packages__find(self</span><span class="s0">, </span><span class="s1">section_options): 
        </span><span class="s2">&quot;&quot;&quot;Parses `packages.find` configuration file section. 
 
        To be used in conjunction with _parse_packages(). 
 
        :param dict section_options: 
        &quot;&quot;&quot;</span><span class="s1"> 
        section_data = self._parse_section_to_dict( 
            section_options</span><span class="s0">, </span><span class="s1">self._parse_list) 
 
        valid_keys = [</span><span class="s3">'where'</span><span class="s0">, </span><span class="s3">'include'</span><span class="s0">, </span><span class="s3">'exclude'</span><span class="s1">] 
 
        find_kwargs = dict( 
            [(k</span><span class="s0">, </span><span class="s1">v) </span><span class="s0">for </span><span class="s1">k</span><span class="s0">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">section_data.items() </span><span class="s0">if </span><span class="s1">k </span><span class="s0">in </span><span class="s1">valid_keys </span><span class="s0">and </span><span class="s1">v]) 
 
        where = find_kwargs.get(</span><span class="s3">'where'</span><span class="s1">) 
        </span><span class="s0">if </span><span class="s1">where </span><span class="s0">is not None</span><span class="s1">: 
            find_kwargs[</span><span class="s3">'where'</span><span class="s1">] = where[</span><span class="s5">0</span><span class="s1">]  </span><span class="s4"># cast list to single val</span><span class="s1"> 
 
        </span><span class="s0">return </span><span class="s1">find_kwargs 
 
    </span><span class="s0">def </span><span class="s1">parse_section_entry_points(self</span><span class="s0">, </span><span class="s1">section_options): 
        </span><span class="s2">&quot;&quot;&quot;Parses `entry_points` configuration file section. 
 
        :param dict section_options: 
        &quot;&quot;&quot;</span><span class="s1"> 
        parsed = self._parse_section_to_dict(section_options</span><span class="s0">, </span><span class="s1">self._parse_list) 
        self[</span><span class="s3">'entry_points'</span><span class="s1">] = parsed 
 
    </span><span class="s0">def </span><span class="s1">_parse_package_data(self</span><span class="s0">, </span><span class="s1">section_options): 
        parsed = self._parse_section_to_dict(section_options</span><span class="s0">, </span><span class="s1">self._parse_list) 
 
        root = parsed.get(</span><span class="s3">'*'</span><span class="s1">) 
        </span><span class="s0">if </span><span class="s1">root: 
            parsed[</span><span class="s3">''</span><span class="s1">] = root 
            </span><span class="s0">del </span><span class="s1">parsed[</span><span class="s3">'*'</span><span class="s1">] 
 
        </span><span class="s0">return </span><span class="s1">parsed 
 
    </span><span class="s0">def </span><span class="s1">parse_section_package_data(self</span><span class="s0">, </span><span class="s1">section_options): 
        </span><span class="s2">&quot;&quot;&quot;Parses `package_data` configuration file section. 
 
        :param dict section_options: 
        &quot;&quot;&quot;</span><span class="s1"> 
        self[</span><span class="s3">'package_data'</span><span class="s1">] = self._parse_package_data(section_options) 
 
    </span><span class="s0">def </span><span class="s1">parse_section_exclude_package_data(self</span><span class="s0">, </span><span class="s1">section_options): 
        </span><span class="s2">&quot;&quot;&quot;Parses `exclude_package_data` configuration file section. 
 
        :param dict section_options: 
        &quot;&quot;&quot;</span><span class="s1"> 
        self[</span><span class="s3">'exclude_package_data'</span><span class="s1">] = self._parse_package_data( 
            section_options) 
 
    </span><span class="s0">def </span><span class="s1">parse_section_extras_require(self</span><span class="s0">, </span><span class="s1">section_options): 
        </span><span class="s2">&quot;&quot;&quot;Parses `extras_require` configuration file section. 
 
        :param dict section_options: 
        &quot;&quot;&quot;</span><span class="s1"> 
        parse_list = partial(self._parse_list</span><span class="s0">, </span><span class="s1">separator=</span><span class="s3">';'</span><span class="s1">) 
        self[</span><span class="s3">'extras_require'</span><span class="s1">] = self._parse_section_to_dict( 
            section_options</span><span class="s0">, </span><span class="s1">parse_list) 
</span></pre>
</body>
</html>