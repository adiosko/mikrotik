<html>
<head>
<title>git.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.ln { color: #606366; font-weight: normal; font-style: normal; }
.s0 { color: rgb(204,120,50); }
.s1 { color: rgb(169,183,198); }
.s2 { color: rgb(106,135,89); }
.s3 { color: rgb(128,128,128); }
.s4 { color: rgb(104,151,187); }
.s5 { color: rgb(98,151,85); font-style: italic; }
</style>
</head>
<BODY BGCOLOR="#2b2b2b">
<TABLE CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<TR><TD><CENTER>
<FONT FACE="Arial, Helvetica" COLOR="#000000">
git.py</FONT>
</center></TD></TR></TABLE>
<pre>
<span class="s0">from </span><span class="s1">__future__ </span><span class="s0">import </span><span class="s1">absolute_import 
 
</span><span class="s0">import </span><span class="s1">logging 
</span><span class="s0">import </span><span class="s1">tempfile 
</span><span class="s0">import </span><span class="s1">os.path 
 
</span><span class="s0">from </span><span class="s1">pip.compat </span><span class="s0">import </span><span class="s1">samefile 
</span><span class="s0">from </span><span class="s1">pip.exceptions </span><span class="s0">import </span><span class="s1">BadCommand 
</span><span class="s0">from </span><span class="s1">pip._vendor.six.moves.urllib </span><span class="s0">import </span><span class="s1">parse </span><span class="s0">as </span><span class="s1">urllib_parse 
</span><span class="s0">from </span><span class="s1">pip._vendor.six.moves.urllib </span><span class="s0">import </span><span class="s1">request </span><span class="s0">as </span><span class="s1">urllib_request 
</span><span class="s0">from </span><span class="s1">pip._vendor.packaging.version </span><span class="s0">import </span><span class="s1">parse </span><span class="s0">as </span><span class="s1">parse_version 
 
</span><span class="s0">from </span><span class="s1">pip.utils </span><span class="s0">import </span><span class="s1">display_path</span><span class="s0">, </span><span class="s1">rmtree 
</span><span class="s0">from </span><span class="s1">pip.vcs </span><span class="s0">import </span><span class="s1">vcs</span><span class="s0">, </span><span class="s1">VersionControl 
 
 
urlsplit = urllib_parse.urlsplit 
urlunsplit = urllib_parse.urlunsplit 
 
 
logger = logging.getLogger(__name__) 
 
 
</span><span class="s0">class </span><span class="s1">Git(VersionControl): 
    name = </span><span class="s2">'git'</span><span class="s1"> 
    dirname = </span><span class="s2">'.git'</span><span class="s1"> 
    repo_name = </span><span class="s2">'clone'</span><span class="s1"> 
    schemes = ( 
        </span><span class="s2">'git'</span><span class="s0">, </span><span class="s2">'git+http'</span><span class="s0">, </span><span class="s2">'git+https'</span><span class="s0">, </span><span class="s2">'git+ssh'</span><span class="s0">, </span><span class="s2">'git+git'</span><span class="s0">, </span><span class="s2">'git+file'</span><span class="s0">,</span><span class="s1"> 
    ) 
 
    </span><span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">url=</span><span class="s0">None, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs): 
 
        </span><span class="s3"># Works around an apparent Git bug</span><span class="s1"> 
        </span><span class="s3"># (see http://article.gmane.org/gmane.comp.version-control.git/146500)</span><span class="s1"> 
        </span><span class="s0">if </span><span class="s1">url: 
            scheme</span><span class="s0">, </span><span class="s1">netloc</span><span class="s0">, </span><span class="s1">path</span><span class="s0">, </span><span class="s1">query</span><span class="s0">, </span><span class="s1">fragment = urlsplit(url) 
            </span><span class="s0">if </span><span class="s1">scheme.endswith(</span><span class="s2">'file'</span><span class="s1">): 
                initial_slashes = path[:-len(path.lstrip(</span><span class="s2">'/'</span><span class="s1">))] 
                newpath = ( 
                    initial_slashes + 
                    urllib_request.url2pathname(path) 
                    .replace(</span><span class="s2">'</span><span class="s0">\\</span><span class="s2">'</span><span class="s0">, </span><span class="s2">'/'</span><span class="s1">).lstrip(</span><span class="s2">'/'</span><span class="s1">) 
                ) 
                url = urlunsplit((scheme</span><span class="s0">, </span><span class="s1">netloc</span><span class="s0">, </span><span class="s1">newpath</span><span class="s0">, </span><span class="s1">query</span><span class="s0">, </span><span class="s1">fragment)) 
                after_plus = scheme.find(</span><span class="s2">'+'</span><span class="s1">) + </span><span class="s4">1</span><span class="s1"> 
                url = scheme[:after_plus] + urlunsplit( 
                    (scheme[after_plus:]</span><span class="s0">, </span><span class="s1">netloc</span><span class="s0">, </span><span class="s1">newpath</span><span class="s0">, </span><span class="s1">query</span><span class="s0">, </span><span class="s1">fragment)</span><span class="s0">,</span><span class="s1"> 
                ) 
 
        super(Git</span><span class="s0">, </span><span class="s1">self).__init__(url</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs) 
 
    </span><span class="s0">def </span><span class="s1">get_git_version(self): 
        VERSION_PFX = </span><span class="s2">'git version '</span><span class="s1"> 
        version = self.run_command([</span><span class="s2">'version'</span><span class="s1">]</span><span class="s0">, </span><span class="s1">show_stdout=</span><span class="s0">False</span><span class="s1">) 
        </span><span class="s0">if </span><span class="s1">version.startswith(VERSION_PFX): 
            version = version[len(VERSION_PFX):] 
        </span><span class="s0">else</span><span class="s1">: 
            version = </span><span class="s2">''</span><span class="s1"> 
        </span><span class="s3"># get first 3 positions of the git version becasue</span><span class="s1"> 
        </span><span class="s3"># on windows it is x.y.z.windows.t, and this parses as</span><span class="s1"> 
        </span><span class="s3"># LegacyVersion which always smaller than a Version.</span><span class="s1"> 
        version = </span><span class="s2">'.'</span><span class="s1">.join(version.split(</span><span class="s2">'.'</span><span class="s1">)[:</span><span class="s4">3</span><span class="s1">]) 
        </span><span class="s0">return </span><span class="s1">parse_version(version) 
 
    </span><span class="s0">def </span><span class="s1">export(self</span><span class="s0">, </span><span class="s1">location): 
        </span><span class="s5">&quot;&quot;&quot;Export the Git repository at the url to the destination location&quot;&quot;&quot;</span><span class="s1"> 
        temp_dir = tempfile.mkdtemp(</span><span class="s2">'-export'</span><span class="s0">, </span><span class="s2">'pip-'</span><span class="s1">) 
        self.unpack(temp_dir) 
        </span><span class="s0">try</span><span class="s1">: 
            </span><span class="s0">if not </span><span class="s1">location.endswith(</span><span class="s2">'/'</span><span class="s1">): 
                location = location + </span><span class="s2">'/'</span><span class="s1"> 
            self.run_command( 
                [</span><span class="s2">'checkout-index'</span><span class="s0">, </span><span class="s2">'-a'</span><span class="s0">, </span><span class="s2">'-f'</span><span class="s0">, </span><span class="s2">'--prefix'</span><span class="s0">, </span><span class="s1">location]</span><span class="s0">,</span><span class="s1"> 
                show_stdout=</span><span class="s0">False, </span><span class="s1">cwd=temp_dir) 
        </span><span class="s0">finally</span><span class="s1">: 
            rmtree(temp_dir) 
 
    </span><span class="s0">def </span><span class="s1">check_rev_options(self</span><span class="s0">, </span><span class="s1">rev</span><span class="s0">, </span><span class="s1">dest</span><span class="s0">, </span><span class="s1">rev_options): 
        </span><span class="s5">&quot;&quot;&quot;Check the revision options before checkout to compensate that tags 
        and branches may need origin/ as a prefix. 
        Returns the SHA1 of the branch or tag if found. 
        &quot;&quot;&quot;</span><span class="s1"> 
        revisions = self.get_short_refs(dest) 
 
        origin_rev = </span><span class="s2">'origin/%s' </span><span class="s1">% rev 
        </span><span class="s0">if </span><span class="s1">origin_rev </span><span class="s0">in </span><span class="s1">revisions: 
            </span><span class="s3"># remote branch</span><span class="s1"> 
            </span><span class="s0">return </span><span class="s1">[revisions[origin_rev]] 
        </span><span class="s0">elif </span><span class="s1">rev </span><span class="s0">in </span><span class="s1">revisions: 
            </span><span class="s3"># a local tag or branch name</span><span class="s1"> 
            </span><span class="s0">return </span><span class="s1">[revisions[rev]] 
        </span><span class="s0">else</span><span class="s1">: 
            logger.warning( 
                </span><span class="s2">&quot;Could not find a tag or branch '%s', assuming commit.&quot;</span><span class="s0">, </span><span class="s1">rev</span><span class="s0">,</span><span class="s1"> 
            ) 
            </span><span class="s0">return </span><span class="s1">rev_options 
 
    </span><span class="s0">def </span><span class="s1">check_version(self</span><span class="s0">, </span><span class="s1">dest</span><span class="s0">, </span><span class="s1">rev_options): 
        </span><span class="s5">&quot;&quot;&quot; 
        Compare the current sha to the ref. ref may be a branch or tag name, 
        but current rev will always point to a sha. This means that a branch 
        or tag will never compare as True. So this ultimately only matches 
        against exact shas. 
        &quot;&quot;&quot;</span><span class="s1"> 
        </span><span class="s0">return </span><span class="s1">self.get_revision(dest).startswith(rev_options[</span><span class="s4">0</span><span class="s1">]) 
 
    </span><span class="s0">def </span><span class="s1">switch(self</span><span class="s0">, </span><span class="s1">dest</span><span class="s0">, </span><span class="s1">url</span><span class="s0">, </span><span class="s1">rev_options): 
        self.run_command([</span><span class="s2">'config'</span><span class="s0">, </span><span class="s2">'remote.origin.url'</span><span class="s0">, </span><span class="s1">url]</span><span class="s0">, </span><span class="s1">cwd=dest) 
        self.run_command([</span><span class="s2">'checkout'</span><span class="s0">, </span><span class="s2">'-q'</span><span class="s1">] + rev_options</span><span class="s0">, </span><span class="s1">cwd=dest) 
 
        self.update_submodules(dest) 
 
    </span><span class="s0">def </span><span class="s1">update(self</span><span class="s0">, </span><span class="s1">dest</span><span class="s0">, </span><span class="s1">rev_options): 
        </span><span class="s3"># First fetch changes from the default remote</span><span class="s1"> 
        </span><span class="s0">if </span><span class="s1">self.get_git_version() &gt;= parse_version(</span><span class="s2">'1.9.0'</span><span class="s1">): 
            </span><span class="s3"># fetch tags in addition to everything else</span><span class="s1"> 
            self.run_command([</span><span class="s2">'fetch'</span><span class="s0">, </span><span class="s2">'-q'</span><span class="s0">, </span><span class="s2">'--tags'</span><span class="s1">]</span><span class="s0">, </span><span class="s1">cwd=dest) 
        </span><span class="s0">else</span><span class="s1">: 
            self.run_command([</span><span class="s2">'fetch'</span><span class="s0">, </span><span class="s2">'-q'</span><span class="s1">]</span><span class="s0">, </span><span class="s1">cwd=dest) 
        </span><span class="s3"># Then reset to wanted revision (maybe even origin/master)</span><span class="s1"> 
        </span><span class="s0">if </span><span class="s1">rev_options: 
            rev_options = self.check_rev_options( 
                rev_options[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dest</span><span class="s0">, </span><span class="s1">rev_options</span><span class="s0">,</span><span class="s1"> 
            ) 
        self.run_command([</span><span class="s2">'reset'</span><span class="s0">, </span><span class="s2">'--hard'</span><span class="s0">, </span><span class="s2">'-q'</span><span class="s1">] + rev_options</span><span class="s0">, </span><span class="s1">cwd=dest) 
        </span><span class="s3">#: update submodules</span><span class="s1"> 
        self.update_submodules(dest) 
 
    </span><span class="s0">def </span><span class="s1">obtain(self</span><span class="s0">, </span><span class="s1">dest): 
        url</span><span class="s0">, </span><span class="s1">rev = self.get_url_rev() 
        </span><span class="s0">if </span><span class="s1">rev: 
            rev_options = [rev] 
            rev_display = </span><span class="s2">' (to %s)' </span><span class="s1">% rev 
        </span><span class="s0">else</span><span class="s1">: 
            rev_options = [</span><span class="s2">'origin/master'</span><span class="s1">] 
            rev_display = </span><span class="s2">''</span><span class="s1"> 
        </span><span class="s0">if </span><span class="s1">self.check_destination(dest</span><span class="s0">, </span><span class="s1">url</span><span class="s0">, </span><span class="s1">rev_options</span><span class="s0">, </span><span class="s1">rev_display): 
            logger.info( 
                </span><span class="s2">'Cloning %s%s to %s'</span><span class="s0">, </span><span class="s1">url</span><span class="s0">, </span><span class="s1">rev_display</span><span class="s0">, </span><span class="s1">display_path(dest)</span><span class="s0">,</span><span class="s1"> 
            ) 
            self.run_command([</span><span class="s2">'clone'</span><span class="s0">, </span><span class="s2">'-q'</span><span class="s0">, </span><span class="s1">url</span><span class="s0">, </span><span class="s1">dest]) 
 
            </span><span class="s0">if </span><span class="s1">rev: 
                rev_options = self.check_rev_options(rev</span><span class="s0">, </span><span class="s1">dest</span><span class="s0">, </span><span class="s1">rev_options) 
                </span><span class="s3"># Only do a checkout if rev_options differs from HEAD</span><span class="s1"> 
                </span><span class="s0">if not </span><span class="s1">self.check_version(dest</span><span class="s0">, </span><span class="s1">rev_options): 
                    self.run_command( 
                        [</span><span class="s2">'checkout'</span><span class="s0">, </span><span class="s2">'-q'</span><span class="s1">] + rev_options</span><span class="s0">,</span><span class="s1"> 
                        cwd=dest</span><span class="s0">,</span><span class="s1"> 
                    ) 
            </span><span class="s3">#: repo may contain submodules</span><span class="s1"> 
            self.update_submodules(dest) 
 
    </span><span class="s0">def </span><span class="s1">get_url(self</span><span class="s0">, </span><span class="s1">location): 
        </span><span class="s5">&quot;&quot;&quot;Return URL of the first remote encountered.&quot;&quot;&quot;</span><span class="s1"> 
        remotes = self.run_command( 
            [</span><span class="s2">'config'</span><span class="s0">, </span><span class="s2">'--get-regexp'</span><span class="s0">, </span><span class="s2">'remote\..*\.url'</span><span class="s1">]</span><span class="s0">,</span><span class="s1"> 
            show_stdout=</span><span class="s0">False, </span><span class="s1">cwd=location) 
        remotes = remotes.splitlines() 
        found_remote = remotes[</span><span class="s4">0</span><span class="s1">] 
        </span><span class="s0">for </span><span class="s1">remote </span><span class="s0">in </span><span class="s1">remotes: 
            </span><span class="s0">if </span><span class="s1">remote.startswith(</span><span class="s2">'remote.origin.url '</span><span class="s1">): 
                found_remote = remote 
                </span><span class="s0">break</span><span class="s1"> 
        url = found_remote.split(</span><span class="s2">' '</span><span class="s1">)[</span><span class="s4">1</span><span class="s1">] 
        </span><span class="s0">return </span><span class="s1">url.strip() 
 
    </span><span class="s0">def </span><span class="s1">get_revision(self</span><span class="s0">, </span><span class="s1">location): 
        current_rev = self.run_command( 
            [</span><span class="s2">'rev-parse'</span><span class="s0">, </span><span class="s2">'HEAD'</span><span class="s1">]</span><span class="s0">, </span><span class="s1">show_stdout=</span><span class="s0">False, </span><span class="s1">cwd=location) 
        </span><span class="s0">return </span><span class="s1">current_rev.strip() 
 
    </span><span class="s0">def </span><span class="s1">get_full_refs(self</span><span class="s0">, </span><span class="s1">location): 
        </span><span class="s5">&quot;&quot;&quot;Yields tuples of (commit, ref) for branches and tags&quot;&quot;&quot;</span><span class="s1"> 
        output = self.run_command([</span><span class="s2">'show-ref'</span><span class="s1">]</span><span class="s0">,</span><span class="s1"> 
                                  show_stdout=</span><span class="s0">False, </span><span class="s1">cwd=location) 
        </span><span class="s0">for </span><span class="s1">line </span><span class="s0">in </span><span class="s1">output.strip().splitlines(): 
            commit</span><span class="s0">, </span><span class="s1">ref = line.split(</span><span class="s2">' '</span><span class="s0">, </span><span class="s4">1</span><span class="s1">) 
            </span><span class="s0">yield </span><span class="s1">commit.strip()</span><span class="s0">, </span><span class="s1">ref.strip() 
 
    </span><span class="s0">def </span><span class="s1">is_ref_remote(self</span><span class="s0">, </span><span class="s1">ref): 
        </span><span class="s0">return </span><span class="s1">ref.startswith(</span><span class="s2">'refs/remotes/'</span><span class="s1">) 
 
    </span><span class="s0">def </span><span class="s1">is_ref_branch(self</span><span class="s0">, </span><span class="s1">ref): 
        </span><span class="s0">return </span><span class="s1">ref.startswith(</span><span class="s2">'refs/heads/'</span><span class="s1">) 
 
    </span><span class="s0">def </span><span class="s1">is_ref_tag(self</span><span class="s0">, </span><span class="s1">ref): 
        </span><span class="s0">return </span><span class="s1">ref.startswith(</span><span class="s2">'refs/tags/'</span><span class="s1">) 
 
    </span><span class="s0">def </span><span class="s1">is_ref_commit(self</span><span class="s0">, </span><span class="s1">ref): 
        </span><span class="s5">&quot;&quot;&quot;A ref is a commit sha if it is not anything else&quot;&quot;&quot;</span><span class="s1"> 
        </span><span class="s0">return not </span><span class="s1">any(( 
            self.is_ref_remote(ref)</span><span class="s0">,</span><span class="s1"> 
            self.is_ref_branch(ref)</span><span class="s0">,</span><span class="s1"> 
            self.is_ref_tag(ref)</span><span class="s0">,</span><span class="s1"> 
        )) 
 
    </span><span class="s3"># Should deprecate `get_refs` since it's ambiguous</span><span class="s1"> 
    </span><span class="s0">def </span><span class="s1">get_refs(self</span><span class="s0">, </span><span class="s1">location): 
        </span><span class="s0">return </span><span class="s1">self.get_short_refs(location) 
 
    </span><span class="s0">def </span><span class="s1">get_short_refs(self</span><span class="s0">, </span><span class="s1">location): 
        </span><span class="s5">&quot;&quot;&quot;Return map of named refs (branches or tags) to commit hashes.&quot;&quot;&quot;</span><span class="s1"> 
        rv = {} 
        </span><span class="s0">for </span><span class="s1">commit</span><span class="s0">, </span><span class="s1">ref </span><span class="s0">in </span><span class="s1">self.get_full_refs(location): 
            ref_name = </span><span class="s0">None</span><span class="s1"> 
            </span><span class="s0">if </span><span class="s1">self.is_ref_remote(ref): 
                ref_name = ref[len(</span><span class="s2">'refs/remotes/'</span><span class="s1">):] 
            </span><span class="s0">elif </span><span class="s1">self.is_ref_branch(ref): 
                ref_name = ref[len(</span><span class="s2">'refs/heads/'</span><span class="s1">):] 
            </span><span class="s0">elif </span><span class="s1">self.is_ref_tag(ref): 
                ref_name = ref[len(</span><span class="s2">'refs/tags/'</span><span class="s1">):] 
            </span><span class="s0">if </span><span class="s1">ref_name </span><span class="s0">is not None</span><span class="s1">: 
                rv[ref_name] = commit 
        </span><span class="s0">return </span><span class="s1">rv 
 
    </span><span class="s0">def </span><span class="s1">_get_subdirectory(self</span><span class="s0">, </span><span class="s1">location): 
        </span><span class="s5">&quot;&quot;&quot;Return the relative path of setup.py to the git repo root.&quot;&quot;&quot;</span><span class="s1"> 
        </span><span class="s3"># find the repo root</span><span class="s1"> 
        git_dir = self.run_command([</span><span class="s2">'rev-parse'</span><span class="s0">, </span><span class="s2">'--git-dir'</span><span class="s1">]</span><span class="s0">,</span><span class="s1"> 
                                   show_stdout=</span><span class="s0">False, </span><span class="s1">cwd=location).strip() 
        </span><span class="s0">if not </span><span class="s1">os.path.isabs(git_dir): 
            git_dir = os.path.join(location</span><span class="s0">, </span><span class="s1">git_dir) 
        root_dir = os.path.join(git_dir</span><span class="s0">, </span><span class="s2">'..'</span><span class="s1">) 
        </span><span class="s3"># find setup.py</span><span class="s1"> 
        orig_location = location 
        </span><span class="s0">while not </span><span class="s1">os.path.exists(os.path.join(location</span><span class="s0">, </span><span class="s2">'setup.py'</span><span class="s1">)): 
            last_location = location 
            location = os.path.dirname(location) 
            </span><span class="s0">if </span><span class="s1">location == last_location: 
                </span><span class="s3"># We've traversed up to the root of the filesystem without</span><span class="s1"> 
                </span><span class="s3"># finding setup.py</span><span class="s1"> 
                logger.warning( 
                    </span><span class="s2">&quot;Could not find setup.py for directory %s (tried all &quot;</span><span class="s1"> 
                    </span><span class="s2">&quot;parent directories)&quot;</span><span class="s0">,</span><span class="s1"> 
                    orig_location</span><span class="s0">,</span><span class="s1"> 
                ) 
                </span><span class="s0">return None</span><span class="s1"> 
        </span><span class="s3"># relative path of setup.py to repo root</span><span class="s1"> 
        </span><span class="s0">if </span><span class="s1">samefile(root_dir</span><span class="s0">, </span><span class="s1">location): 
            </span><span class="s0">return None</span><span class="s1"> 
        </span><span class="s0">return </span><span class="s1">os.path.relpath(location</span><span class="s0">, </span><span class="s1">root_dir) 
 
    </span><span class="s0">def </span><span class="s1">get_src_requirement(self</span><span class="s0">, </span><span class="s1">dist</span><span class="s0">, </span><span class="s1">location): 
        repo = self.get_url(location) 
        </span><span class="s0">if not </span><span class="s1">repo.lower().startswith(</span><span class="s2">'git:'</span><span class="s1">): 
            repo = </span><span class="s2">'git+' </span><span class="s1">+ repo 
        egg_project_name = dist.egg_name().split(</span><span class="s2">'-'</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)[</span><span class="s4">0</span><span class="s1">] 
        </span><span class="s0">if not </span><span class="s1">repo: 
            </span><span class="s0">return None</span><span class="s1"> 
        current_rev = self.get_revision(location) 
        req = </span><span class="s2">'%s@%s#egg=%s' </span><span class="s1">% (repo</span><span class="s0">, </span><span class="s1">current_rev</span><span class="s0">, </span><span class="s1">egg_project_name) 
        subdirectory = self._get_subdirectory(location) 
        </span><span class="s0">if </span><span class="s1">subdirectory: 
            req += </span><span class="s2">'&amp;subdirectory=' </span><span class="s1">+ subdirectory 
        </span><span class="s0">return </span><span class="s1">req 
 
    </span><span class="s0">def </span><span class="s1">get_url_rev(self): 
        </span><span class="s5">&quot;&quot;&quot; 
        Prefixes stub URLs like 'user@hostname:user/repo.git' with 'ssh://'. 
        That's required because although they use SSH they sometimes doesn't 
        work with a ssh:// scheme (e.g. Github). But we need a scheme for 
        parsing. Hence we remove it again afterwards and return it as a stub. 
        &quot;&quot;&quot;</span><span class="s1"> 
        </span><span class="s0">if </span><span class="s2">'://' </span><span class="s0">not in </span><span class="s1">self.url: 
            </span><span class="s0">assert </span><span class="s2">'file:' </span><span class="s0">not in </span><span class="s1">self.url 
            self.url = self.url.replace(</span><span class="s2">'git+'</span><span class="s0">, </span><span class="s2">'git+ssh://'</span><span class="s1">) 
            url</span><span class="s0">, </span><span class="s1">rev = super(Git</span><span class="s0">, </span><span class="s1">self).get_url_rev() 
            url = url.replace(</span><span class="s2">'ssh://'</span><span class="s0">, </span><span class="s2">''</span><span class="s1">) 
        </span><span class="s0">else</span><span class="s1">: 
            url</span><span class="s0">, </span><span class="s1">rev = super(Git</span><span class="s0">, </span><span class="s1">self).get_url_rev() 
 
        </span><span class="s0">return </span><span class="s1">url</span><span class="s0">, </span><span class="s1">rev 
 
    </span><span class="s0">def </span><span class="s1">update_submodules(self</span><span class="s0">, </span><span class="s1">location): 
        </span><span class="s0">if not </span><span class="s1">os.path.exists(os.path.join(location</span><span class="s0">, </span><span class="s2">'.gitmodules'</span><span class="s1">)): 
            </span><span class="s0">return</span><span class="s1"> 
        self.run_command( 
            [</span><span class="s2">'submodule'</span><span class="s0">, </span><span class="s2">'update'</span><span class="s0">, </span><span class="s2">'--init'</span><span class="s0">, </span><span class="s2">'--recursive'</span><span class="s0">, </span><span class="s2">'-q'</span><span class="s1">]</span><span class="s0">,</span><span class="s1"> 
            cwd=location</span><span class="s0">,</span><span class="s1"> 
        ) 
 
    @classmethod 
    </span><span class="s0">def </span><span class="s1">controls_location(cls</span><span class="s0">, </span><span class="s1">location): 
        </span><span class="s0">if </span><span class="s1">super(Git</span><span class="s0">, </span><span class="s1">cls).controls_location(location): 
            </span><span class="s0">return True</span><span class="s1"> 
        </span><span class="s0">try</span><span class="s1">: 
            r = cls().run_command([</span><span class="s2">'rev-parse'</span><span class="s1">]</span><span class="s0">,</span><span class="s1"> 
                                  cwd=location</span><span class="s0">,</span><span class="s1"> 
                                  show_stdout=</span><span class="s0">False,</span><span class="s1"> 
                                  on_returncode=</span><span class="s2">'ignore'</span><span class="s1">) 
            </span><span class="s0">return not </span><span class="s1">r 
        </span><span class="s0">except </span><span class="s1">BadCommand: 
            logger.debug(</span><span class="s2">&quot;could not determine if %s is under git control &quot;</span><span class="s1"> 
                         </span><span class="s2">&quot;because git is not available&quot;</span><span class="s0">, </span><span class="s1">location) 
            </span><span class="s0">return False</span><span class="s1"> 
 
 
vcs.register(Git) 
</span></pre>
</body>
</html>