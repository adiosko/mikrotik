<html>
<head>
<title>bdist_egg.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.ln { color: #606366; font-weight: normal; font-style: normal; }
.s0 { color: rgb(98,151,85); font-style: italic; }
.s1 { color: rgb(169,183,198); }
.s2 { color: rgb(204,120,50); }
.s3 { color: rgb(128,128,128); }
.s4 { color: rgb(106,135,89); }
.s5 { color: rgb(104,151,187); }
</style>
</head>
<BODY BGCOLOR="#2b2b2b">
<TABLE CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<TR><TD><CENTER>
<FONT FACE="Arial, Helvetica" COLOR="#000000">
bdist_egg.py</FONT>
</center></TD></TR></TABLE>
<pre>
<span class="s0">&quot;&quot;&quot;setuptools.command.bdist_egg 
 
Build .egg distributions&quot;&quot;&quot;</span><span class="s1"> 
 
</span><span class="s2">from </span><span class="s1">distutils.errors </span><span class="s2">import </span><span class="s1">DistutilsSetupError 
</span><span class="s2">from </span><span class="s1">distutils.dir_util </span><span class="s2">import </span><span class="s1">remove_tree</span><span class="s2">, </span><span class="s1">mkpath 
</span><span class="s2">from </span><span class="s1">distutils </span><span class="s2">import </span><span class="s1">log 
</span><span class="s2">from </span><span class="s1">types </span><span class="s2">import </span><span class="s1">CodeType 
</span><span class="s2">import </span><span class="s1">sys 
</span><span class="s2">import </span><span class="s1">os 
</span><span class="s2">import </span><span class="s1">re 
</span><span class="s2">import </span><span class="s1">textwrap 
</span><span class="s2">import </span><span class="s1">marshal 
 
</span><span class="s2">from </span><span class="s1">setuptools.extern </span><span class="s2">import </span><span class="s1">six 
 
</span><span class="s2">from </span><span class="s1">pkg_resources </span><span class="s2">import </span><span class="s1">get_build_platform</span><span class="s2">, </span><span class="s1">Distribution</span><span class="s2">, </span><span class="s1">ensure_directory 
</span><span class="s2">from </span><span class="s1">pkg_resources </span><span class="s2">import </span><span class="s1">EntryPoint 
</span><span class="s2">from </span><span class="s1">setuptools.extension </span><span class="s2">import </span><span class="s1">Library 
</span><span class="s2">from </span><span class="s1">setuptools </span><span class="s2">import </span><span class="s1">Command 
 
</span><span class="s2">try</span><span class="s1">: 
    </span><span class="s3"># Python 2.7 or &gt;=3.2</span><span class="s1"> 
    </span><span class="s2">from </span><span class="s1">sysconfig </span><span class="s2">import </span><span class="s1">get_path</span><span class="s2">, </span><span class="s1">get_python_version 
 
    </span><span class="s2">def </span><span class="s1">_get_purelib(): 
        </span><span class="s2">return </span><span class="s1">get_path(</span><span class="s4">&quot;purelib&quot;</span><span class="s1">) 
</span><span class="s2">except </span><span class="s1">ImportError: 
    </span><span class="s2">from </span><span class="s1">distutils.sysconfig </span><span class="s2">import </span><span class="s1">get_python_lib</span><span class="s2">, </span><span class="s1">get_python_version 
 
    </span><span class="s2">def </span><span class="s1">_get_purelib(): 
        </span><span class="s2">return </span><span class="s1">get_python_lib(</span><span class="s2">False</span><span class="s1">) 
 
 
</span><span class="s2">def </span><span class="s1">strip_module(filename): 
    </span><span class="s2">if </span><span class="s4">'.' </span><span class="s2">in </span><span class="s1">filename: 
        filename = os.path.splitext(filename)[</span><span class="s5">0</span><span class="s1">] 
    </span><span class="s2">if </span><span class="s1">filename.endswith(</span><span class="s4">'module'</span><span class="s1">): 
        filename = filename[:-</span><span class="s5">6</span><span class="s1">] 
    </span><span class="s2">return </span><span class="s1">filename 
 
 
</span><span class="s2">def </span><span class="s1">sorted_walk(dir): 
    </span><span class="s0">&quot;&quot;&quot;Do os.walk in a reproducible way, 
    independent of indeterministic filesystem readdir order 
    &quot;&quot;&quot;</span><span class="s1"> 
    </span><span class="s2">for </span><span class="s1">base</span><span class="s2">, </span><span class="s1">dirs</span><span class="s2">, </span><span class="s1">files </span><span class="s2">in </span><span class="s1">os.walk(dir): 
        dirs.sort() 
        files.sort() 
        </span><span class="s2">yield </span><span class="s1">base</span><span class="s2">, </span><span class="s1">dirs</span><span class="s2">, </span><span class="s1">files 
 
 
</span><span class="s2">def </span><span class="s1">write_stub(resource</span><span class="s2">, </span><span class="s1">pyfile): 
    _stub_template = textwrap.dedent(</span><span class="s4">&quot;&quot;&quot; 
        def __bootstrap__(): 
            global __bootstrap__, __loader__, __file__ 
            import sys, pkg_resources, imp 
            __file__ = pkg_resources.resource_filename(__name__, %r) 
            __loader__ = None; del __bootstrap__, __loader__ 
            imp.load_dynamic(__name__,__file__) 
        __bootstrap__() 
        &quot;&quot;&quot;</span><span class="s1">).lstrip() 
    </span><span class="s2">with </span><span class="s1">open(pyfile</span><span class="s2">, </span><span class="s4">'w'</span><span class="s1">) </span><span class="s2">as </span><span class="s1">f: 
        f.write(_stub_template % resource) 
 
 
</span><span class="s2">class </span><span class="s1">bdist_egg(Command): 
    description = </span><span class="s4">&quot;create an </span><span class="s2">\&quot;</span><span class="s4">egg</span><span class="s2">\&quot;</span><span class="s4"> distribution&quot;</span><span class="s1"> 
 
    user_options = [ 
        (</span><span class="s4">'bdist-dir='</span><span class="s2">, </span><span class="s4">'b'</span><span class="s2">,</span><span class="s1"> 
         </span><span class="s4">&quot;temporary directory for creating the distribution&quot;</span><span class="s1">)</span><span class="s2">,</span><span class="s1"> 
        (</span><span class="s4">'plat-name='</span><span class="s2">, </span><span class="s4">'p'</span><span class="s2">, </span><span class="s4">&quot;platform name to embed in generated filenames &quot;</span><span class="s1"> 
                            </span><span class="s4">&quot;(default: %s)&quot; </span><span class="s1">% get_build_platform())</span><span class="s2">,</span><span class="s1"> 
        (</span><span class="s4">'exclude-source-files'</span><span class="s2">, None,</span><span class="s1"> 
         </span><span class="s4">&quot;remove all .py files from the generated egg&quot;</span><span class="s1">)</span><span class="s2">,</span><span class="s1"> 
        (</span><span class="s4">'keep-temp'</span><span class="s2">, </span><span class="s4">'k'</span><span class="s2">,</span><span class="s1"> 
         </span><span class="s4">&quot;keep the pseudo-installation tree around after &quot; </span><span class="s1">+ 
         </span><span class="s4">&quot;creating the distribution archive&quot;</span><span class="s1">)</span><span class="s2">,</span><span class="s1"> 
        (</span><span class="s4">'dist-dir='</span><span class="s2">, </span><span class="s4">'d'</span><span class="s2">,</span><span class="s1"> 
         </span><span class="s4">&quot;directory to put final built distributions in&quot;</span><span class="s1">)</span><span class="s2">,</span><span class="s1"> 
        (</span><span class="s4">'skip-build'</span><span class="s2">, None,</span><span class="s1"> 
         </span><span class="s4">&quot;skip rebuilding everything (for testing/debugging)&quot;</span><span class="s1">)</span><span class="s2">,</span><span class="s1"> 
    ] 
 
    boolean_options = [ 
        </span><span class="s4">'keep-temp'</span><span class="s2">, </span><span class="s4">'skip-build'</span><span class="s2">, </span><span class="s4">'exclude-source-files'</span><span class="s1"> 
    ] 
 
    </span><span class="s2">def </span><span class="s1">initialize_options(self): 
        self.bdist_dir = </span><span class="s2">None</span><span class="s1"> 
        self.plat_name = </span><span class="s2">None</span><span class="s1"> 
        self.keep_temp = </span><span class="s5">0</span><span class="s1"> 
        self.dist_dir = </span><span class="s2">None</span><span class="s1"> 
        self.skip_build = </span><span class="s5">0</span><span class="s1"> 
        self.egg_output = </span><span class="s2">None</span><span class="s1"> 
        self.exclude_source_files = </span><span class="s2">None</span><span class="s1"> 
 
    </span><span class="s2">def </span><span class="s1">finalize_options(self): 
        ei_cmd = self.ei_cmd = self.get_finalized_command(</span><span class="s4">&quot;egg_info&quot;</span><span class="s1">) 
        self.egg_info = ei_cmd.egg_info 
 
        </span><span class="s2">if </span><span class="s1">self.bdist_dir </span><span class="s2">is None</span><span class="s1">: 
            bdist_base = self.get_finalized_command(</span><span class="s4">'bdist'</span><span class="s1">).bdist_base 
            self.bdist_dir = os.path.join(bdist_base</span><span class="s2">, </span><span class="s4">'egg'</span><span class="s1">) 
 
        </span><span class="s2">if </span><span class="s1">self.plat_name </span><span class="s2">is None</span><span class="s1">: 
            self.plat_name = get_build_platform() 
 
        self.set_undefined_options(</span><span class="s4">'bdist'</span><span class="s2">, </span><span class="s1">(</span><span class="s4">'dist_dir'</span><span class="s2">, </span><span class="s4">'dist_dir'</span><span class="s1">)) 
 
        </span><span class="s2">if </span><span class="s1">self.egg_output </span><span class="s2">is None</span><span class="s1">: 
 
            </span><span class="s3"># Compute filename of the output egg</span><span class="s1"> 
            basename = Distribution( 
                </span><span class="s2">None, None, </span><span class="s1">ei_cmd.egg_name</span><span class="s2">, </span><span class="s1">ei_cmd.egg_version</span><span class="s2">,</span><span class="s1"> 
                get_python_version()</span><span class="s2">,</span><span class="s1"> 
                self.distribution.has_ext_modules() </span><span class="s2">and </span><span class="s1">self.plat_name 
            ).egg_name() 
 
            self.egg_output = os.path.join(self.dist_dir</span><span class="s2">, </span><span class="s1">basename + </span><span class="s4">'.egg'</span><span class="s1">) 
 
    </span><span class="s2">def </span><span class="s1">do_install_data(self): 
        </span><span class="s3"># Hack for packages that install data to install's --install-lib</span><span class="s1"> 
        self.get_finalized_command(</span><span class="s4">'install'</span><span class="s1">).install_lib = self.bdist_dir 
 
        site_packages = os.path.normcase(os.path.realpath(_get_purelib())) 
        old</span><span class="s2">, </span><span class="s1">self.distribution.data_files = self.distribution.data_files</span><span class="s2">, </span><span class="s1">[] 
 
        </span><span class="s2">for </span><span class="s1">item </span><span class="s2">in </span><span class="s1">old: 
            </span><span class="s2">if </span><span class="s1">isinstance(item</span><span class="s2">, </span><span class="s1">tuple) </span><span class="s2">and </span><span class="s1">len(item) == </span><span class="s5">2</span><span class="s1">: 
                </span><span class="s2">if </span><span class="s1">os.path.isabs(item[</span><span class="s5">0</span><span class="s1">]): 
                    realpath = os.path.realpath(item[</span><span class="s5">0</span><span class="s1">]) 
                    normalized = os.path.normcase(realpath) 
                    </span><span class="s2">if </span><span class="s1">normalized == site_packages </span><span class="s2">or </span><span class="s1">normalized.startswith( 
                        site_packages + os.sep 
                    ): 
                        item = realpath[len(site_packages) + </span><span class="s5">1</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">item[</span><span class="s5">1</span><span class="s1">] 
                        </span><span class="s3"># XXX else: raise ???</span><span class="s1"> 
            self.distribution.data_files.append(item) 
 
        </span><span class="s2">try</span><span class="s1">: 
            log.info(</span><span class="s4">&quot;installing package data to %s&quot;</span><span class="s2">, </span><span class="s1">self.bdist_dir) 
            self.call_command(</span><span class="s4">'install_data'</span><span class="s2">, </span><span class="s1">force=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">root=</span><span class="s2">None</span><span class="s1">) 
        </span><span class="s2">finally</span><span class="s1">: 
            self.distribution.data_files = old 
 
    </span><span class="s2">def </span><span class="s1">get_outputs(self): 
        </span><span class="s2">return </span><span class="s1">[self.egg_output] 
 
    </span><span class="s2">def </span><span class="s1">call_command(self</span><span class="s2">, </span><span class="s1">cmdname</span><span class="s2">, </span><span class="s1">**kw): 
        </span><span class="s0">&quot;&quot;&quot;Invoke reinitialized command `cmdname` with keyword args&quot;&quot;&quot;</span><span class="s1"> 
        </span><span class="s2">for </span><span class="s1">dirname </span><span class="s2">in </span><span class="s1">INSTALL_DIRECTORY_ATTRS: 
            kw.setdefault(dirname</span><span class="s2">, </span><span class="s1">self.bdist_dir) 
        kw.setdefault(</span><span class="s4">'skip_build'</span><span class="s2">, </span><span class="s1">self.skip_build) 
        kw.setdefault(</span><span class="s4">'dry_run'</span><span class="s2">, </span><span class="s1">self.dry_run) 
        cmd = self.reinitialize_command(cmdname</span><span class="s2">, </span><span class="s1">**kw) 
        self.run_command(cmdname) 
        </span><span class="s2">return </span><span class="s1">cmd 
 
    </span><span class="s2">def </span><span class="s1">run(self): 
        </span><span class="s3"># Generate metadata first</span><span class="s1"> 
        self.run_command(</span><span class="s4">&quot;egg_info&quot;</span><span class="s1">) 
        </span><span class="s3"># We run install_lib before install_data, because some data hacks</span><span class="s1"> 
        </span><span class="s3"># pull their data path from the install_lib command.</span><span class="s1"> 
        log.info(</span><span class="s4">&quot;installing library code to %s&quot;</span><span class="s2">, </span><span class="s1">self.bdist_dir) 
        instcmd = self.get_finalized_command(</span><span class="s4">'install'</span><span class="s1">) 
        old_root = instcmd.root 
        instcmd.root = </span><span class="s2">None</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">self.distribution.has_c_libraries() </span><span class="s2">and not </span><span class="s1">self.skip_build: 
            self.run_command(</span><span class="s4">'build_clib'</span><span class="s1">) 
        cmd = self.call_command(</span><span class="s4">'install_lib'</span><span class="s2">, </span><span class="s1">warn_dir=</span><span class="s5">0</span><span class="s1">) 
        instcmd.root = old_root 
 
        all_outputs</span><span class="s2">, </span><span class="s1">ext_outputs = self.get_ext_outputs() 
        self.stubs = [] 
        to_compile = [] 
        </span><span class="s2">for </span><span class="s1">(p</span><span class="s2">, </span><span class="s1">ext_name) </span><span class="s2">in </span><span class="s1">enumerate(ext_outputs): 
            filename</span><span class="s2">, </span><span class="s1">ext = os.path.splitext(ext_name) 
            pyfile = os.path.join(self.bdist_dir</span><span class="s2">, </span><span class="s1">strip_module(filename) + 
                                  </span><span class="s4">'.py'</span><span class="s1">) 
            self.stubs.append(pyfile) 
            log.info(</span><span class="s4">&quot;creating stub loader for %s&quot;</span><span class="s2">, </span><span class="s1">ext_name) 
            </span><span class="s2">if not </span><span class="s1">self.dry_run: 
                write_stub(os.path.basename(ext_name)</span><span class="s2">, </span><span class="s1">pyfile) 
            to_compile.append(pyfile) 
            ext_outputs[p] = ext_name.replace(os.sep</span><span class="s2">, </span><span class="s4">'/'</span><span class="s1">) 
 
        </span><span class="s2">if </span><span class="s1">to_compile: 
            cmd.byte_compile(to_compile) 
        </span><span class="s2">if </span><span class="s1">self.distribution.data_files: 
            self.do_install_data() 
 
        </span><span class="s3"># Make the EGG-INFO directory</span><span class="s1"> 
        archive_root = self.bdist_dir 
        egg_info = os.path.join(archive_root</span><span class="s2">, </span><span class="s4">'EGG-INFO'</span><span class="s1">) 
        self.mkpath(egg_info) 
        </span><span class="s2">if </span><span class="s1">self.distribution.scripts: 
            script_dir = os.path.join(egg_info</span><span class="s2">, </span><span class="s4">'scripts'</span><span class="s1">) 
            log.info(</span><span class="s4">&quot;installing scripts to %s&quot;</span><span class="s2">, </span><span class="s1">script_dir) 
            self.call_command(</span><span class="s4">'install_scripts'</span><span class="s2">, </span><span class="s1">install_dir=script_dir</span><span class="s2">,</span><span class="s1"> 
                              no_ep=</span><span class="s5">1</span><span class="s1">) 
 
        self.copy_metadata_to(egg_info) 
        native_libs = os.path.join(egg_info</span><span class="s2">, </span><span class="s4">&quot;native_libs.txt&quot;</span><span class="s1">) 
        </span><span class="s2">if </span><span class="s1">all_outputs: 
            log.info(</span><span class="s4">&quot;writing %s&quot;</span><span class="s2">, </span><span class="s1">native_libs) 
            </span><span class="s2">if not </span><span class="s1">self.dry_run: 
                ensure_directory(native_libs) 
                libs_file = open(native_libs</span><span class="s2">, </span><span class="s4">'wt'</span><span class="s1">) 
                libs_file.write(</span><span class="s4">'</span><span class="s2">\n</span><span class="s4">'</span><span class="s1">.join(all_outputs)) 
                libs_file.write(</span><span class="s4">'</span><span class="s2">\n</span><span class="s4">'</span><span class="s1">) 
                libs_file.close() 
        </span><span class="s2">elif </span><span class="s1">os.path.isfile(native_libs): 
            log.info(</span><span class="s4">&quot;removing %s&quot;</span><span class="s2">, </span><span class="s1">native_libs) 
            </span><span class="s2">if not </span><span class="s1">self.dry_run: 
                os.unlink(native_libs) 
 
        write_safety_flag( 
            os.path.join(archive_root</span><span class="s2">, </span><span class="s4">'EGG-INFO'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">self.zip_safe() 
        ) 
 
        </span><span class="s2">if </span><span class="s1">os.path.exists(os.path.join(self.egg_info</span><span class="s2">, </span><span class="s4">'depends.txt'</span><span class="s1">)): 
            log.warn( 
                </span><span class="s4">&quot;WARNING: 'depends.txt' will not be used by setuptools 0.6!</span><span class="s2">\n</span><span class="s4">&quot;</span><span class="s1"> 
                </span><span class="s4">&quot;Use the install_requires/extras_require setup() args instead.&quot;</span><span class="s1"> 
            ) 
 
        </span><span class="s2">if </span><span class="s1">self.exclude_source_files: 
            self.zap_pyfiles() 
 
        </span><span class="s3"># Make the archive</span><span class="s1"> 
        make_zipfile(self.egg_output</span><span class="s2">, </span><span class="s1">archive_root</span><span class="s2">, </span><span class="s1">verbose=self.verbose</span><span class="s2">,</span><span class="s1"> 
                     dry_run=self.dry_run</span><span class="s2">, </span><span class="s1">mode=self.gen_header()) 
        </span><span class="s2">if not </span><span class="s1">self.keep_temp: 
            remove_tree(self.bdist_dir</span><span class="s2">, </span><span class="s1">dry_run=self.dry_run) 
 
        </span><span class="s3"># Add to 'Distribution.dist_files' so that the &quot;upload&quot; command works</span><span class="s1"> 
        getattr(self.distribution</span><span class="s2">, </span><span class="s4">'dist_files'</span><span class="s2">, </span><span class="s1">[]).append( 
            (</span><span class="s4">'bdist_egg'</span><span class="s2">, </span><span class="s1">get_python_version()</span><span class="s2">, </span><span class="s1">self.egg_output)) 
 
    </span><span class="s2">def </span><span class="s1">zap_pyfiles(self): 
        log.info(</span><span class="s4">&quot;Removing .py files from temporary directory&quot;</span><span class="s1">) 
        </span><span class="s2">for </span><span class="s1">base</span><span class="s2">, </span><span class="s1">dirs</span><span class="s2">, </span><span class="s1">files </span><span class="s2">in </span><span class="s1">walk_egg(self.bdist_dir): 
            </span><span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">files: 
                path = os.path.join(base</span><span class="s2">, </span><span class="s1">name) 
 
                </span><span class="s2">if </span><span class="s1">name.endswith(</span><span class="s4">'.py'</span><span class="s1">): 
                    log.debug(</span><span class="s4">&quot;Deleting %s&quot;</span><span class="s2">, </span><span class="s1">path) 
                    os.unlink(path) 
 
                </span><span class="s2">if </span><span class="s1">base.endswith(</span><span class="s4">'__pycache__'</span><span class="s1">): 
                    path_old = path 
 
                    pattern = </span><span class="s4">r'(?P&lt;name&gt;.+)\.(?P&lt;magic&gt;[^.]+)\.pyc'</span><span class="s1"> 
                    m = re.match(pattern</span><span class="s2">, </span><span class="s1">name) 
                    path_new = os.path.join( 
                        base</span><span class="s2">, </span><span class="s1">os.pardir</span><span class="s2">, </span><span class="s1">m.group(</span><span class="s4">'name'</span><span class="s1">) + </span><span class="s4">'.pyc'</span><span class="s1">) 
                    log.info( 
                        </span><span class="s4">&quot;Renaming file from [%s] to [%s]&quot;</span><span class="s1"> 
                        % (path_old</span><span class="s2">, </span><span class="s1">path_new)) 
                    </span><span class="s2">try</span><span class="s1">: 
                        os.remove(path_new) 
                    </span><span class="s2">except </span><span class="s1">OSError: 
                        </span><span class="s2">pass</span><span class="s1"> 
                    os.rename(path_old</span><span class="s2">, </span><span class="s1">path_new) 
 
    </span><span class="s2">def </span><span class="s1">zip_safe(self): 
        safe = getattr(self.distribution</span><span class="s2">, </span><span class="s4">'zip_safe'</span><span class="s2">, None</span><span class="s1">) 
        </span><span class="s2">if </span><span class="s1">safe </span><span class="s2">is not None</span><span class="s1">: 
            </span><span class="s2">return </span><span class="s1">safe 
        log.warn(</span><span class="s4">&quot;zip_safe flag not set; analyzing archive contents...&quot;</span><span class="s1">) 
        </span><span class="s2">return </span><span class="s1">analyze_egg(self.bdist_dir</span><span class="s2">, </span><span class="s1">self.stubs) 
 
    </span><span class="s2">def </span><span class="s1">gen_header(self): 
        epm = EntryPoint.parse_map(self.distribution.entry_points </span><span class="s2">or </span><span class="s4">''</span><span class="s1">) 
        ep = epm.get(</span><span class="s4">'setuptools.installation'</span><span class="s2">, </span><span class="s1">{}).get(</span><span class="s4">'eggsecutable'</span><span class="s1">) 
        </span><span class="s2">if </span><span class="s1">ep </span><span class="s2">is None</span><span class="s1">: 
            </span><span class="s2">return </span><span class="s4">'w'  </span><span class="s3"># not an eggsecutable, do it the usual way.</span><span class="s1"> 
 
        </span><span class="s2">if not </span><span class="s1">ep.attrs </span><span class="s2">or </span><span class="s1">ep.extras: 
            </span><span class="s2">raise </span><span class="s1">DistutilsSetupError( 
                </span><span class="s4">&quot;eggsecutable entry point (%r) cannot have 'extras' &quot;</span><span class="s1"> 
                </span><span class="s4">&quot;or refer to a module&quot; </span><span class="s1">% (ep</span><span class="s2">,</span><span class="s1">) 
            ) 
 
        pyver = sys.version[:</span><span class="s5">3</span><span class="s1">] 
        pkg = ep.module_name 
        full = </span><span class="s4">'.'</span><span class="s1">.join(ep.attrs) 
        base = ep.attrs[</span><span class="s5">0</span><span class="s1">] 
        basename = os.path.basename(self.egg_output) 
 
        header = ( 
            </span><span class="s4">&quot;#!/bin/sh</span><span class="s2">\n</span><span class="s4">&quot;</span><span class="s1"> 
            </span><span class="s4">'if [ `basename $0` = &quot;%(basename)s&quot; ]</span><span class="s2">\n</span><span class="s4">'</span><span class="s1"> 
            </span><span class="s4">'then exec python%(pyver)s -c &quot;'</span><span class="s1"> 
            </span><span class="s4">&quot;import sys, os; sys.path.insert(0, os.path.abspath('$0')); &quot;</span><span class="s1"> 
            </span><span class="s4">&quot;from %(pkg)s import %(base)s; sys.exit(%(full)s())&quot;</span><span class="s1"> 
            </span><span class="s4">'&quot; &quot;$@&quot;</span><span class="s2">\n</span><span class="s4">'</span><span class="s1"> 
            </span><span class="s4">'else</span><span class="s2">\n</span><span class="s4">'</span><span class="s1"> 
            </span><span class="s4">'  echo $0 is not the correct name for this egg file.</span><span class="s2">\n</span><span class="s4">'</span><span class="s1"> 
            </span><span class="s4">'  echo Please rename it back to %(basename)s and try again.</span><span class="s2">\n</span><span class="s4">'</span><span class="s1"> 
            </span><span class="s4">'  exec false</span><span class="s2">\n</span><span class="s4">'</span><span class="s1"> 
            </span><span class="s4">'fi</span><span class="s2">\n</span><span class="s4">'</span><span class="s1"> 
        ) % locals() 
 
        </span><span class="s2">if not </span><span class="s1">self.dry_run: 
            mkpath(os.path.dirname(self.egg_output)</span><span class="s2">, </span><span class="s1">dry_run=self.dry_run) 
            f = open(self.egg_output</span><span class="s2">, </span><span class="s4">'w'</span><span class="s1">) 
            f.write(header) 
            f.close() 
        </span><span class="s2">return </span><span class="s4">'a'</span><span class="s1"> 
 
    </span><span class="s2">def </span><span class="s1">copy_metadata_to(self</span><span class="s2">, </span><span class="s1">target_dir): 
        </span><span class="s0">&quot;Copy metadata (egg info) to the target_dir&quot;</span><span class="s1"> 
        </span><span class="s3"># normalize the path (so that a forward-slash in egg_info will</span><span class="s1"> 
        </span><span class="s3"># match using startswith below)</span><span class="s1"> 
        norm_egg_info = os.path.normpath(self.egg_info) 
        prefix = os.path.join(norm_egg_info</span><span class="s2">, </span><span class="s4">''</span><span class="s1">) 
        </span><span class="s2">for </span><span class="s1">path </span><span class="s2">in </span><span class="s1">self.ei_cmd.filelist.files: 
            </span><span class="s2">if </span><span class="s1">path.startswith(prefix): 
                target = os.path.join(target_dir</span><span class="s2">, </span><span class="s1">path[len(prefix):]) 
                ensure_directory(target) 
                self.copy_file(path</span><span class="s2">, </span><span class="s1">target) 
 
    </span><span class="s2">def </span><span class="s1">get_ext_outputs(self): 
        </span><span class="s0">&quot;&quot;&quot;Get a list of relative paths to C extensions in the output distro&quot;&quot;&quot;</span><span class="s1"> 
 
        all_outputs = [] 
        ext_outputs = [] 
 
        paths = {self.bdist_dir: </span><span class="s4">''</span><span class="s1">} 
        </span><span class="s2">for </span><span class="s1">base</span><span class="s2">, </span><span class="s1">dirs</span><span class="s2">, </span><span class="s1">files </span><span class="s2">in </span><span class="s1">sorted_walk(self.bdist_dir): 
            </span><span class="s2">for </span><span class="s1">filename </span><span class="s2">in </span><span class="s1">files: 
                </span><span class="s2">if </span><span class="s1">os.path.splitext(filename)[</span><span class="s5">1</span><span class="s1">].lower() </span><span class="s2">in </span><span class="s1">NATIVE_EXTENSIONS: 
                    all_outputs.append(paths[base] + filename) 
            </span><span class="s2">for </span><span class="s1">filename </span><span class="s2">in </span><span class="s1">dirs: 
                paths[os.path.join(base</span><span class="s2">, </span><span class="s1">filename)] = (paths[base] + 
                                                       filename + </span><span class="s4">'/'</span><span class="s1">) 
 
        </span><span class="s2">if </span><span class="s1">self.distribution.has_ext_modules(): 
            build_cmd = self.get_finalized_command(</span><span class="s4">'build_ext'</span><span class="s1">) 
            </span><span class="s2">for </span><span class="s1">ext </span><span class="s2">in </span><span class="s1">build_cmd.extensions: 
                </span><span class="s2">if </span><span class="s1">isinstance(ext</span><span class="s2">, </span><span class="s1">Library): 
                    </span><span class="s2">continue</span><span class="s1"> 
                fullname = build_cmd.get_ext_fullname(ext.name) 
                filename = build_cmd.get_ext_filename(fullname) 
                </span><span class="s2">if not </span><span class="s1">os.path.basename(filename).startswith(</span><span class="s4">'dl-'</span><span class="s1">): 
                    </span><span class="s2">if </span><span class="s1">os.path.exists(os.path.join(self.bdist_dir</span><span class="s2">, </span><span class="s1">filename)): 
                        ext_outputs.append(filename) 
 
        </span><span class="s2">return </span><span class="s1">all_outputs</span><span class="s2">, </span><span class="s1">ext_outputs 
 
 
NATIVE_EXTENSIONS = dict.fromkeys(</span><span class="s4">'.dll .so .dylib .pyd'</span><span class="s1">.split()) 
 
 
</span><span class="s2">def </span><span class="s1">walk_egg(egg_dir): 
    </span><span class="s0">&quot;&quot;&quot;Walk an unpacked egg's contents, skipping the metadata directory&quot;&quot;&quot;</span><span class="s1"> 
    walker = sorted_walk(egg_dir) 
    base</span><span class="s2">, </span><span class="s1">dirs</span><span class="s2">, </span><span class="s1">files = next(walker) 
    </span><span class="s2">if </span><span class="s4">'EGG-INFO' </span><span class="s2">in </span><span class="s1">dirs: 
        dirs.remove(</span><span class="s4">'EGG-INFO'</span><span class="s1">) 
    </span><span class="s2">yield </span><span class="s1">base</span><span class="s2">, </span><span class="s1">dirs</span><span class="s2">, </span><span class="s1">files 
    </span><span class="s2">for </span><span class="s1">bdf </span><span class="s2">in </span><span class="s1">walker: 
        </span><span class="s2">yield </span><span class="s1">bdf 
 
 
</span><span class="s2">def </span><span class="s1">analyze_egg(egg_dir</span><span class="s2">, </span><span class="s1">stubs): 
    </span><span class="s3"># check for existing flag in EGG-INFO</span><span class="s1"> 
    </span><span class="s2">for </span><span class="s1">flag</span><span class="s2">, </span><span class="s1">fn </span><span class="s2">in </span><span class="s1">safety_flags.items(): 
        </span><span class="s2">if </span><span class="s1">os.path.exists(os.path.join(egg_dir</span><span class="s2">, </span><span class="s4">'EGG-INFO'</span><span class="s2">, </span><span class="s1">fn)): 
            </span><span class="s2">return </span><span class="s1">flag 
    </span><span class="s2">if not </span><span class="s1">can_scan(): 
        </span><span class="s2">return False</span><span class="s1"> 
    safe = </span><span class="s2">True</span><span class="s1"> 
    </span><span class="s2">for </span><span class="s1">base</span><span class="s2">, </span><span class="s1">dirs</span><span class="s2">, </span><span class="s1">files </span><span class="s2">in </span><span class="s1">walk_egg(egg_dir): 
        </span><span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">files: 
            </span><span class="s2">if </span><span class="s1">name.endswith(</span><span class="s4">'.py'</span><span class="s1">) </span><span class="s2">or </span><span class="s1">name.endswith(</span><span class="s4">'.pyw'</span><span class="s1">): 
                </span><span class="s2">continue</span><span class="s1"> 
            </span><span class="s2">elif </span><span class="s1">name.endswith(</span><span class="s4">'.pyc'</span><span class="s1">) </span><span class="s2">or </span><span class="s1">name.endswith(</span><span class="s4">'.pyo'</span><span class="s1">): 
                </span><span class="s3"># always scan, even if we already know we're not safe</span><span class="s1"> 
                safe = scan_module(egg_dir</span><span class="s2">, </span><span class="s1">base</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">stubs) </span><span class="s2">and </span><span class="s1">safe 
    </span><span class="s2">return </span><span class="s1">safe 
 
 
</span><span class="s2">def </span><span class="s1">write_safety_flag(egg_dir</span><span class="s2">, </span><span class="s1">safe): 
    </span><span class="s3"># Write or remove zip safety flag file(s)</span><span class="s1"> 
    </span><span class="s2">for </span><span class="s1">flag</span><span class="s2">, </span><span class="s1">fn </span><span class="s2">in </span><span class="s1">safety_flags.items(): 
        fn = os.path.join(egg_dir</span><span class="s2">, </span><span class="s1">fn) 
        </span><span class="s2">if </span><span class="s1">os.path.exists(fn): 
            </span><span class="s2">if </span><span class="s1">safe </span><span class="s2">is None or </span><span class="s1">bool(safe) != flag: 
                os.unlink(fn) 
        </span><span class="s2">elif </span><span class="s1">safe </span><span class="s2">is not None and </span><span class="s1">bool(safe) == flag: 
            f = open(fn</span><span class="s2">, </span><span class="s4">'wt'</span><span class="s1">) 
            f.write(</span><span class="s4">'</span><span class="s2">\n</span><span class="s4">'</span><span class="s1">) 
            f.close() 
 
 
safety_flags = { 
    </span><span class="s2">True</span><span class="s1">: </span><span class="s4">'zip-safe'</span><span class="s2">,</span><span class="s1"> 
    </span><span class="s2">False</span><span class="s1">: </span><span class="s4">'not-zip-safe'</span><span class="s2">,</span><span class="s1"> 
} 
 
 
</span><span class="s2">def </span><span class="s1">scan_module(egg_dir</span><span class="s2">, </span><span class="s1">base</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">stubs): 
    </span><span class="s0">&quot;&quot;&quot;Check whether module possibly uses unsafe-for-zipfile stuff&quot;&quot;&quot;</span><span class="s1"> 
 
    filename = os.path.join(base</span><span class="s2">, </span><span class="s1">name) 
    </span><span class="s2">if </span><span class="s1">filename[:-</span><span class="s5">1</span><span class="s1">] </span><span class="s2">in </span><span class="s1">stubs: 
        </span><span class="s2">return True  </span><span class="s3"># Extension module</span><span class="s1"> 
    pkg = base[len(egg_dir) + </span><span class="s5">1</span><span class="s1">:].replace(os.sep</span><span class="s2">, </span><span class="s4">'.'</span><span class="s1">) 
    module = pkg + (pkg </span><span class="s2">and </span><span class="s4">'.' </span><span class="s2">or </span><span class="s4">''</span><span class="s1">) + os.path.splitext(name)[</span><span class="s5">0</span><span class="s1">] 
    </span><span class="s2">if </span><span class="s1">sys.version_info &lt; (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">3</span><span class="s1">): 
        skip = </span><span class="s5">8  </span><span class="s3"># skip magic &amp; date</span><span class="s1"> 
    </span><span class="s2">elif </span><span class="s1">sys.version_info &lt; (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">7</span><span class="s1">): 
        skip = </span><span class="s5">12  </span><span class="s3"># skip magic &amp; date &amp; file size</span><span class="s1"> 
    </span><span class="s2">else</span><span class="s1">: 
        skip = </span><span class="s5">16  </span><span class="s3"># skip magic &amp; reserved? &amp; date &amp; file size</span><span class="s1"> 
    f = open(filename</span><span class="s2">, </span><span class="s4">'rb'</span><span class="s1">) 
    f.read(skip) 
    code = marshal.load(f) 
    f.close() 
    safe = </span><span class="s2">True</span><span class="s1"> 
    symbols = dict.fromkeys(iter_symbols(code)) 
    </span><span class="s2">for </span><span class="s1">bad </span><span class="s2">in </span><span class="s1">[</span><span class="s4">'__file__'</span><span class="s2">, </span><span class="s4">'__path__'</span><span class="s1">]: 
        </span><span class="s2">if </span><span class="s1">bad </span><span class="s2">in </span><span class="s1">symbols: 
            log.warn(</span><span class="s4">&quot;%s: module references %s&quot;</span><span class="s2">, </span><span class="s1">module</span><span class="s2">, </span><span class="s1">bad) 
            safe = </span><span class="s2">False</span><span class="s1"> 
    </span><span class="s2">if </span><span class="s4">'inspect' </span><span class="s2">in </span><span class="s1">symbols: 
        </span><span class="s2">for </span><span class="s1">bad </span><span class="s2">in </span><span class="s1">[ 
            </span><span class="s4">'getsource'</span><span class="s2">, </span><span class="s4">'getabsfile'</span><span class="s2">, </span><span class="s4">'getsourcefile'</span><span class="s2">, </span><span class="s4">'getfile'</span><span class="s1"> 
            </span><span class="s4">'getsourcelines'</span><span class="s2">, </span><span class="s4">'findsource'</span><span class="s2">, </span><span class="s4">'getcomments'</span><span class="s2">, </span><span class="s4">'getframeinfo'</span><span class="s2">,</span><span class="s1"> 
            </span><span class="s4">'getinnerframes'</span><span class="s2">, </span><span class="s4">'getouterframes'</span><span class="s2">, </span><span class="s4">'stack'</span><span class="s2">, </span><span class="s4">'trace'</span><span class="s1"> 
        ]: 
            </span><span class="s2">if </span><span class="s1">bad </span><span class="s2">in </span><span class="s1">symbols: 
                log.warn(</span><span class="s4">&quot;%s: module MAY be using inspect.%s&quot;</span><span class="s2">, </span><span class="s1">module</span><span class="s2">, </span><span class="s1">bad) 
                safe = </span><span class="s2">False</span><span class="s1"> 
    </span><span class="s2">return </span><span class="s1">safe 
 
 
</span><span class="s2">def </span><span class="s1">iter_symbols(code): 
    </span><span class="s0">&quot;&quot;&quot;Yield names and strings used by `code` and its nested code objects&quot;&quot;&quot;</span><span class="s1"> 
    </span><span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">code.co_names: 
        </span><span class="s2">yield </span><span class="s1">name 
    </span><span class="s2">for </span><span class="s1">const </span><span class="s2">in </span><span class="s1">code.co_consts: 
        </span><span class="s2">if </span><span class="s1">isinstance(const</span><span class="s2">, </span><span class="s1">six.string_types): 
            </span><span class="s2">yield </span><span class="s1">const 
        </span><span class="s2">elif </span><span class="s1">isinstance(const</span><span class="s2">, </span><span class="s1">CodeType): 
            </span><span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">iter_symbols(const): 
                </span><span class="s2">yield </span><span class="s1">name 
 
 
</span><span class="s2">def </span><span class="s1">can_scan(): 
    </span><span class="s2">if not </span><span class="s1">sys.platform.startswith(</span><span class="s4">'java'</span><span class="s1">) </span><span class="s2">and </span><span class="s1">sys.platform != </span><span class="s4">'cli'</span><span class="s1">: 
        </span><span class="s3"># CPython, PyPy, etc.</span><span class="s1"> 
        </span><span class="s2">return True</span><span class="s1"> 
    log.warn(</span><span class="s4">&quot;Unable to analyze compiled code on this platform.&quot;</span><span class="s1">) 
    log.warn(</span><span class="s4">&quot;Please ask the author to include a 'zip_safe'&quot;</span><span class="s1"> 
             </span><span class="s4">&quot; setting (either True or False) in the package's setup.py&quot;</span><span class="s1">) 
 
 
</span><span class="s3"># Attribute names of options for commands that might need to be convinced to</span><span class="s1"> 
</span><span class="s3"># install to the egg build directory</span><span class="s1"> 
 
INSTALL_DIRECTORY_ATTRS = [ 
    </span><span class="s4">'install_lib'</span><span class="s2">, </span><span class="s4">'install_dir'</span><span class="s2">, </span><span class="s4">'install_data'</span><span class="s2">, </span><span class="s4">'install_base'</span><span class="s1"> 
] 
 
 
</span><span class="s2">def </span><span class="s1">make_zipfile(zip_filename</span><span class="s2">, </span><span class="s1">base_dir</span><span class="s2">, </span><span class="s1">verbose=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">dry_run=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">compress=</span><span class="s2">True,</span><span class="s1"> 
                 mode=</span><span class="s4">'w'</span><span class="s1">): 
    </span><span class="s0">&quot;&quot;&quot;Create a zip file from all the files under 'base_dir'.  The output 
    zip file will be named 'base_dir' + &quot;.zip&quot;.  Uses either the &quot;zipfile&quot; 
    Python module (if available) or the InfoZIP &quot;zip&quot; utility (if installed 
    and found on the default search path).  If neither tool is available, 
    raises DistutilsExecError.  Returns the name of the output zip file. 
    &quot;&quot;&quot;</span><span class="s1"> 
    </span><span class="s2">import </span><span class="s1">zipfile 
 
    mkpath(os.path.dirname(zip_filename)</span><span class="s2">, </span><span class="s1">dry_run=dry_run) 
    log.info(</span><span class="s4">&quot;creating '%s' and adding '%s' to it&quot;</span><span class="s2">, </span><span class="s1">zip_filename</span><span class="s2">, </span><span class="s1">base_dir) 
 
    </span><span class="s2">def </span><span class="s1">visit(z</span><span class="s2">, </span><span class="s1">dirname</span><span class="s2">, </span><span class="s1">names): 
        </span><span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">names: 
            path = os.path.normpath(os.path.join(dirname</span><span class="s2">, </span><span class="s1">name)) 
            </span><span class="s2">if </span><span class="s1">os.path.isfile(path): 
                p = path[len(base_dir) + </span><span class="s5">1</span><span class="s1">:] 
                </span><span class="s2">if not </span><span class="s1">dry_run: 
                    z.write(path</span><span class="s2">, </span><span class="s1">p) 
                log.debug(</span><span class="s4">&quot;adding '%s'&quot;</span><span class="s2">, </span><span class="s1">p) 
 
    compression = zipfile.ZIP_DEFLATED </span><span class="s2">if </span><span class="s1">compress </span><span class="s2">else </span><span class="s1">zipfile.ZIP_STORED 
    </span><span class="s2">if not </span><span class="s1">dry_run: 
        z = zipfile.ZipFile(zip_filename</span><span class="s2">, </span><span class="s1">mode</span><span class="s2">, </span><span class="s1">compression=compression) 
        </span><span class="s2">for </span><span class="s1">dirname</span><span class="s2">, </span><span class="s1">dirs</span><span class="s2">, </span><span class="s1">files </span><span class="s2">in </span><span class="s1">sorted_walk(base_dir): 
            visit(z</span><span class="s2">, </span><span class="s1">dirname</span><span class="s2">, </span><span class="s1">files) 
        z.close() 
    </span><span class="s2">else</span><span class="s1">: 
        </span><span class="s2">for </span><span class="s1">dirname</span><span class="s2">, </span><span class="s1">dirs</span><span class="s2">, </span><span class="s1">files </span><span class="s2">in </span><span class="s1">sorted_walk(base_dir): 
            visit(</span><span class="s2">None, </span><span class="s1">dirname</span><span class="s2">, </span><span class="s1">files) 
    </span><span class="s2">return </span><span class="s1">zip_filename 
</span></pre>
</body>
</html>