<html>
<head>
<title>heuristics.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.ln { color: #606366; font-weight: normal; font-style: normal; }
.s0 { color: rgb(204,120,50); }
.s1 { color: rgb(169,183,198); }
.s2 { color: rgb(106,135,89); }
.s3 { color: rgb(98,151,85); font-style: italic; }
.s4 { color: rgb(104,151,187); }
</style>
</head>
<BODY BGCOLOR="#2b2b2b">
<TABLE CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<TR><TD><CENTER>
<FONT FACE="Arial, Helvetica" COLOR="#000000">
heuristics.py</FONT>
</center></TD></TR></TABLE>
<pre>
<span class="s0">import </span><span class="s1">calendar 
</span><span class="s0">import </span><span class="s1">time 
 
</span><span class="s0">from </span><span class="s1">email.utils </span><span class="s0">import </span><span class="s1">formatdate</span><span class="s0">, </span><span class="s1">parsedate</span><span class="s0">, </span><span class="s1">parsedate_tz 
 
</span><span class="s0">from </span><span class="s1">datetime </span><span class="s0">import </span><span class="s1">datetime</span><span class="s0">, </span><span class="s1">timedelta 
 
TIME_FMT = </span><span class="s2">&quot;%a, %d %b %Y %H:%M:%S GMT&quot;</span><span class="s1"> 
 
 
</span><span class="s0">def </span><span class="s1">expire_after(delta</span><span class="s0">, </span><span class="s1">date=</span><span class="s0">None</span><span class="s1">): 
    date = date </span><span class="s0">or </span><span class="s1">datetime.now() 
    </span><span class="s0">return </span><span class="s1">date + delta 
 
 
</span><span class="s0">def </span><span class="s1">datetime_to_header(dt): 
    </span><span class="s0">return </span><span class="s1">formatdate(calendar.timegm(dt.timetuple())) 
 
 
</span><span class="s0">class </span><span class="s1">BaseHeuristic(object): 
 
    </span><span class="s0">def </span><span class="s1">warning(self</span><span class="s0">, </span><span class="s1">response): 
        </span><span class="s3">&quot;&quot;&quot; 
        Return a valid 1xx warning header value describing the cache 
        adjustments. 
 
        The response is provided too allow warnings like 113 
        http://tools.ietf.org/html/rfc7234#section-5.5.4 where we need 
        to explicitly say response is over 24 hours old. 
        &quot;&quot;&quot;</span><span class="s1"> 
        </span><span class="s0">return </span><span class="s2">'110 - &quot;Response is Stale&quot;'</span><span class="s1"> 
 
    </span><span class="s0">def </span><span class="s1">update_headers(self</span><span class="s0">, </span><span class="s1">response): 
        </span><span class="s3">&quot;&quot;&quot;Update the response headers with any new headers. 
 
        NOTE: This SHOULD always include some Warning header to 
              signify that the response was cached by the client, not 
              by way of the provided headers. 
        &quot;&quot;&quot;</span><span class="s1"> 
        </span><span class="s0">return </span><span class="s1">{} 
 
    </span><span class="s0">def </span><span class="s1">apply(self</span><span class="s0">, </span><span class="s1">response): 
        updated_headers = self.update_headers(response) 
 
        </span><span class="s0">if </span><span class="s1">updated_headers: 
            response.headers.update(updated_headers) 
            warning_header_value = self.warning(response) 
            </span><span class="s0">if </span><span class="s1">warning_header_value </span><span class="s0">is not None</span><span class="s1">: 
                response.headers.update({</span><span class="s2">'Warning'</span><span class="s1">: warning_header_value}) 
 
        </span><span class="s0">return </span><span class="s1">response 
 
 
</span><span class="s0">class </span><span class="s1">OneDayCache(BaseHeuristic): 
    </span><span class="s3">&quot;&quot;&quot; 
    Cache the response by providing an expires 1 day in the 
    future. 
    &quot;&quot;&quot;</span><span class="s1"> 
    </span><span class="s0">def </span><span class="s1">update_headers(self</span><span class="s0">, </span><span class="s1">response): 
        headers = {} 
 
        </span><span class="s0">if </span><span class="s2">'expires' </span><span class="s0">not in </span><span class="s1">response.headers: 
            date = parsedate(response.headers[</span><span class="s2">'date'</span><span class="s1">]) 
            expires = expire_after(timedelta(days=</span><span class="s4">1</span><span class="s1">)</span><span class="s0">,</span><span class="s1"> 
                                   date=datetime(*date[:</span><span class="s4">6</span><span class="s1">])) 
            headers[</span><span class="s2">'expires'</span><span class="s1">] = datetime_to_header(expires) 
            headers[</span><span class="s2">'cache-control'</span><span class="s1">] = </span><span class="s2">'public'</span><span class="s1"> 
        </span><span class="s0">return </span><span class="s1">headers 
 
 
</span><span class="s0">class </span><span class="s1">ExpiresAfter(BaseHeuristic): 
    </span><span class="s3">&quot;&quot;&quot; 
    Cache **all** requests for a defined time period. 
    &quot;&quot;&quot;</span><span class="s1"> 
 
    </span><span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">**kw): 
        self.delta = timedelta(**kw) 
 
    </span><span class="s0">def </span><span class="s1">update_headers(self</span><span class="s0">, </span><span class="s1">response): 
        expires = expire_after(self.delta) 
        </span><span class="s0">return </span><span class="s1">{ 
            </span><span class="s2">'expires'</span><span class="s1">: datetime_to_header(expires)</span><span class="s0">,</span><span class="s1"> 
            </span><span class="s2">'cache-control'</span><span class="s1">: </span><span class="s2">'public'</span><span class="s0">,</span><span class="s1"> 
        } 
 
    </span><span class="s0">def </span><span class="s1">warning(self</span><span class="s0">, </span><span class="s1">response): 
        tmpl = </span><span class="s2">'110 - Automatically cached for %s. Response might be stale'</span><span class="s1"> 
        </span><span class="s0">return </span><span class="s1">tmpl % self.delta 
 
 
</span><span class="s0">class </span><span class="s1">LastModified(BaseHeuristic): 
    </span><span class="s3">&quot;&quot;&quot; 
    If there is no Expires header already, fall back on Last-Modified 
    using the heuristic from 
    http://tools.ietf.org/html/rfc7234#section-4.2.2 
    to calculate a reasonable value. 
 
    Firefox also does something like this per 
    https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching_FAQ 
    http://lxr.mozilla.org/mozilla-release/source/netwerk/protocol/http/nsHttpResponseHead.cpp#397 
    Unlike mozilla we limit this to 24-hr. 
    &quot;&quot;&quot;</span><span class="s1"> 
    cacheable_by_default_statuses = set([ 
        </span><span class="s4">200</span><span class="s0">, </span><span class="s4">203</span><span class="s0">, </span><span class="s4">204</span><span class="s0">, </span><span class="s4">206</span><span class="s0">, </span><span class="s4">300</span><span class="s0">, </span><span class="s4">301</span><span class="s0">, </span><span class="s4">404</span><span class="s0">, </span><span class="s4">405</span><span class="s0">, </span><span class="s4">410</span><span class="s0">, </span><span class="s4">414</span><span class="s0">, </span><span class="s4">501</span><span class="s1"> 
    ]) 
 
    </span><span class="s0">def </span><span class="s1">update_headers(self</span><span class="s0">, </span><span class="s1">resp): 
        headers = resp.headers 
 
        </span><span class="s0">if </span><span class="s2">'expires' </span><span class="s0">in </span><span class="s1">headers: 
            </span><span class="s0">return </span><span class="s1">{} 
 
        </span><span class="s0">if </span><span class="s2">'cache-control' </span><span class="s0">in </span><span class="s1">headers </span><span class="s0">and </span><span class="s1">headers[</span><span class="s2">'cache-control'</span><span class="s1">] != </span><span class="s2">'public'</span><span class="s1">: 
            </span><span class="s0">return </span><span class="s1">{} 
 
        </span><span class="s0">if </span><span class="s1">resp.status </span><span class="s0">not in </span><span class="s1">self.cacheable_by_default_statuses: 
            </span><span class="s0">return </span><span class="s1">{} 
 
        </span><span class="s0">if </span><span class="s2">'date' </span><span class="s0">not in </span><span class="s1">headers </span><span class="s0">or </span><span class="s2">'last-modified' </span><span class="s0">not in </span><span class="s1">headers: 
            </span><span class="s0">return </span><span class="s1">{} 
 
        date = calendar.timegm(parsedate_tz(headers[</span><span class="s2">'date'</span><span class="s1">])) 
        last_modified = parsedate(headers[</span><span class="s2">'last-modified'</span><span class="s1">]) 
        </span><span class="s0">if </span><span class="s1">date </span><span class="s0">is None or </span><span class="s1">last_modified </span><span class="s0">is None</span><span class="s1">: 
            </span><span class="s0">return </span><span class="s1">{} 
 
        now = time.time() 
        current_age = max(</span><span class="s4">0</span><span class="s0">, </span><span class="s1">now - date) 
        delta = date - calendar.timegm(last_modified) 
        freshness_lifetime = max(</span><span class="s4">0</span><span class="s0">, </span><span class="s1">min(delta / </span><span class="s4">10</span><span class="s0">, </span><span class="s4">24 </span><span class="s1">* </span><span class="s4">3600</span><span class="s1">)) 
        </span><span class="s0">if </span><span class="s1">freshness_lifetime &lt;= current_age: 
            </span><span class="s0">return </span><span class="s1">{} 
 
        expires = date + freshness_lifetime 
        </span><span class="s0">return </span><span class="s1">{</span><span class="s2">'expires'</span><span class="s1">: time.strftime(TIME_FMT</span><span class="s0">, </span><span class="s1">time.gmtime(expires))} 
 
    </span><span class="s0">def </span><span class="s1">warning(self</span><span class="s0">, </span><span class="s1">resp): 
        </span><span class="s0">return None</span><span class="s1"> 
</span></pre>
</body>
</html>