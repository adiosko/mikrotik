<html>
<head>
<title>etree_lxml.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.ln { color: #606366; font-weight: normal; font-style: normal; }
.s0 { color: rgb(98,151,85); font-style: italic; }
.s1 { color: rgb(169,183,198); }
.s2 { color: rgb(204,120,50); }
.s3 { color: rgb(128,128,128); }
.s4 { color: rgb(106,135,89); }
.s5 { color: rgb(104,151,187); }
</style>
</head>
<BODY BGCOLOR="#2b2b2b">
<TABLE CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<TR><TD><CENTER>
<FONT FACE="Arial, Helvetica" COLOR="#000000">
etree_lxml.py</FONT>
</center></TD></TR></TABLE>
<pre>
<span class="s0">&quot;&quot;&quot;Module for supporting the lxml.etree library. The idea here is to use as much 
of the native library as possible, without using fragile hacks like custom element 
names that break between releases. The downside of this is that we cannot represent 
all possible trees; specifically the following are known to cause problems: 
 
Text or comments as siblings of the root element 
Docypes with no name 
 
When any of these things occur, we emit a DataLossWarning 
&quot;&quot;&quot;</span><span class="s1"> 
 
</span><span class="s2">from </span><span class="s1">__future__ </span><span class="s2">import </span><span class="s1">absolute_import</span><span class="s2">, </span><span class="s1">division</span><span class="s2">, </span><span class="s1">unicode_literals 
</span><span class="s3"># pylint:disable=protected-access</span><span class="s1"> 
 
</span><span class="s2">import </span><span class="s1">warnings 
</span><span class="s2">import </span><span class="s1">re 
</span><span class="s2">import </span><span class="s1">sys 
 
</span><span class="s2">from </span><span class="s1">. </span><span class="s2">import </span><span class="s1">base 
</span><span class="s2">from </span><span class="s1">..constants </span><span class="s2">import </span><span class="s1">DataLossWarning 
</span><span class="s2">from </span><span class="s1">.. </span><span class="s2">import </span><span class="s1">constants 
</span><span class="s2">from </span><span class="s1">. </span><span class="s2">import </span><span class="s1">etree </span><span class="s2">as </span><span class="s1">etree_builders 
</span><span class="s2">from </span><span class="s1">.. </span><span class="s2">import </span><span class="s1">_ihatexml 
 
</span><span class="s2">import </span><span class="s1">lxml.etree </span><span class="s2">as </span><span class="s1">etree 
 
 
fullTree = </span><span class="s2">True</span><span class="s1"> 
tag_regexp = re.compile(</span><span class="s4">&quot;{([^}]*)}(.*)&quot;</span><span class="s1">) 
 
comment_type = etree.Comment(</span><span class="s4">&quot;asd&quot;</span><span class="s1">).tag 
 
 
</span><span class="s2">class </span><span class="s1">DocumentType(object): 
    </span><span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">publicId</span><span class="s2">, </span><span class="s1">systemId): 
        self.name = name 
        self.publicId = publicId 
        self.systemId = systemId 
 
 
</span><span class="s2">class </span><span class="s1">Document(object): 
    </span><span class="s2">def </span><span class="s1">__init__(self): 
        self._elementTree = </span><span class="s2">None</span><span class="s1"> 
        self._childNodes = [] 
 
    </span><span class="s2">def </span><span class="s1">appendChild(self</span><span class="s2">, </span><span class="s1">element): 
        self._elementTree.getroot().addnext(element._element) 
 
    </span><span class="s2">def </span><span class="s1">_getChildNodes(self): 
        </span><span class="s2">return </span><span class="s1">self._childNodes 
 
    childNodes = property(_getChildNodes) 
 
 
</span><span class="s2">def </span><span class="s1">testSerializer(element): 
    rv = [] 
    infosetFilter = _ihatexml.InfosetFilter(preventDoubleDashComments=</span><span class="s2">True</span><span class="s1">) 
 
    </span><span class="s2">def </span><span class="s1">serializeElement(element</span><span class="s2">, </span><span class="s1">indent=</span><span class="s5">0</span><span class="s1">): 
        </span><span class="s2">if not </span><span class="s1">hasattr(element</span><span class="s2">, </span><span class="s4">&quot;tag&quot;</span><span class="s1">): 
            </span><span class="s2">if </span><span class="s1">hasattr(element</span><span class="s2">, </span><span class="s4">&quot;getroot&quot;</span><span class="s1">): 
                </span><span class="s3"># Full tree case</span><span class="s1"> 
                rv.append(</span><span class="s4">&quot;#document&quot;</span><span class="s1">) 
                </span><span class="s2">if </span><span class="s1">element.docinfo.internalDTD: 
                    </span><span class="s2">if not </span><span class="s1">(element.docinfo.public_id </span><span class="s2">or</span><span class="s1"> 
                            element.docinfo.system_url): 
                        dtd_str = </span><span class="s4">&quot;&lt;!DOCTYPE %s&gt;&quot; </span><span class="s1">% element.docinfo.root_name 
                    </span><span class="s2">else</span><span class="s1">: 
                        dtd_str = </span><span class="s4">&quot;&quot;&quot;&lt;!DOCTYPE %s &quot;%s&quot; &quot;%s&quot;&gt;&quot;&quot;&quot; </span><span class="s1">% ( 
                            element.docinfo.root_name</span><span class="s2">,</span><span class="s1"> 
                            element.docinfo.public_id</span><span class="s2">,</span><span class="s1"> 
                            element.docinfo.system_url) 
                    rv.append(</span><span class="s4">&quot;|%s%s&quot; </span><span class="s1">% (</span><span class="s4">' ' </span><span class="s1">* (indent + </span><span class="s5">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtd_str)) 
                next_element = element.getroot() 
                </span><span class="s2">while </span><span class="s1">next_element.getprevious() </span><span class="s2">is not None</span><span class="s1">: 
                    next_element = next_element.getprevious() 
                </span><span class="s2">while </span><span class="s1">next_element </span><span class="s2">is not None</span><span class="s1">: 
                    serializeElement(next_element</span><span class="s2">, </span><span class="s1">indent + </span><span class="s5">2</span><span class="s1">) 
                    next_element = next_element.getnext() 
            </span><span class="s2">elif </span><span class="s1">isinstance(element</span><span class="s2">, </span><span class="s1">str) </span><span class="s2">or </span><span class="s1">isinstance(element</span><span class="s2">, </span><span class="s1">bytes): 
                </span><span class="s3"># Text in a fragment</span><span class="s1"> 
                </span><span class="s2">assert </span><span class="s1">isinstance(element</span><span class="s2">, </span><span class="s1">str) </span><span class="s2">or </span><span class="s1">sys.version_info[</span><span class="s5">0</span><span class="s1">] == </span><span class="s5">2</span><span class="s1"> 
                rv.append(</span><span class="s4">&quot;|%s</span><span class="s2">\&quot;</span><span class="s4">%s</span><span class="s2">\&quot;</span><span class="s4">&quot; </span><span class="s1">% (</span><span class="s4">' ' </span><span class="s1">* indent</span><span class="s2">, </span><span class="s1">element)) 
            </span><span class="s2">else</span><span class="s1">: 
                </span><span class="s3"># Fragment case</span><span class="s1"> 
                rv.append(</span><span class="s4">&quot;#document-fragment&quot;</span><span class="s1">) 
                </span><span class="s2">for </span><span class="s1">next_element </span><span class="s2">in </span><span class="s1">element: 
                    serializeElement(next_element</span><span class="s2">, </span><span class="s1">indent + </span><span class="s5">2</span><span class="s1">) 
        </span><span class="s2">elif </span><span class="s1">element.tag == comment_type: 
            rv.append(</span><span class="s4">&quot;|%s&lt;!-- %s --&gt;&quot; </span><span class="s1">% (</span><span class="s4">' ' </span><span class="s1">* indent</span><span class="s2">, </span><span class="s1">element.text)) 
            </span><span class="s2">if </span><span class="s1">hasattr(element</span><span class="s2">, </span><span class="s4">&quot;tail&quot;</span><span class="s1">) </span><span class="s2">and </span><span class="s1">element.tail: 
                rv.append(</span><span class="s4">&quot;|%s</span><span class="s2">\&quot;</span><span class="s4">%s</span><span class="s2">\&quot;</span><span class="s4">&quot; </span><span class="s1">% (</span><span class="s4">' ' </span><span class="s1">* indent</span><span class="s2">, </span><span class="s1">element.tail)) 
        </span><span class="s2">else</span><span class="s1">: 
            </span><span class="s2">assert </span><span class="s1">isinstance(element</span><span class="s2">, </span><span class="s1">etree._Element) 
            nsmatch = etree_builders.tag_regexp.match(element.tag) 
            </span><span class="s2">if </span><span class="s1">nsmatch </span><span class="s2">is not None</span><span class="s1">: 
                ns = nsmatch.group(</span><span class="s5">1</span><span class="s1">) 
                tag = nsmatch.group(</span><span class="s5">2</span><span class="s1">) 
                prefix = constants.prefixes[ns] 
                rv.append(</span><span class="s4">&quot;|%s&lt;%s %s&gt;&quot; </span><span class="s1">% (</span><span class="s4">' ' </span><span class="s1">* indent</span><span class="s2">, </span><span class="s1">prefix</span><span class="s2">,</span><span class="s1"> 
                                          infosetFilter.fromXmlName(tag))) 
            </span><span class="s2">else</span><span class="s1">: 
                rv.append(</span><span class="s4">&quot;|%s&lt;%s&gt;&quot; </span><span class="s1">% (</span><span class="s4">' ' </span><span class="s1">* indent</span><span class="s2">,</span><span class="s1"> 
                                       infosetFilter.fromXmlName(element.tag))) 
 
            </span><span class="s2">if </span><span class="s1">hasattr(element</span><span class="s2">, </span><span class="s4">&quot;attrib&quot;</span><span class="s1">): 
                attributes = [] 
                </span><span class="s2">for </span><span class="s1">name</span><span class="s2">, </span><span class="s1">value </span><span class="s2">in </span><span class="s1">element.attrib.items(): 
                    nsmatch = tag_regexp.match(name) 
                    </span><span class="s2">if </span><span class="s1">nsmatch </span><span class="s2">is not None</span><span class="s1">: 
                        ns</span><span class="s2">, </span><span class="s1">name = nsmatch.groups() 
                        name = infosetFilter.fromXmlName(name) 
                        prefix = constants.prefixes[ns] 
                        attr_string = </span><span class="s4">&quot;%s %s&quot; </span><span class="s1">% (prefix</span><span class="s2">, </span><span class="s1">name) 
                    </span><span class="s2">else</span><span class="s1">: 
                        attr_string = infosetFilter.fromXmlName(name) 
                    attributes.append((attr_string</span><span class="s2">, </span><span class="s1">value)) 
 
                </span><span class="s2">for </span><span class="s1">name</span><span class="s2">, </span><span class="s1">value </span><span class="s2">in </span><span class="s1">sorted(attributes): 
                    rv.append(</span><span class="s4">'|%s%s=&quot;%s&quot;' </span><span class="s1">% (</span><span class="s4">' ' </span><span class="s1">* (indent + </span><span class="s5">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">value)) 
 
            </span><span class="s2">if </span><span class="s1">element.text: 
                rv.append(</span><span class="s4">&quot;|%s</span><span class="s2">\&quot;</span><span class="s4">%s</span><span class="s2">\&quot;</span><span class="s4">&quot; </span><span class="s1">% (</span><span class="s4">' ' </span><span class="s1">* (indent + </span><span class="s5">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">element.text)) 
            indent += </span><span class="s5">2</span><span class="s1"> 
            </span><span class="s2">for </span><span class="s1">child </span><span class="s2">in </span><span class="s1">element: 
                serializeElement(child</span><span class="s2">, </span><span class="s1">indent) 
            </span><span class="s2">if </span><span class="s1">hasattr(element</span><span class="s2">, </span><span class="s4">&quot;tail&quot;</span><span class="s1">) </span><span class="s2">and </span><span class="s1">element.tail: 
                rv.append(</span><span class="s4">&quot;|%s</span><span class="s2">\&quot;</span><span class="s4">%s</span><span class="s2">\&quot;</span><span class="s4">&quot; </span><span class="s1">% (</span><span class="s4">' ' </span><span class="s1">* (indent - </span><span class="s5">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">element.tail)) 
    serializeElement(element</span><span class="s2">, </span><span class="s5">0</span><span class="s1">) 
 
    </span><span class="s2">return </span><span class="s4">&quot;</span><span class="s2">\n</span><span class="s4">&quot;</span><span class="s1">.join(rv) 
 
 
</span><span class="s2">def </span><span class="s1">tostring(element): 
    </span><span class="s0">&quot;&quot;&quot;Serialize an element and its child nodes to a string&quot;&quot;&quot;</span><span class="s1"> 
    rv = [] 
 
    </span><span class="s2">def </span><span class="s1">serializeElement(element): 
        </span><span class="s2">if not </span><span class="s1">hasattr(element</span><span class="s2">, </span><span class="s4">&quot;tag&quot;</span><span class="s1">): 
            </span><span class="s2">if </span><span class="s1">element.docinfo.internalDTD: 
                </span><span class="s2">if </span><span class="s1">element.docinfo.doctype: 
                    dtd_str = element.docinfo.doctype 
                </span><span class="s2">else</span><span class="s1">: 
                    dtd_str = </span><span class="s4">&quot;&lt;!DOCTYPE %s&gt;&quot; </span><span class="s1">% element.docinfo.root_name 
                rv.append(dtd_str) 
            serializeElement(element.getroot()) 
 
        </span><span class="s2">elif </span><span class="s1">element.tag == comment_type: 
            rv.append(</span><span class="s4">&quot;&lt;!--%s--&gt;&quot; </span><span class="s1">% (element.text</span><span class="s2">,</span><span class="s1">)) 
 
        </span><span class="s2">else</span><span class="s1">: 
            </span><span class="s3"># This is assumed to be an ordinary element</span><span class="s1"> 
            </span><span class="s2">if not </span><span class="s1">element.attrib: 
                rv.append(</span><span class="s4">&quot;&lt;%s&gt;&quot; </span><span class="s1">% (element.tag</span><span class="s2">,</span><span class="s1">)) 
            </span><span class="s2">else</span><span class="s1">: 
                attr = </span><span class="s4">&quot; &quot;</span><span class="s1">.join([</span><span class="s4">&quot;%s=</span><span class="s2">\&quot;</span><span class="s4">%s</span><span class="s2">\&quot;</span><span class="s4">&quot; </span><span class="s1">% (name</span><span class="s2">, </span><span class="s1">value) 
                                 </span><span class="s2">for </span><span class="s1">name</span><span class="s2">, </span><span class="s1">value </span><span class="s2">in </span><span class="s1">element.attrib.items()]) 
                rv.append(</span><span class="s4">&quot;&lt;%s %s&gt;&quot; </span><span class="s1">% (element.tag</span><span class="s2">, </span><span class="s1">attr)) 
            </span><span class="s2">if </span><span class="s1">element.text: 
                rv.append(element.text) 
 
            </span><span class="s2">for </span><span class="s1">child </span><span class="s2">in </span><span class="s1">element: 
                serializeElement(child) 
 
            rv.append(</span><span class="s4">&quot;&lt;/%s&gt;&quot; </span><span class="s1">% (element.tag</span><span class="s2">,</span><span class="s1">)) 
 
        </span><span class="s2">if </span><span class="s1">hasattr(element</span><span class="s2">, </span><span class="s4">&quot;tail&quot;</span><span class="s1">) </span><span class="s2">and </span><span class="s1">element.tail: 
            rv.append(element.tail) 
 
    serializeElement(element) 
 
    </span><span class="s2">return </span><span class="s4">&quot;&quot;</span><span class="s1">.join(rv) 
 
 
</span><span class="s2">class </span><span class="s1">TreeBuilder(base.TreeBuilder): 
    documentClass = Document 
    doctypeClass = DocumentType 
    elementClass = </span><span class="s2">None</span><span class="s1"> 
    commentClass = </span><span class="s2">None</span><span class="s1"> 
    fragmentClass = Document 
    implementation = etree 
 
    </span><span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">namespaceHTMLElements</span><span class="s2">, </span><span class="s1">fullTree=</span><span class="s2">False</span><span class="s1">): 
        builder = etree_builders.getETreeModule(etree</span><span class="s2">, </span><span class="s1">fullTree=fullTree) 
        infosetFilter = self.infosetFilter = _ihatexml.InfosetFilter(preventDoubleDashComments=</span><span class="s2">True</span><span class="s1">) 
        self.namespaceHTMLElements = namespaceHTMLElements 
 
        </span><span class="s2">class </span><span class="s1">Attributes(dict): 
            </span><span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">element</span><span class="s2">, </span><span class="s1">value=</span><span class="s2">None</span><span class="s1">): 
                </span><span class="s2">if </span><span class="s1">value </span><span class="s2">is None</span><span class="s1">: 
                    value = {} 
                self._element = element 
                dict.__init__(self</span><span class="s2">, </span><span class="s1">value)  </span><span class="s3"># pylint:disable=non-parent-init-called</span><span class="s1"> 
                </span><span class="s2">for </span><span class="s1">key</span><span class="s2">, </span><span class="s1">value </span><span class="s2">in </span><span class="s1">self.items(): 
                    </span><span class="s2">if </span><span class="s1">isinstance(key</span><span class="s2">, </span><span class="s1">tuple): 
                        name = </span><span class="s4">&quot;{%s}%s&quot; </span><span class="s1">% (key[</span><span class="s5">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">infosetFilter.coerceAttribute(key[</span><span class="s5">1</span><span class="s1">])) 
                    </span><span class="s2">else</span><span class="s1">: 
                        name = infosetFilter.coerceAttribute(key) 
                    self._element._element.attrib[name] = value 
 
            </span><span class="s2">def </span><span class="s1">__setitem__(self</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">value): 
                dict.__setitem__(self</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">value) 
                </span><span class="s2">if </span><span class="s1">isinstance(key</span><span class="s2">, </span><span class="s1">tuple): 
                    name = </span><span class="s4">&quot;{%s}%s&quot; </span><span class="s1">% (key[</span><span class="s5">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">infosetFilter.coerceAttribute(key[</span><span class="s5">1</span><span class="s1">])) 
                </span><span class="s2">else</span><span class="s1">: 
                    name = infosetFilter.coerceAttribute(key) 
                self._element._element.attrib[name] = value 
 
        </span><span class="s2">class </span><span class="s1">Element(builder.Element): 
            </span><span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">namespace): 
                name = infosetFilter.coerceElement(name) 
                builder.Element.__init__(self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">namespace=namespace) 
                self._attributes = Attributes(self) 
 
            </span><span class="s2">def </span><span class="s1">_setName(self</span><span class="s2">, </span><span class="s1">name): 
                self._name = infosetFilter.coerceElement(name) 
                self._element.tag = self._getETreeTag( 
                    self._name</span><span class="s2">, </span><span class="s1">self._namespace) 
 
            </span><span class="s2">def </span><span class="s1">_getName(self): 
                </span><span class="s2">return </span><span class="s1">infosetFilter.fromXmlName(self._name) 
 
            name = property(_getName</span><span class="s2">, </span><span class="s1">_setName) 
 
            </span><span class="s2">def </span><span class="s1">_getAttributes(self): 
                </span><span class="s2">return </span><span class="s1">self._attributes 
 
            </span><span class="s2">def </span><span class="s1">_setAttributes(self</span><span class="s2">, </span><span class="s1">attributes): 
                self._attributes = Attributes(self</span><span class="s2">, </span><span class="s1">attributes) 
 
            attributes = property(_getAttributes</span><span class="s2">, </span><span class="s1">_setAttributes) 
 
            </span><span class="s2">def </span><span class="s1">insertText(self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">insertBefore=</span><span class="s2">None</span><span class="s1">): 
                data = infosetFilter.coerceCharacters(data) 
                builder.Element.insertText(self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">insertBefore) 
 
            </span><span class="s2">def </span><span class="s1">appendChild(self</span><span class="s2">, </span><span class="s1">child): 
                builder.Element.appendChild(self</span><span class="s2">, </span><span class="s1">child) 
 
        </span><span class="s2">class </span><span class="s1">Comment(builder.Comment): 
            </span><span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">data): 
                data = infosetFilter.coerceComment(data) 
                builder.Comment.__init__(self</span><span class="s2">, </span><span class="s1">data) 
 
            </span><span class="s2">def </span><span class="s1">_setData(self</span><span class="s2">, </span><span class="s1">data): 
                data = infosetFilter.coerceComment(data) 
                self._element.text = data 
 
            </span><span class="s2">def </span><span class="s1">_getData(self): 
                </span><span class="s2">return </span><span class="s1">self._element.text 
 
            data = property(_getData</span><span class="s2">, </span><span class="s1">_setData) 
 
        self.elementClass = Element 
        self.commentClass = Comment 
        </span><span class="s3"># self.fragmentClass = builder.DocumentFragment</span><span class="s1"> 
        base.TreeBuilder.__init__(self</span><span class="s2">, </span><span class="s1">namespaceHTMLElements) 
 
    </span><span class="s2">def </span><span class="s1">reset(self): 
        base.TreeBuilder.reset(self) 
        self.insertComment = self.insertCommentInitial 
        self.initial_comments = [] 
        self.doctype = </span><span class="s2">None</span><span class="s1"> 
 
    </span><span class="s2">def </span><span class="s1">testSerializer(self</span><span class="s2">, </span><span class="s1">element): 
        </span><span class="s2">return </span><span class="s1">testSerializer(element) 
 
    </span><span class="s2">def </span><span class="s1">getDocument(self): 
        </span><span class="s2">if </span><span class="s1">fullTree: 
            </span><span class="s2">return </span><span class="s1">self.document._elementTree 
        </span><span class="s2">else</span><span class="s1">: 
            </span><span class="s2">return </span><span class="s1">self.document._elementTree.getroot() 
 
    </span><span class="s2">def </span><span class="s1">getFragment(self): 
        fragment = [] 
        element = self.openElements[</span><span class="s5">0</span><span class="s1">]._element 
        </span><span class="s2">if </span><span class="s1">element.text: 
            fragment.append(element.text) 
        fragment.extend(list(element)) 
        </span><span class="s2">if </span><span class="s1">element.tail: 
            fragment.append(element.tail) 
        </span><span class="s2">return </span><span class="s1">fragment 
 
    </span><span class="s2">def </span><span class="s1">insertDoctype(self</span><span class="s2">, </span><span class="s1">token): 
        name = token[</span><span class="s4">&quot;name&quot;</span><span class="s1">] 
        publicId = token[</span><span class="s4">&quot;publicId&quot;</span><span class="s1">] 
        systemId = token[</span><span class="s4">&quot;systemId&quot;</span><span class="s1">] 
 
        </span><span class="s2">if not </span><span class="s1">name: 
            warnings.warn(</span><span class="s4">&quot;lxml cannot represent empty doctype&quot;</span><span class="s2">, </span><span class="s1">DataLossWarning) 
            self.doctype = </span><span class="s2">None</span><span class="s1"> 
        </span><span class="s2">else</span><span class="s1">: 
            coercedName = self.infosetFilter.coerceElement(name) 
            </span><span class="s2">if </span><span class="s1">coercedName != name: 
                warnings.warn(</span><span class="s4">&quot;lxml cannot represent non-xml doctype&quot;</span><span class="s2">, </span><span class="s1">DataLossWarning) 
 
            doctype = self.doctypeClass(coercedName</span><span class="s2">, </span><span class="s1">publicId</span><span class="s2">, </span><span class="s1">systemId) 
            self.doctype = doctype 
 
    </span><span class="s2">def </span><span class="s1">insertCommentInitial(self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">parent=</span><span class="s2">None</span><span class="s1">): 
        </span><span class="s2">assert </span><span class="s1">parent </span><span class="s2">is None or </span><span class="s1">parent </span><span class="s2">is </span><span class="s1">self.document 
        </span><span class="s2">assert </span><span class="s1">self.document._elementTree </span><span class="s2">is None</span><span class="s1"> 
        self.initial_comments.append(data) 
 
    </span><span class="s2">def </span><span class="s1">insertCommentMain(self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">parent=</span><span class="s2">None</span><span class="s1">): 
        </span><span class="s2">if </span><span class="s1">(parent == self.document </span><span class="s2">and</span><span class="s1"> 
                self.document._elementTree.getroot()[-</span><span class="s5">1</span><span class="s1">].tag == comment_type): 
            warnings.warn(</span><span class="s4">&quot;lxml cannot represent adjacent comments beyond the root elements&quot;</span><span class="s2">, </span><span class="s1">DataLossWarning) 
        super(TreeBuilder</span><span class="s2">, </span><span class="s1">self).insertComment(data</span><span class="s2">, </span><span class="s1">parent) 
 
    </span><span class="s2">def </span><span class="s1">insertRoot(self</span><span class="s2">, </span><span class="s1">token): 
        </span><span class="s0">&quot;&quot;&quot;Create the document root&quot;&quot;&quot;</span><span class="s1"> 
        </span><span class="s3"># Because of the way libxml2 works, it doesn't seem to be possible to</span><span class="s1"> 
        </span><span class="s3"># alter information like the doctype after the tree has been parsed.</span><span class="s1"> 
        </span><span class="s3"># Therefore we need to use the built-in parser to create our initial</span><span class="s1"> 
        </span><span class="s3"># tree, after which we can add elements like normal</span><span class="s1"> 
        docStr = </span><span class="s4">&quot;&quot;</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">self.doctype: 
            </span><span class="s2">assert </span><span class="s1">self.doctype.name 
            docStr += </span><span class="s4">&quot;&lt;!DOCTYPE %s&quot; </span><span class="s1">% self.doctype.name 
            </span><span class="s2">if </span><span class="s1">(self.doctype.publicId </span><span class="s2">is not None or</span><span class="s1"> 
                    self.doctype.systemId </span><span class="s2">is not None</span><span class="s1">): 
                docStr += (</span><span class="s4">' PUBLIC &quot;%s&quot; ' </span><span class="s1">% 
                           (self.infosetFilter.coercePubid(self.doctype.publicId </span><span class="s2">or </span><span class="s4">&quot;&quot;</span><span class="s1">))) 
                </span><span class="s2">if </span><span class="s1">self.doctype.systemId: 
                    sysid = self.doctype.systemId 
                    </span><span class="s2">if </span><span class="s1">sysid.find(</span><span class="s4">&quot;'&quot;</span><span class="s1">) &gt;= </span><span class="s5">0 </span><span class="s2">and </span><span class="s1">sysid.find(</span><span class="s4">'&quot;'</span><span class="s1">) &gt;= </span><span class="s5">0</span><span class="s1">: 
                        warnings.warn(</span><span class="s4">&quot;DOCTYPE system cannot contain single and double quotes&quot;</span><span class="s2">, </span><span class="s1">DataLossWarning) 
                        sysid = sysid.replace(</span><span class="s4">&quot;'&quot;</span><span class="s2">, </span><span class="s4">'U00027'</span><span class="s1">) 
                    </span><span class="s2">if </span><span class="s1">sysid.find(</span><span class="s4">&quot;'&quot;</span><span class="s1">) &gt;= </span><span class="s5">0</span><span class="s1">: 
                        docStr += </span><span class="s4">'&quot;%s&quot;' </span><span class="s1">% sysid 
                    </span><span class="s2">else</span><span class="s1">: 
                        docStr += </span><span class="s4">&quot;'%s'&quot; </span><span class="s1">% sysid 
                </span><span class="s2">else</span><span class="s1">: 
                    docStr += </span><span class="s4">&quot;''&quot;</span><span class="s1"> 
            docStr += </span><span class="s4">&quot;&gt;&quot;</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">self.doctype.name != token[</span><span class="s4">&quot;name&quot;</span><span class="s1">]: 
                warnings.warn(</span><span class="s4">&quot;lxml cannot represent doctype with a different name to the root element&quot;</span><span class="s2">, </span><span class="s1">DataLossWarning) 
        docStr += </span><span class="s4">&quot;&lt;THIS_SHOULD_NEVER_APPEAR_PUBLICLY/&gt;&quot;</span><span class="s1"> 
        root = etree.fromstring(docStr) 
 
        </span><span class="s3"># Append the initial comments:</span><span class="s1"> 
        </span><span class="s2">for </span><span class="s1">comment_token </span><span class="s2">in </span><span class="s1">self.initial_comments: 
            comment = self.commentClass(comment_token[</span><span class="s4">&quot;data&quot;</span><span class="s1">]) 
            root.addprevious(comment._element) 
 
        </span><span class="s3"># Create the root document and add the ElementTree to it</span><span class="s1"> 
        self.document = self.documentClass() 
        self.document._elementTree = root.getroottree() 
 
        </span><span class="s3"># Give the root element the right name</span><span class="s1"> 
        name = token[</span><span class="s4">&quot;name&quot;</span><span class="s1">] 
        namespace = token.get(</span><span class="s4">&quot;namespace&quot;</span><span class="s2">, </span><span class="s1">self.defaultNamespace) 
        </span><span class="s2">if </span><span class="s1">namespace </span><span class="s2">is None</span><span class="s1">: 
            etree_tag = name 
        </span><span class="s2">else</span><span class="s1">: 
            etree_tag = </span><span class="s4">&quot;{%s}%s&quot; </span><span class="s1">% (namespace</span><span class="s2">, </span><span class="s1">name) 
        root.tag = etree_tag 
 
        </span><span class="s3"># Add the root element to the internal child/open data structures</span><span class="s1"> 
        root_element = self.elementClass(name</span><span class="s2">, </span><span class="s1">namespace) 
        root_element._element = root 
        self.document._childNodes.append(root_element) 
        self.openElements.append(root_element) 
 
        </span><span class="s3"># Reset to the default insert comment function</span><span class="s1"> 
        self.insertComment = self.insertCommentMain 
</span></pre>
</body>
</html>