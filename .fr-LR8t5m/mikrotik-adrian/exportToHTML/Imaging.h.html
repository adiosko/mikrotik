<html>
<head>
<title>Imaging.h</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.ln { color: #606366; font-weight: normal; font-style: normal; }
.s0 { color: rgb(128,128,128); }
.s1 { color: rgb(169,183,198); }
.s2 { color: rgb(204,120,50); }
.s3 { color: rgb(106,135,89); }
.s4 { color: rgb(104,151,187); }
.s5 { color: rgb(15,151,149); }
</style>
</head>
<BODY BGCOLOR="#2b2b2b">
<TABLE CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<TR><TD><CENTER>
<FONT FACE="Arial, Helvetica" COLOR="#000000">
Imaging.h</FONT>
</center></TD></TR></TABLE>
<pre>
<span class="s0">/* 
 * The Python Imaging Library 
 * $Id$ 
 * 
 * declarations for the imaging core library 
 * 
 * Copyright (c) 1997-2005 by Secret Labs AB 
 * Copyright (c) 1995-2005 by Fredrik Lundh 
 * 
 * See the README file for information on usage and redistribution. 
 */</span><span class="s1"> 
 
 
</span><span class="s2">#include </span><span class="s3">&quot;ImPlatform.h&quot;</span><span class="s1"> 
 
 
</span><span class="s2">#if </span><span class="s1">defined(__cplusplus) 
</span><span class="s2">extern </span><span class="s3">&quot;C&quot; </span><span class="s1">{ 
</span><span class="s2">#endif</span><span class="s1"> 
 
 
</span><span class="s2">#ifndef </span><span class="s1">M_PI 
</span><span class="s2">#define </span><span class="s1">M_PI    </span><span class="s4">3.1415926535897932384626433832795</span><span class="s1"> 
</span><span class="s2">#endif</span><span class="s1"> 
 
 
</span><span class="s0">/* -------------------------------------------------------------------- */</span><span class="s1"> 
 
</span><span class="s0">/* 
 * Image data organization: 
 * 
 * mode     bytes   byte order 
 * ------------------------------- 
 * 1        1       1 
 * L        1       L 
 * P        1       P 
 * I        4           I (32-bit integer, native byte order) 
 * F        4           F (32-bit IEEE float, native byte order) 
 * RGB      4       R, G, B, - 
 * RGBA     4       R, G, B, A 
 * CMYK     4       C, M, Y, K 
 * YCbCr    4       Y, Cb, Cr, - 
 * Lab      4       L, a, b, - 
 * 
 * experimental modes (incomplete): 
 * LA       4           L, -, -, A 
 * PA       4           P, -, -, A 
 * I;16     2           I (16-bit integer, native byte order) 
 * 
 * &quot;P&quot; is an 8-bit palette mode, which should be mapped through the 
 * palette member to get an output image.  Check palette-&gt;mode to 
 * find the corresponding &quot;real&quot; mode. 
 * 
 * For information on how to access Imaging objects from your own C 
 * extensions, see http://www.effbot.org/zone/pil-extending.htm 
 */</span><span class="s1"> 
 
</span><span class="s0">/* Handles */</span><span class="s1"> 
 
</span><span class="s2">typedef struct </span><span class="s1">ImagingMemoryInstance* Imaging; 
 
</span><span class="s2">typedef struct </span><span class="s1">ImagingAccessInstance* ImagingAccess; 
</span><span class="s2">typedef struct </span><span class="s1">ImagingHistogramInstance* ImagingHistogram; 
</span><span class="s2">typedef struct </span><span class="s1">ImagingOutlineInstance* ImagingOutline; 
</span><span class="s2">typedef struct </span><span class="s1">ImagingPaletteInstance* ImagingPalette; 
 
</span><span class="s0">/* handle magics (used with PyCObject). */</span><span class="s1"> 
</span><span class="s2">#define </span><span class="s1">IMAGING_MAGIC </span><span class="s3">&quot;PIL Imaging&quot;</span><span class="s1"> 
 
</span><span class="s0">/* pixel types */</span><span class="s1"> 
</span><span class="s2">#define </span><span class="s1">IMAGING_TYPE_UINT8 </span><span class="s4">0</span><span class="s1"> 
</span><span class="s2">#define </span><span class="s1">IMAGING_TYPE_INT32 </span><span class="s4">1</span><span class="s1"> 
</span><span class="s2">#define </span><span class="s1">IMAGING_TYPE_FLOAT32 </span><span class="s4">2</span><span class="s1"> 
</span><span class="s2">#define </span><span class="s1">IMAGING_TYPE_SPECIAL </span><span class="s4">3 </span><span class="s0">/* check mode for details */</span><span class="s1"> 
 
</span><span class="s2">#define </span><span class="s1">IMAGING_MODE_LENGTH </span><span class="s4">6</span><span class="s1">+</span><span class="s4">1 </span><span class="s0">/* Band names (&quot;1&quot;, &quot;L&quot;, &quot;P&quot;, &quot;RGB&quot;, &quot;RGBA&quot;, &quot;CMYK&quot;, &quot;YCbCr&quot;, &quot;BGR;xy&quot;) */</span><span class="s1"> 
 
</span><span class="s2">struct </span><span class="s1">ImagingMemoryInstance { 
 
    </span><span class="s0">/* Format */</span><span class="s1"> 
    </span><span class="s2">char </span><span class="s1">mode[IMAGING_MODE_LENGTH]; </span><span class="s0">/* Band names (&quot;1&quot;, &quot;L&quot;, &quot;P&quot;, &quot;RGB&quot;, &quot;RGBA&quot;, &quot;CMYK&quot;, &quot;YCbCr&quot;, &quot;BGR;xy&quot;) */</span><span class="s1"> 
    </span><span class="s2">int </span><span class="s1">type;       </span><span class="s0">/* Data type (IMAGING_TYPE_*) */</span><span class="s1"> 
    </span><span class="s2">int </span><span class="s1">depth;      </span><span class="s0">/* Depth (ignored in this version) */</span><span class="s1"> 
    </span><span class="s2">int </span><span class="s1">bands;      </span><span class="s0">/* Number of bands (1, 2, 3, or 4) */</span><span class="s1"> 
    </span><span class="s2">int </span><span class="s1">xsize;      </span><span class="s0">/* Image dimension. */</span><span class="s1"> 
    </span><span class="s2">int </span><span class="s1">ysize; 
 
    </span><span class="s0">/* Colour palette (for &quot;P&quot; images only) */</span><span class="s1"> 
    ImagingPalette palette; 
 
    </span><span class="s0">/* Data pointers */</span><span class="s1"> 
    UINT8 **image8; </span><span class="s0">/* Set for 8-bit images (pixelsize=1). */</span><span class="s1"> 
    INT32 **image32;    </span><span class="s0">/* Set for 32-bit images (pixelsize=4). */</span><span class="s1"> 
 
    </span><span class="s0">/* Internals */</span><span class="s1"> 
    </span><span class="s2">char </span><span class="s1">**image;   </span><span class="s0">/* Actual raster data. */</span><span class="s1"> 
    </span><span class="s2">char </span><span class="s1">*block;    </span><span class="s0">/* Set if data is allocated in a single block. */</span><span class="s1"> 
 
    </span><span class="s2">int </span><span class="s1">pixelsize;  </span><span class="s0">/* Size of a pixel, in bytes (1, 2 or 4) */</span><span class="s1"> 
    </span><span class="s2">int </span><span class="s1">linesize;   </span><span class="s0">/* Size of a line, in bytes (xsize * pixelsize) */</span><span class="s1"> 
 
    </span><span class="s0">/* Virtual methods */</span><span class="s1"> 
    </span><span class="s2">void </span><span class="s1">(*destroy)(Imaging im); 
}; 
 
 
</span><span class="s2">#define </span><span class="s1">IMAGING_PIXEL_1(im,x,y) ((im)</span><span class="s5">-&gt;</span><span class="s1">image8[(y)][(x)]) 
</span><span class="s2">#define </span><span class="s1">IMAGING_PIXEL_L(im,x,y) ((im)</span><span class="s5">-&gt;</span><span class="s1">image8[(y)][(x)]) 
</span><span class="s2">#define </span><span class="s1">IMAGING_PIXEL_LA(im,x,y) ((im)</span><span class="s5">-&gt;</span><span class="s1">image[(y)][(x)*</span><span class="s4">4</span><span class="s1">]) 
</span><span class="s2">#define </span><span class="s1">IMAGING_PIXEL_P(im,x,y) ((im)</span><span class="s5">-&gt;</span><span class="s1">image8[(y)][(x)]) 
</span><span class="s2">#define </span><span class="s1">IMAGING_PIXEL_PA(im,x,y) ((im)</span><span class="s5">-&gt;</span><span class="s1">image[(y)][(x)*</span><span class="s4">4</span><span class="s1">]) 
</span><span class="s2">#define </span><span class="s1">IMAGING_PIXEL_I(im,x,y) ((im)</span><span class="s5">-&gt;</span><span class="s1">image32[(y)][(x)]) 
</span><span class="s2">#define </span><span class="s1">IMAGING_PIXEL_F(im,x,y) (((FLOAT32*)(im)</span><span class="s5">-&gt;</span><span class="s1">image32[y])[x]) 
</span><span class="s2">#define </span><span class="s1">IMAGING_PIXEL_RGB(im,x,y) ((im)</span><span class="s5">-&gt;</span><span class="s1">image[(y)][(x)*</span><span class="s4">4</span><span class="s1">]) 
</span><span class="s2">#define </span><span class="s1">IMAGING_PIXEL_RGBA(im,x,y) ((im)</span><span class="s5">-&gt;</span><span class="s1">image[(y)][(x)*</span><span class="s4">4</span><span class="s1">]) 
</span><span class="s2">#define </span><span class="s1">IMAGING_PIXEL_CMYK(im,x,y) ((im)</span><span class="s5">-&gt;</span><span class="s1">image[(y)][(x)*</span><span class="s4">4</span><span class="s1">]) 
</span><span class="s2">#define </span><span class="s1">IMAGING_PIXEL_YCbCr(im,x,y) ((im)</span><span class="s5">-&gt;</span><span class="s1">image[(y)][(x)*</span><span class="s4">4</span><span class="s1">]) 
 
</span><span class="s2">#define </span><span class="s1">IMAGING_PIXEL_UINT8(im,x,y) ((im)</span><span class="s5">-&gt;</span><span class="s1">image8[(y)][(x)]) 
</span><span class="s2">#define </span><span class="s1">IMAGING_PIXEL_INT32(im,x,y) ((im)</span><span class="s5">-&gt;</span><span class="s1">image32[(y)][(x)]) 
</span><span class="s2">#define </span><span class="s1">IMAGING_PIXEL_FLOAT32(im,x,y) (((FLOAT32*)(im)</span><span class="s5">-&gt;</span><span class="s1">image32[y])[x]) 
 
</span><span class="s2">struct </span><span class="s1">ImagingAccessInstance { 
  </span><span class="s2">const char</span><span class="s1">* mode; 
  </span><span class="s2">void</span><span class="s1">* (*line)(Imaging im, </span><span class="s2">int </span><span class="s1">x, </span><span class="s2">int </span><span class="s1">y); 
  </span><span class="s2">void </span><span class="s1">(*get_pixel)(Imaging im, </span><span class="s2">int </span><span class="s1">x, </span><span class="s2">int </span><span class="s1">y, </span><span class="s2">void</span><span class="s1">* pixel); 
  </span><span class="s2">void </span><span class="s1">(*put_pixel)(Imaging im, </span><span class="s2">int </span><span class="s1">x, </span><span class="s2">int </span><span class="s1">y, </span><span class="s2">const void</span><span class="s1">* pixel); 
}; 
 
</span><span class="s2">struct </span><span class="s1">ImagingHistogramInstance { 
 
    </span><span class="s0">/* Format */</span><span class="s1"> 
    </span><span class="s2">char </span><span class="s1">mode[IMAGING_MODE_LENGTH]; </span><span class="s0">/* Band names (of corresponding source image) */</span><span class="s1"> 
    </span><span class="s2">int </span><span class="s1">bands;      </span><span class="s0">/* Number of bands (1, 3, or 4) */</span><span class="s1"> 
 
    </span><span class="s0">/* Data */</span><span class="s1"> 
    </span><span class="s2">long </span><span class="s1">*histogram;    </span><span class="s0">/* Histogram (bands*256 longs) */</span><span class="s1"> 
 
}; 
 
 
</span><span class="s2">struct </span><span class="s1">ImagingPaletteInstance { 
 
    </span><span class="s0">/* Format */</span><span class="s1"> 
    </span><span class="s2">char </span><span class="s1">mode[IMAGING_MODE_LENGTH]; </span><span class="s0">/* Band names */</span><span class="s1"> 
 
    </span><span class="s0">/* Data */</span><span class="s1"> 
    UINT8 palette[</span><span class="s4">1024</span><span class="s1">];</span><span class="s0">/* Palette data (same format as image data) */</span><span class="s1"> 
 
    INT16* cache;   </span><span class="s0">/* Palette cache (used for predefined palettes) */</span><span class="s1"> 
    </span><span class="s2">int </span><span class="s1">keep_cache; </span><span class="s0">/* This palette will be reused; keep cache */</span><span class="s1"> 
 
}; 
 
 
</span><span class="s0">/* Objects */</span><span class="s1"> 
</span><span class="s0">/* ------- */</span><span class="s1"> 
 
</span><span class="s2">extern int </span><span class="s1">ImagingNewCount; 
 
</span><span class="s2">extern </span><span class="s1">Imaging ImagingNew(</span><span class="s2">const char</span><span class="s1">* mode, </span><span class="s2">int </span><span class="s1">xsize, </span><span class="s2">int </span><span class="s1">ysize); 
</span><span class="s2">extern </span><span class="s1">Imaging ImagingNew2(</span><span class="s2">const char</span><span class="s1">* mode, Imaging imOut, Imaging imIn); 
</span><span class="s2">extern void    </span><span class="s1">ImagingDelete(Imaging im); 
 
</span><span class="s2">extern </span><span class="s1">Imaging ImagingNewBlock(</span><span class="s2">const char</span><span class="s1">* mode, </span><span class="s2">int </span><span class="s1">xsize, </span><span class="s2">int </span><span class="s1">ysize); 
</span><span class="s2">extern </span><span class="s1">Imaging ImagingNewArray(</span><span class="s2">const char</span><span class="s1">* mode, </span><span class="s2">int </span><span class="s1">xsize, </span><span class="s2">int </span><span class="s1">ysize); 
</span><span class="s2">extern </span><span class="s1">Imaging ImagingNewMap(</span><span class="s2">const char</span><span class="s1">* filename, </span><span class="s2">int </span><span class="s1">readonly, 
                             </span><span class="s2">const char</span><span class="s1">* mode, </span><span class="s2">int </span><span class="s1">xsize, </span><span class="s2">int </span><span class="s1">ysize); 
 
</span><span class="s2">extern </span><span class="s1">Imaging ImagingNewPrologue(</span><span class="s2">const char </span><span class="s1">*mode, 
                                  </span><span class="s2">unsigned </span><span class="s1">xsize, </span><span class="s2">unsigned </span><span class="s1">ysize); 
</span><span class="s2">extern </span><span class="s1">Imaging ImagingNewPrologueSubtype(</span><span class="s2">const char </span><span class="s1">*mode, 
                                  </span><span class="s2">unsigned </span><span class="s1">xsize, </span><span class="s2">unsigned </span><span class="s1">ysize, 
                                  </span><span class="s2">int </span><span class="s1">structure_size); 
</span><span class="s2">extern </span><span class="s1">Imaging ImagingNewEpilogue(Imaging im); 
 
</span><span class="s2">extern void </span><span class="s1">ImagingCopyInfo(Imaging destination, Imaging source); 
 
</span><span class="s2">extern void </span><span class="s1">ImagingHistogramDelete(ImagingHistogram histogram); 
 
</span><span class="s2">extern void </span><span class="s1">ImagingAccessInit(</span><span class="s2">void</span><span class="s1">); 
</span><span class="s2">extern </span><span class="s1">ImagingAccess ImagingAccessNew(Imaging im); 
</span><span class="s2">extern void </span><span class="s1">_ImagingAccessDelete(Imaging im, ImagingAccess access); 
</span><span class="s2">#define </span><span class="s1">ImagingAccessDelete(im, access) </span><span class="s0">/* nop, for now */</span><span class="s1"> 
</span><span class="s0">/*#define ImagingAccessDelete(im, access) \ 
  ((access)-&gt;dynamic ? _ImagingAccessDelete((im), (access)), 0 : 0)) */</span><span class="s1"> 
 
</span><span class="s2">extern </span><span class="s1">ImagingPalette ImagingPaletteNew(</span><span class="s2">const char </span><span class="s1">*mode); 
</span><span class="s2">extern </span><span class="s1">ImagingPalette ImagingPaletteNewBrowser(</span><span class="s2">void</span><span class="s1">); 
</span><span class="s2">extern </span><span class="s1">ImagingPalette ImagingPaletteDuplicate(ImagingPalette palette); 
</span><span class="s2">extern void           </span><span class="s1">ImagingPaletteDelete(ImagingPalette palette); 
 
</span><span class="s2">extern int  </span><span class="s1">ImagingPaletteCachePrepare(ImagingPalette palette); 
</span><span class="s2">extern void </span><span class="s1">ImagingPaletteCacheUpdate(ImagingPalette palette, 
                      </span><span class="s2">int </span><span class="s1">r, </span><span class="s2">int </span><span class="s1">g, </span><span class="s2">int </span><span class="s1">b); 
</span><span class="s2">extern void </span><span class="s1">ImagingPaletteCacheDelete(ImagingPalette palette); 
 
</span><span class="s2">#define </span><span class="s1">ImagingPaletteCache(p, r, g, b)\ 
    p</span><span class="s5">-&gt;</span><span class="s1">cache[(r&gt;&gt;</span><span class="s4">2</span><span class="s1">) + (g&gt;&gt;</span><span class="s4">2</span><span class="s1">)*</span><span class="s4">64 </span><span class="s1">+ (b&gt;&gt;</span><span class="s4">2</span><span class="s1">)*</span><span class="s4">64</span><span class="s1">*</span><span class="s4">64</span><span class="s1">] 
 
</span><span class="s2">extern </span><span class="s1">Imaging ImagingQuantize(Imaging im, </span><span class="s2">int </span><span class="s1">colours, </span><span class="s2">int </span><span class="s1">mode, </span><span class="s2">int </span><span class="s1">kmeans); 
 
</span><span class="s0">/* Threading */</span><span class="s1"> 
</span><span class="s0">/* --------- */</span><span class="s1"> 
 
</span><span class="s2">typedef void</span><span class="s1">* ImagingSectionCookie; 
 
</span><span class="s2">extern void </span><span class="s1">ImagingSectionEnter(ImagingSectionCookie* cookie); 
</span><span class="s2">extern void </span><span class="s1">ImagingSectionLeave(ImagingSectionCookie* cookie); 
 
</span><span class="s0">/* Exceptions */</span><span class="s1"> 
</span><span class="s0">/* ---------- */</span><span class="s1"> 
 
</span><span class="s2">extern void</span><span class="s1">* ImagingError_IOError(</span><span class="s2">void</span><span class="s1">); 
</span><span class="s2">extern void</span><span class="s1">* ImagingError_MemoryError(</span><span class="s2">void</span><span class="s1">); 
</span><span class="s2">extern void</span><span class="s1">* ImagingError_ModeError(</span><span class="s2">void</span><span class="s1">); </span><span class="s0">/* maps to ValueError by default */</span><span class="s1"> 
</span><span class="s2">extern void</span><span class="s1">* ImagingError_Mismatch(</span><span class="s2">void</span><span class="s1">); </span><span class="s0">/* maps to ValueError by default */</span><span class="s1"> 
</span><span class="s2">extern void</span><span class="s1">* ImagingError_ValueError(</span><span class="s2">const char</span><span class="s1">* message); 
</span><span class="s2">extern void </span><span class="s1">ImagingError_Clear(</span><span class="s2">void</span><span class="s1">); 
 
</span><span class="s0">/* Transform callbacks */</span><span class="s1"> 
</span><span class="s0">/* ------------------- */</span><span class="s1"> 
 
</span><span class="s0">/* standard transforms */</span><span class="s1"> 
</span><span class="s2">#define </span><span class="s1">IMAGING_TRANSFORM_AFFINE </span><span class="s4">0</span><span class="s1"> 
</span><span class="s2">#define </span><span class="s1">IMAGING_TRANSFORM_PERSPECTIVE </span><span class="s4">2</span><span class="s1"> 
</span><span class="s2">#define </span><span class="s1">IMAGING_TRANSFORM_QUAD </span><span class="s4">3</span><span class="s1"> 
 
 
</span><span class="s0">/* standard filters */</span><span class="s1"> 
</span><span class="s2">#define </span><span class="s1">IMAGING_TRANSFORM_NEAREST </span><span class="s4">0</span><span class="s1"> 
</span><span class="s2">#define </span><span class="s1">IMAGING_TRANSFORM_LANCZOS </span><span class="s4">1</span><span class="s1"> 
</span><span class="s2">#define </span><span class="s1">IMAGING_TRANSFORM_BILINEAR </span><span class="s4">2</span><span class="s1"> 
</span><span class="s2">#define </span><span class="s1">IMAGING_TRANSFORM_BICUBIC </span><span class="s4">3</span><span class="s1"> 
 
</span><span class="s2">typedef int </span><span class="s1">(*ImagingTransformMap)(</span><span class="s2">double</span><span class="s1">* X, </span><span class="s2">double</span><span class="s1">* Y, 
                                   </span><span class="s2">int </span><span class="s1">x, </span><span class="s2">int </span><span class="s1">y, </span><span class="s2">void</span><span class="s1">* data); 
</span><span class="s2">typedef int </span><span class="s1">(*ImagingTransformFilter)(</span><span class="s2">void</span><span class="s1">* out, Imaging im, 
                                      </span><span class="s2">double </span><span class="s1">x, </span><span class="s2">double </span><span class="s1">y, 
                                      </span><span class="s2">void</span><span class="s1">* data); 
 
</span><span class="s0">/* Image Manipulation Methods */</span><span class="s1"> 
</span><span class="s0">/* -------------------------- */</span><span class="s1"> 
 
</span><span class="s2">extern </span><span class="s1">Imaging ImagingAlphaComposite(Imaging imIn1, Imaging imIn2); 
</span><span class="s2">extern </span><span class="s1">Imaging ImagingBlend(Imaging imIn1, Imaging imIn2, </span><span class="s2">float </span><span class="s1">alpha); 
</span><span class="s2">extern </span><span class="s1">Imaging ImagingCopy(Imaging im); 
</span><span class="s2">extern </span><span class="s1">Imaging ImagingConvert(Imaging im, </span><span class="s2">const char</span><span class="s1">* mode, ImagingPalette palette, </span><span class="s2">int </span><span class="s1">dither); 
</span><span class="s2">extern </span><span class="s1">Imaging ImagingConvertInPlace(Imaging im, </span><span class="s2">const char</span><span class="s1">* mode); 
</span><span class="s2">extern </span><span class="s1">Imaging ImagingConvertMatrix(Imaging im, </span><span class="s2">const char </span><span class="s1">*mode, </span><span class="s2">float </span><span class="s1">m[]); 
</span><span class="s2">extern </span><span class="s1">Imaging ImagingConvertTransparent(Imaging im, </span><span class="s2">const char </span><span class="s1">*mode, </span><span class="s2">int </span><span class="s1">r, </span><span class="s2">int </span><span class="s1">g, </span><span class="s2">int </span><span class="s1">b); 
</span><span class="s2">extern </span><span class="s1">Imaging ImagingCrop(Imaging im, </span><span class="s2">int </span><span class="s1">x0, </span><span class="s2">int </span><span class="s1">y0, </span><span class="s2">int </span><span class="s1">x1, </span><span class="s2">int </span><span class="s1">y1); 
</span><span class="s2">extern </span><span class="s1">Imaging ImagingExpand(Imaging im, </span><span class="s2">int </span><span class="s1">x, </span><span class="s2">int </span><span class="s1">y, </span><span class="s2">int </span><span class="s1">mode); 
</span><span class="s2">extern </span><span class="s1">Imaging ImagingFill(Imaging im, </span><span class="s2">const void</span><span class="s1">* ink); 
</span><span class="s2">extern int </span><span class="s1">ImagingFill2( 
    Imaging into, </span><span class="s2">const void</span><span class="s1">* ink, Imaging mask, 
    </span><span class="s2">int </span><span class="s1">x0, </span><span class="s2">int </span><span class="s1">y0, </span><span class="s2">int </span><span class="s1">x1, </span><span class="s2">int </span><span class="s1">y1); 
</span><span class="s2">extern </span><span class="s1">Imaging ImagingFillBand(Imaging im, </span><span class="s2">int </span><span class="s1">band, </span><span class="s2">int </span><span class="s1">color); 
</span><span class="s2">extern </span><span class="s1">Imaging ImagingFillLinearGradient(</span><span class="s2">const char</span><span class="s1">* mode); 
</span><span class="s2">extern </span><span class="s1">Imaging ImagingFillRadialGradient(</span><span class="s2">const char</span><span class="s1">* mode); 
</span><span class="s2">extern </span><span class="s1">Imaging ImagingFilter( 
    Imaging im, </span><span class="s2">int </span><span class="s1">xsize, </span><span class="s2">int </span><span class="s1">ysize, </span><span class="s2">const </span><span class="s1">FLOAT32* kernel, 
    FLOAT32 offset, FLOAT32 divisor); 
</span><span class="s2">extern </span><span class="s1">Imaging ImagingFlipLeftRight(Imaging imOut, Imaging imIn); 
</span><span class="s2">extern </span><span class="s1">Imaging ImagingFlipTopBottom(Imaging imOut, Imaging imIn); 
</span><span class="s2">extern </span><span class="s1">Imaging ImagingGaussianBlur(Imaging imOut, Imaging imIn, </span><span class="s2">float </span><span class="s1">radius, 
    </span><span class="s2">int </span><span class="s1">passes); 
</span><span class="s2">extern </span><span class="s1">Imaging ImagingGetBand(Imaging im, </span><span class="s2">int </span><span class="s1">band); 
</span><span class="s2">extern int </span><span class="s1">ImagingGetBBox(Imaging im, </span><span class="s2">int </span><span class="s1">bbox[</span><span class="s4">4</span><span class="s1">]); 
</span><span class="s2">typedef struct </span><span class="s1">{ </span><span class="s2">int </span><span class="s1">x, y; INT32 count; INT32 pixel; } ImagingColorItem; 
</span><span class="s2">extern </span><span class="s1">ImagingColorItem* ImagingGetColors(Imaging im, </span><span class="s2">int </span><span class="s1">maxcolors, 
    </span><span class="s2">int </span><span class="s1">*colors); 
</span><span class="s2">extern int </span><span class="s1">ImagingGetExtrema(Imaging im, </span><span class="s2">void </span><span class="s1">*extrema); 
</span><span class="s2">extern int </span><span class="s1">ImagingGetProjection(Imaging im, UINT8* xproj, UINT8* yproj); 
</span><span class="s2">extern </span><span class="s1">ImagingHistogram ImagingGetHistogram( 
    Imaging im, Imaging mask, </span><span class="s2">void </span><span class="s1">*extrema); 
</span><span class="s2">extern </span><span class="s1">Imaging ImagingModeFilter(Imaging im, </span><span class="s2">int </span><span class="s1">size); 
</span><span class="s2">extern </span><span class="s1">Imaging ImagingNegative(Imaging im); 
</span><span class="s2">extern </span><span class="s1">Imaging ImagingOffset(Imaging im, </span><span class="s2">int </span><span class="s1">xoffset, </span><span class="s2">int </span><span class="s1">yoffset); 
</span><span class="s2">extern int </span><span class="s1">ImagingPaste( 
    Imaging into, Imaging im, Imaging mask, 
    </span><span class="s2">int </span><span class="s1">x0, </span><span class="s2">int </span><span class="s1">y0, </span><span class="s2">int </span><span class="s1">x1, </span><span class="s2">int </span><span class="s1">y1); 
</span><span class="s2">extern </span><span class="s1">Imaging ImagingPoint( 
    Imaging im, </span><span class="s2">const char</span><span class="s1">* tablemode, </span><span class="s2">const void</span><span class="s1">* table); 
</span><span class="s2">extern </span><span class="s1">Imaging ImagingPointTransform( 
    Imaging imIn, </span><span class="s2">double </span><span class="s1">scale, </span><span class="s2">double </span><span class="s1">offset); 
</span><span class="s2">extern </span><span class="s1">Imaging ImagingPutBand(Imaging im, Imaging imIn, </span><span class="s2">int </span><span class="s1">band); 
</span><span class="s2">extern </span><span class="s1">Imaging ImagingRankFilter(Imaging im, </span><span class="s2">int </span><span class="s1">size, </span><span class="s2">int </span><span class="s1">rank); 
</span><span class="s2">extern </span><span class="s1">Imaging ImagingRotate( 
    Imaging imOut, Imaging imIn, </span><span class="s2">double </span><span class="s1">theta, </span><span class="s2">int </span><span class="s1">filter); 
</span><span class="s2">extern </span><span class="s1">Imaging ImagingRotate90(Imaging imOut, Imaging imIn); 
</span><span class="s2">extern </span><span class="s1">Imaging ImagingRotate180(Imaging imOut, Imaging imIn); 
</span><span class="s2">extern </span><span class="s1">Imaging ImagingRotate270(Imaging imOut, Imaging imIn); 
</span><span class="s2">extern </span><span class="s1">Imaging ImagingResample(Imaging imIn, </span><span class="s2">int </span><span class="s1">xsize, </span><span class="s2">int </span><span class="s1">ysize, </span><span class="s2">int </span><span class="s1">filter); 
</span><span class="s2">extern </span><span class="s1">Imaging ImagingTranspose(Imaging imOut, Imaging imIn); 
</span><span class="s2">extern </span><span class="s1">Imaging ImagingTransposeToNew(Imaging imIn); 
</span><span class="s2">extern </span><span class="s1">Imaging ImagingTransformPerspective( 
    Imaging imOut, Imaging imIn, </span><span class="s2">int </span><span class="s1">x0, </span><span class="s2">int </span><span class="s1">y0, </span><span class="s2">int </span><span class="s1">x1, </span><span class="s2">int </span><span class="s1">y1, 
    </span><span class="s2">double </span><span class="s1">a[</span><span class="s4">8</span><span class="s1">], </span><span class="s2">int </span><span class="s1">filter, </span><span class="s2">int </span><span class="s1">fill); 
</span><span class="s2">extern </span><span class="s1">Imaging ImagingTransformAffine( 
    Imaging imOut, Imaging imIn, </span><span class="s2">int </span><span class="s1">x0, </span><span class="s2">int </span><span class="s1">y0, </span><span class="s2">int </span><span class="s1">x1, </span><span class="s2">int </span><span class="s1">y1, 
    </span><span class="s2">double </span><span class="s1">a[</span><span class="s4">6</span><span class="s1">], </span><span class="s2">int </span><span class="s1">filter, </span><span class="s2">int </span><span class="s1">fill); 
</span><span class="s2">extern </span><span class="s1">Imaging ImagingTransformQuad( 
    Imaging imOut, Imaging imIn, </span><span class="s2">int </span><span class="s1">x0, </span><span class="s2">int </span><span class="s1">y0, </span><span class="s2">int </span><span class="s1">x1, </span><span class="s2">int </span><span class="s1">y1, 
    </span><span class="s2">double </span><span class="s1">a[</span><span class="s4">8</span><span class="s1">], </span><span class="s2">int </span><span class="s1">filter, </span><span class="s2">int </span><span class="s1">fill); 
</span><span class="s2">extern </span><span class="s1">Imaging ImagingTransform( 
    Imaging imOut, Imaging imIn, </span><span class="s2">int </span><span class="s1">x0, </span><span class="s2">int </span><span class="s1">y0, </span><span class="s2">int </span><span class="s1">x1, </span><span class="s2">int </span><span class="s1">y1, 
    ImagingTransformMap transform, </span><span class="s2">void</span><span class="s1">* transform_data, 
    ImagingTransformFilter filter, </span><span class="s2">void</span><span class="s1">* filter_data, 
    </span><span class="s2">int </span><span class="s1">fill); 
</span><span class="s2">extern </span><span class="s1">Imaging ImagingUnsharpMask( 
    Imaging imOut, Imaging im, </span><span class="s2">float </span><span class="s1">radius, </span><span class="s2">int </span><span class="s1">percent, </span><span class="s2">int </span><span class="s1">threshold); 
</span><span class="s2">extern </span><span class="s1">Imaging ImagingBoxBlur(Imaging imOut, Imaging imIn, </span><span class="s2">float </span><span class="s1">radius, </span><span class="s2">int </span><span class="s1">n); 
 
</span><span class="s2">extern </span><span class="s1">Imaging ImagingCopy2(Imaging imOut, Imaging imIn); 
</span><span class="s2">extern </span><span class="s1">Imaging ImagingConvert2(Imaging imOut, Imaging imIn); 
 
</span><span class="s0">/* Channel operations */</span><span class="s1"> 
</span><span class="s0">/* any mode, except &quot;F&quot; */</span><span class="s1"> 
</span><span class="s2">extern </span><span class="s1">Imaging ImagingChopLighter(Imaging imIn1, Imaging imIn2); 
</span><span class="s2">extern </span><span class="s1">Imaging ImagingChopDarker(Imaging imIn1, Imaging imIn2); 
</span><span class="s2">extern </span><span class="s1">Imaging ImagingChopDifference(Imaging imIn1, Imaging imIn2); 
</span><span class="s2">extern </span><span class="s1">Imaging ImagingChopMultiply(Imaging imIn1, Imaging imIn2); 
</span><span class="s2">extern </span><span class="s1">Imaging ImagingChopScreen(Imaging imIn1, Imaging imIn2); 
</span><span class="s2">extern </span><span class="s1">Imaging ImagingChopAdd( 
    Imaging imIn1, Imaging imIn2, </span><span class="s2">float </span><span class="s1">scale, </span><span class="s2">int </span><span class="s1">offset); 
</span><span class="s2">extern </span><span class="s1">Imaging ImagingChopSubtract( 
    Imaging imIn1, Imaging imIn2, </span><span class="s2">float </span><span class="s1">scale, </span><span class="s2">int </span><span class="s1">offset); 
</span><span class="s2">extern </span><span class="s1">Imaging ImagingChopAddModulo(Imaging imIn1, Imaging imIn2); 
</span><span class="s2">extern </span><span class="s1">Imaging ImagingChopSubtractModulo(Imaging imIn1, Imaging imIn2); 
 
</span><span class="s0">/* &quot;1&quot; images only */</span><span class="s1"> 
</span><span class="s2">extern </span><span class="s1">Imaging ImagingChopAnd(Imaging imIn1, Imaging imIn2); 
</span><span class="s2">extern </span><span class="s1">Imaging ImagingChopOr(Imaging imIn1, Imaging imIn2); 
</span><span class="s2">extern </span><span class="s1">Imaging ImagingChopXor(Imaging imIn1, Imaging imIn2); 
 
</span><span class="s0">/* Image measurement */</span><span class="s1"> 
</span><span class="s2">extern void </span><span class="s1">ImagingCrack(Imaging im, </span><span class="s2">int </span><span class="s1">x0, </span><span class="s2">int </span><span class="s1">y0); 
 
</span><span class="s0">/* Graphics */</span><span class="s1"> 
</span><span class="s2">struct </span><span class="s1">ImagingAffineMatrixInstance { 
    </span><span class="s2">float </span><span class="s1">a[</span><span class="s4">9</span><span class="s1">]; 
}; 
 
</span><span class="s2">typedef struct </span><span class="s1">ImagingAffineMatrixInstance *ImagingAffineMatrix; 
 
</span><span class="s2">extern int </span><span class="s1">ImagingDrawArc(Imaging im, </span><span class="s2">int </span><span class="s1">x0, </span><span class="s2">int </span><span class="s1">y0, </span><span class="s2">int </span><span class="s1">x1, </span><span class="s2">int </span><span class="s1">y1, 
                          </span><span class="s2">float </span><span class="s1">start, </span><span class="s2">float </span><span class="s1">end, </span><span class="s2">const void</span><span class="s1">* ink, </span><span class="s2">int </span><span class="s1">op); 
</span><span class="s2">extern int </span><span class="s1">ImagingDrawBitmap(Imaging im, </span><span class="s2">int </span><span class="s1">x0, </span><span class="s2">int </span><span class="s1">y0, Imaging bitmap, 
                             </span><span class="s2">const void</span><span class="s1">* ink, </span><span class="s2">int </span><span class="s1">op); 
</span><span class="s2">extern int </span><span class="s1">ImagingDrawChord(Imaging im, </span><span class="s2">int </span><span class="s1">x0, </span><span class="s2">int </span><span class="s1">y0, </span><span class="s2">int </span><span class="s1">x1, </span><span class="s2">int </span><span class="s1">y1, 
                            </span><span class="s2">float </span><span class="s1">start, </span><span class="s2">float </span><span class="s1">end, </span><span class="s2">const void</span><span class="s1">* ink, </span><span class="s2">int </span><span class="s1">fill, 
                            </span><span class="s2">int </span><span class="s1">op); 
</span><span class="s2">extern int </span><span class="s1">ImagingDrawEllipse(Imaging im, </span><span class="s2">int </span><span class="s1">x0, </span><span class="s2">int </span><span class="s1">y0, </span><span class="s2">int </span><span class="s1">x1, </span><span class="s2">int </span><span class="s1">y1, 
                              </span><span class="s2">const void</span><span class="s1">* ink, </span><span class="s2">int </span><span class="s1">fill, </span><span class="s2">int </span><span class="s1">op); 
</span><span class="s2">extern int </span><span class="s1">ImagingDrawLine(Imaging im, </span><span class="s2">int </span><span class="s1">x0, </span><span class="s2">int </span><span class="s1">y0, </span><span class="s2">int </span><span class="s1">x1, </span><span class="s2">int </span><span class="s1">y1, 
               </span><span class="s2">const void</span><span class="s1">* ink, </span><span class="s2">int </span><span class="s1">op); 
</span><span class="s2">extern int </span><span class="s1">ImagingDrawWideLine(Imaging im, </span><span class="s2">int </span><span class="s1">x0, </span><span class="s2">int </span><span class="s1">y0, </span><span class="s2">int </span><span class="s1">x1, </span><span class="s2">int </span><span class="s1">y1, 
                               </span><span class="s2">const void</span><span class="s1">* ink, </span><span class="s2">int </span><span class="s1">width, </span><span class="s2">int </span><span class="s1">op); 
</span><span class="s2">extern int </span><span class="s1">ImagingDrawPieslice(Imaging im, </span><span class="s2">int </span><span class="s1">x0, </span><span class="s2">int </span><span class="s1">y0, </span><span class="s2">int </span><span class="s1">x1, </span><span class="s2">int </span><span class="s1">y1, 
                               </span><span class="s2">float </span><span class="s1">start, </span><span class="s2">float </span><span class="s1">end, </span><span class="s2">const void</span><span class="s1">* ink, </span><span class="s2">int </span><span class="s1">fill, 
                               </span><span class="s2">int </span><span class="s1">op); 
</span><span class="s2">extern int </span><span class="s1">ImagingDrawPoint(Imaging im, </span><span class="s2">int </span><span class="s1">x, </span><span class="s2">int </span><span class="s1">y, </span><span class="s2">const void</span><span class="s1">* ink, </span><span class="s2">int </span><span class="s1">op); 
</span><span class="s2">extern int </span><span class="s1">ImagingDrawPolygon(Imaging im, </span><span class="s2">int </span><span class="s1">points, </span><span class="s2">int </span><span class="s1">*xy, 
                  </span><span class="s2">const void</span><span class="s1">* ink, </span><span class="s2">int </span><span class="s1">fill, </span><span class="s2">int </span><span class="s1">op); 
</span><span class="s2">extern int </span><span class="s1">ImagingDrawRectangle(Imaging im, </span><span class="s2">int </span><span class="s1">x0, </span><span class="s2">int </span><span class="s1">y0, </span><span class="s2">int </span><span class="s1">x1, </span><span class="s2">int </span><span class="s1">y1, 
                </span><span class="s2">const void</span><span class="s1">* ink, </span><span class="s2">int </span><span class="s1">fill, </span><span class="s2">int </span><span class="s1">op); 
 
</span><span class="s0">/* Level 2 graphics (WORK IN PROGRESS) */</span><span class="s1"> 
</span><span class="s2">extern </span><span class="s1">ImagingOutline ImagingOutlineNew(</span><span class="s2">void</span><span class="s1">); 
</span><span class="s2">extern void </span><span class="s1">ImagingOutlineDelete(ImagingOutline outline); 
 
</span><span class="s2">extern int </span><span class="s1">ImagingDrawOutline(Imaging im, ImagingOutline outline, 
                              </span><span class="s2">const void</span><span class="s1">* ink, </span><span class="s2">int </span><span class="s1">fill, </span><span class="s2">int </span><span class="s1">op); 
 
</span><span class="s2">extern int </span><span class="s1">ImagingOutlineMove(ImagingOutline outline, </span><span class="s2">float </span><span class="s1">x, </span><span class="s2">float </span><span class="s1">y); 
</span><span class="s2">extern int </span><span class="s1">ImagingOutlineLine(ImagingOutline outline, </span><span class="s2">float </span><span class="s1">x, </span><span class="s2">float </span><span class="s1">y); 
</span><span class="s2">extern int </span><span class="s1">ImagingOutlineCurve(ImagingOutline outline, </span><span class="s2">float </span><span class="s1">x1, </span><span class="s2">float </span><span class="s1">y1, 
                                </span><span class="s2">float </span><span class="s1">x2, </span><span class="s2">float </span><span class="s1">y2, </span><span class="s2">float </span><span class="s1">x3, </span><span class="s2">float </span><span class="s1">y3); 
</span><span class="s2">extern int </span><span class="s1">ImagingOutlineTransform(ImagingOutline outline, </span><span class="s2">double </span><span class="s1">a[</span><span class="s4">6</span><span class="s1">]); 
 
</span><span class="s2">extern int </span><span class="s1">ImagingOutlineClose(ImagingOutline outline); 
 
</span><span class="s0">/* Special effects */</span><span class="s1"> 
</span><span class="s2">extern </span><span class="s1">Imaging ImagingEffectSpread(Imaging imIn, </span><span class="s2">int </span><span class="s1">distance); 
</span><span class="s2">extern </span><span class="s1">Imaging ImagingEffectNoise(</span><span class="s2">int </span><span class="s1">xsize, </span><span class="s2">int </span><span class="s1">ysize, </span><span class="s2">float </span><span class="s1">sigma); 
</span><span class="s2">extern </span><span class="s1">Imaging ImagingEffectMandelbrot(</span><span class="s2">int </span><span class="s1">xsize, </span><span class="s2">int </span><span class="s1">ysize, 
                                       </span><span class="s2">double </span><span class="s1">extent[</span><span class="s4">4</span><span class="s1">], </span><span class="s2">int </span><span class="s1">quality); 
 
</span><span class="s0">/* Obsolete */</span><span class="s1"> 
</span><span class="s2">extern int </span><span class="s1">ImagingToString(Imaging im, </span><span class="s2">int </span><span class="s1">orientation, </span><span class="s2">char </span><span class="s1">*buffer); 
</span><span class="s2">extern int </span><span class="s1">ImagingFromString(Imaging im, </span><span class="s2">int </span><span class="s1">orientation, </span><span class="s2">char </span><span class="s1">*buffer); 
 
 
</span><span class="s0">/* File I/O */</span><span class="s1"> 
</span><span class="s0">/* -------- */</span><span class="s1"> 
 
</span><span class="s0">/* Built-in drivers */</span><span class="s1"> 
</span><span class="s2">extern </span><span class="s1">Imaging ImagingOpenPPM(</span><span class="s2">const char</span><span class="s1">* filename); 
</span><span class="s2">extern int </span><span class="s1">ImagingSavePPM(Imaging im, </span><span class="s2">const char</span><span class="s1">* filename); 
 
</span><span class="s0">/* Utility functions */</span><span class="s1"> 
</span><span class="s2">extern </span><span class="s1">UINT32 ImagingCRC32(UINT32 crc, UINT8* buffer, </span><span class="s2">int </span><span class="s1">bytes); 
 
</span><span class="s0">/* Codecs */</span><span class="s1"> 
</span><span class="s2">typedef struct </span><span class="s1">ImagingCodecStateInstance *ImagingCodecState; 
</span><span class="s2">typedef int </span><span class="s1">(*ImagingCodec)(Imaging im, ImagingCodecState state, 
                UINT8* buffer, </span><span class="s2">int </span><span class="s1">bytes); 
 
</span><span class="s2">extern int </span><span class="s1">ImagingBitDecode(Imaging im, ImagingCodecState state, 
                UINT8* buffer, </span><span class="s2">int </span><span class="s1">bytes); 
</span><span class="s2">extern int </span><span class="s1">ImagingEpsEncode(Imaging im, ImagingCodecState state, 
                UINT8* buffer, </span><span class="s2">int </span><span class="s1">bytes); 
</span><span class="s2">extern int </span><span class="s1">ImagingFliDecode(Imaging im, ImagingCodecState state, 
                UINT8* buffer, </span><span class="s2">int </span><span class="s1">bytes); 
</span><span class="s2">extern int </span><span class="s1">ImagingGifDecode(Imaging im, ImagingCodecState state, 
                UINT8* buffer, </span><span class="s2">int </span><span class="s1">bytes); 
</span><span class="s2">extern int </span><span class="s1">ImagingGifEncode(Imaging im, ImagingCodecState state, 
                UINT8* buffer, </span><span class="s2">int </span><span class="s1">bytes); 
</span><span class="s2">extern int </span><span class="s1">ImagingHexDecode(Imaging im, ImagingCodecState state, 
                UINT8* buffer, </span><span class="s2">int </span><span class="s1">bytes); 
</span><span class="s2">#ifdef  </span><span class="s1">HAVE_LIBJPEG 
</span><span class="s2">extern int </span><span class="s1">ImagingJpegDecode(Imaging im, ImagingCodecState state, 
                 UINT8* buffer, </span><span class="s2">int </span><span class="s1">bytes); 
</span><span class="s2">extern int </span><span class="s1">ImagingJpegDecodeCleanup(ImagingCodecState state); 
 
</span><span class="s2">extern int </span><span class="s1">ImagingJpegEncode(Imaging im, ImagingCodecState state, 
                 UINT8* buffer, </span><span class="s2">int </span><span class="s1">bytes); 
</span><span class="s2">#endif</span><span class="s1"> 
</span><span class="s2">#ifdef </span><span class="s1">HAVE_OPENJPEG 
</span><span class="s2">extern int </span><span class="s1">ImagingJpeg2KDecode(Imaging im, ImagingCodecState state, 
                               UINT8* buffer, </span><span class="s2">int </span><span class="s1">bytes); 
</span><span class="s2">extern int </span><span class="s1">ImagingJpeg2KDecodeCleanup(ImagingCodecState state); 
</span><span class="s2">extern int </span><span class="s1">ImagingJpeg2KEncode(Imaging im, ImagingCodecState state, 
                               UINT8* buffer, </span><span class="s2">int </span><span class="s1">bytes); 
</span><span class="s2">extern int </span><span class="s1">ImagingJpeg2KEncodeCleanup(ImagingCodecState state); 
</span><span class="s2">#endif</span><span class="s1"> 
</span><span class="s2">extern int </span><span class="s1">ImagingLzwDecode(Imaging im, ImagingCodecState state, 
                UINT8* buffer, </span><span class="s2">int </span><span class="s1">bytes); 
</span><span class="s2">#ifdef  </span><span class="s1">HAVE_LIBTIFF 
</span><span class="s2">extern int </span><span class="s1">ImagingLibTiffDecode(Imaging im, ImagingCodecState state, 
                UINT8* buffer, </span><span class="s2">int </span><span class="s1">bytes); 
</span><span class="s2">extern int </span><span class="s1">ImagingLibTiffEncode(Imaging im, ImagingCodecState state, 
                UINT8* buffer, </span><span class="s2">int </span><span class="s1">bytes); 
</span><span class="s2">#endif</span><span class="s1"> 
</span><span class="s2">#ifdef  </span><span class="s1">HAVE_LIBMPEG 
</span><span class="s2">extern int </span><span class="s1">ImagingMpegDecode(Imaging im, ImagingCodecState state, 
                 UINT8* buffer, </span><span class="s2">int </span><span class="s1">bytes); 
</span><span class="s2">#endif</span><span class="s1"> 
</span><span class="s2">extern int </span><span class="s1">ImagingMspDecode(Imaging im, ImagingCodecState state, 
                UINT8* buffer, </span><span class="s2">int </span><span class="s1">bytes); 
</span><span class="s2">extern int </span><span class="s1">ImagingPackbitsDecode(Imaging im, ImagingCodecState state, 
                 UINT8* buffer, </span><span class="s2">int </span><span class="s1">bytes); 
</span><span class="s2">extern int </span><span class="s1">ImagingPcdDecode(Imaging im, ImagingCodecState state, 
                UINT8* buffer, </span><span class="s2">int </span><span class="s1">bytes); 
</span><span class="s2">extern int </span><span class="s1">ImagingPcxDecode(Imaging im, ImagingCodecState state, 
                UINT8* buffer, </span><span class="s2">int </span><span class="s1">bytes); 
</span><span class="s2">extern int </span><span class="s1">ImagingPcxEncode(Imaging im, ImagingCodecState state, 
                UINT8* buffer, </span><span class="s2">int </span><span class="s1">bytes); 
</span><span class="s2">extern int </span><span class="s1">ImagingRawDecode(Imaging im, ImagingCodecState state, 
                UINT8* buffer, </span><span class="s2">int </span><span class="s1">bytes); 
</span><span class="s2">extern int </span><span class="s1">ImagingRawEncode(Imaging im, ImagingCodecState state, 
                UINT8* buffer, </span><span class="s2">int </span><span class="s1">bytes); 
</span><span class="s2">extern int </span><span class="s1">ImagingSunRleDecode(Imaging im, ImagingCodecState state, 
                   UINT8* buffer, </span><span class="s2">int </span><span class="s1">bytes); 
</span><span class="s2">extern int </span><span class="s1">ImagingTgaRleDecode(Imaging im, ImagingCodecState state, 
                   UINT8* buffer, </span><span class="s2">int </span><span class="s1">bytes); 
</span><span class="s2">extern int </span><span class="s1">ImagingXbmDecode(Imaging im, ImagingCodecState state, 
                UINT8* buffer, </span><span class="s2">int </span><span class="s1">bytes); 
</span><span class="s2">extern int </span><span class="s1">ImagingXbmEncode(Imaging im, ImagingCodecState state, 
                UINT8* buffer, </span><span class="s2">int </span><span class="s1">bytes); 
</span><span class="s2">#ifdef  </span><span class="s1">HAVE_LIBZ 
</span><span class="s2">extern int </span><span class="s1">ImagingZipDecode(Imaging im, ImagingCodecState state, 
                UINT8* buffer, </span><span class="s2">int </span><span class="s1">bytes); 
</span><span class="s2">extern int </span><span class="s1">ImagingZipEncode(Imaging im, ImagingCodecState state, 
                UINT8* buffer, </span><span class="s2">int </span><span class="s1">bytes); 
</span><span class="s2">#endif</span><span class="s1"> 
 
</span><span class="s2">typedef void </span><span class="s1">(*ImagingShuffler)(UINT8* out, </span><span class="s2">const </span><span class="s1">UINT8* in, </span><span class="s2">int </span><span class="s1">pixels); 
 
</span><span class="s0">/* Public shufflers */</span><span class="s1"> 
</span><span class="s2">extern void </span><span class="s1">ImagingPackRGB(UINT8* out, </span><span class="s2">const </span><span class="s1">UINT8* in, </span><span class="s2">int </span><span class="s1">pixels); 
</span><span class="s2">extern void </span><span class="s1">ImagingPackBGR(UINT8* out, </span><span class="s2">const </span><span class="s1">UINT8* in, </span><span class="s2">int </span><span class="s1">pixels); 
</span><span class="s2">extern void </span><span class="s1">ImagingUnpackRGB(UINT8* out, </span><span class="s2">const </span><span class="s1">UINT8* in, </span><span class="s2">int </span><span class="s1">pixels); 
</span><span class="s2">extern void </span><span class="s1">ImagingUnpackBGR(UINT8* out, </span><span class="s2">const </span><span class="s1">UINT8* in, </span><span class="s2">int </span><span class="s1">pixels); 
</span><span class="s2">extern void </span><span class="s1">ImagingUnpackYCC(UINT8* out, </span><span class="s2">const </span><span class="s1">UINT8* in, </span><span class="s2">int </span><span class="s1">pixels); 
</span><span class="s2">extern void </span><span class="s1">ImagingUnpackYCCA(UINT8* out, </span><span class="s2">const </span><span class="s1">UINT8* in, </span><span class="s2">int </span><span class="s1">pixels); 
</span><span class="s2">extern void </span><span class="s1">ImagingUnpackYCbCr(UINT8* out, </span><span class="s2">const </span><span class="s1">UINT8* in, </span><span class="s2">int </span><span class="s1">pixels); 
 
</span><span class="s2">extern void </span><span class="s1">ImagingConvertRGB2YCbCr(UINT8* out, </span><span class="s2">const </span><span class="s1">UINT8* in, </span><span class="s2">int </span><span class="s1">pixels); 
</span><span class="s2">extern void </span><span class="s1">ImagingConvertYCbCr2RGB(UINT8* out, </span><span class="s2">const </span><span class="s1">UINT8* in, </span><span class="s2">int </span><span class="s1">pixels); 
 
</span><span class="s2">extern </span><span class="s1">ImagingShuffler ImagingFindUnpacker(</span><span class="s2">const char</span><span class="s1">* mode, 
                                           </span><span class="s2">const char</span><span class="s1">* rawmode, </span><span class="s2">int</span><span class="s1">* bits_out); 
</span><span class="s2">extern </span><span class="s1">ImagingShuffler ImagingFindPacker(</span><span class="s2">const char</span><span class="s1">* mode, 
                                         </span><span class="s2">const char</span><span class="s1">* rawmode, </span><span class="s2">int</span><span class="s1">* bits_out); 
 
</span><span class="s2">struct </span><span class="s1">ImagingCodecStateInstance { 
    </span><span class="s2">int </span><span class="s1">count; 
    </span><span class="s2">int </span><span class="s1">state; 
    </span><span class="s2">int </span><span class="s1">errcode; 
    </span><span class="s2">int </span><span class="s1">x, y; 
    </span><span class="s2">int </span><span class="s1">ystep; 
    </span><span class="s2">int </span><span class="s1">xsize, ysize, xoff, yoff; 
    ImagingShuffler shuffle; 
    </span><span class="s2">int </span><span class="s1">bits, bytes; 
    UINT8 *buffer; 
    </span><span class="s2">void </span><span class="s1">*context; 
}; 
 
</span><span class="s0">/* Incremental encoding/decoding support */</span><span class="s1"> 
</span><span class="s2">typedef struct </span><span class="s1">ImagingIncrementalCodecStruct *ImagingIncrementalCodec; 
 
</span><span class="s2">typedef int </span><span class="s1">(*ImagingIncrementalCodecEntry)(Imaging im,  
                                            ImagingCodecState state, 
                                            ImagingIncrementalCodec codec); 
 
</span><span class="s2">enum </span><span class="s1">{ 
  INCREMENTAL_CODEC_READ = </span><span class="s4">1</span><span class="s1">, 
  INCREMENTAL_CODEC_WRITE = </span><span class="s4">2</span><span class="s1"> 
}; 
 
</span><span class="s2">enum </span><span class="s1">{ 
  INCREMENTAL_CODEC_NOT_SEEKABLE = </span><span class="s4">0</span><span class="s1">, 
  INCREMENTAL_CODEC_SEEKABLE = </span><span class="s4">1</span><span class="s1"> 
}; 
 
</span><span class="s2">extern </span><span class="s1">ImagingIncrementalCodec ImagingIncrementalCodecCreate(ImagingIncrementalCodecEntry codec_entry, Imaging im, ImagingCodecState state, </span><span class="s2">int </span><span class="s1">read_or_write, </span><span class="s2">int </span><span class="s1">seekable, </span><span class="s2">int </span><span class="s1">fd); 
</span><span class="s2">extern void </span><span class="s1">ImagingIncrementalCodecDestroy(ImagingIncrementalCodec codec); 
</span><span class="s2">extern int </span><span class="s1">ImagingIncrementalCodecPushBuffer(ImagingIncrementalCodec codec, UINT8 *buf, </span><span class="s2">int </span><span class="s1">bytes); 
</span><span class="s2">extern </span><span class="s1">Py_ssize_t ImagingIncrementalCodecRead(ImagingIncrementalCodec codec, </span><span class="s2">void </span><span class="s1">*buffer, size_t bytes); 
</span><span class="s2">extern </span><span class="s1">off_t ImagingIncrementalCodecSkip(ImagingIncrementalCodec codec, off_t bytes); 
</span><span class="s2">extern </span><span class="s1">Py_ssize_t ImagingIncrementalCodecWrite(ImagingIncrementalCodec codec, </span><span class="s2">const void </span><span class="s1">*buffer, size_t bytes); 
</span><span class="s2">extern </span><span class="s1">off_t ImagingIncrementalCodecSeek(ImagingIncrementalCodec codec, off_t bytes); 
</span><span class="s2">extern </span><span class="s1">size_t ImagingIncrementalCodecBytesInBuffer(ImagingIncrementalCodec codec); 
 
</span><span class="s0">/* Errcodes */</span><span class="s1"> 
</span><span class="s2">#define </span><span class="s1">IMAGING_CODEC_END    </span><span class="s4">1</span><span class="s1"> 
</span><span class="s2">#define </span><span class="s1">IMAGING_CODEC_OVERRUN   -</span><span class="s4">1</span><span class="s1"> 
</span><span class="s2">#define </span><span class="s1">IMAGING_CODEC_BROKEN    -</span><span class="s4">2</span><span class="s1"> 
</span><span class="s2">#define </span><span class="s1">IMAGING_CODEC_UNKNOWN   -</span><span class="s4">3</span><span class="s1"> 
</span><span class="s2">#define </span><span class="s1">IMAGING_CODEC_CONFIG    -</span><span class="s4">8</span><span class="s1"> 
</span><span class="s2">#define </span><span class="s1">IMAGING_CODEC_MEMORY    -</span><span class="s4">9</span><span class="s1"> 
 
</span><span class="s2">#if </span><span class="s1">defined(__cplusplus) 
} 
</span><span class="s2">#endif</span><span class="s1"> 
</span></pre>
</body>
</html>