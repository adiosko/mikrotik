<html>
<head>
<title>adapter.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.ln { color: #606366; font-weight: normal; font-style: normal; }
.s0 { color: rgb(204,120,50); }
.s1 { color: rgb(169,183,198); }
.s2 { color: rgb(106,135,89); }
.s3 { color: rgb(98,151,85); font-style: italic; }
.s4 { color: rgb(128,128,128); }
.s5 { color: rgb(104,151,187); }
</style>
</head>
<BODY BGCOLOR="#2b2b2b">
<TABLE CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<TR><TD><CENTER>
<FONT FACE="Arial, Helvetica" COLOR="#000000">
adapter.py</FONT>
</center></TD></TR></TABLE>
<pre>
<span class="s0">import </span><span class="s1">types 
</span><span class="s0">import </span><span class="s1">functools 
 
</span><span class="s0">from </span><span class="s1">pip._vendor.requests.adapters </span><span class="s0">import </span><span class="s1">HTTPAdapter 
 
</span><span class="s0">from </span><span class="s1">.controller </span><span class="s0">import </span><span class="s1">CacheController 
</span><span class="s0">from </span><span class="s1">.cache </span><span class="s0">import </span><span class="s1">DictCache 
</span><span class="s0">from </span><span class="s1">.filewrapper </span><span class="s0">import </span><span class="s1">CallbackFileWrapper 
 
 
</span><span class="s0">class </span><span class="s1">CacheControlAdapter(HTTPAdapter): 
    invalidating_methods = set([</span><span class="s2">'PUT'</span><span class="s0">, </span><span class="s2">'DELETE'</span><span class="s1">]) 
 
    </span><span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">cache=</span><span class="s0">None,</span><span class="s1"> 
                 cache_etags=</span><span class="s0">True,</span><span class="s1"> 
                 controller_class=</span><span class="s0">None,</span><span class="s1"> 
                 serializer=</span><span class="s0">None,</span><span class="s1"> 
                 heuristic=</span><span class="s0">None,</span><span class="s1"> 
                 *args</span><span class="s0">, </span><span class="s1">**kw): 
        super(CacheControlAdapter</span><span class="s0">, </span><span class="s1">self).__init__(*args</span><span class="s0">, </span><span class="s1">**kw) 
        self.cache = cache </span><span class="s0">or </span><span class="s1">DictCache() 
        self.heuristic = heuristic 
 
        controller_factory = controller_class </span><span class="s0">or </span><span class="s1">CacheController 
        self.controller = controller_factory( 
            self.cache</span><span class="s0">,</span><span class="s1"> 
            cache_etags=cache_etags</span><span class="s0">,</span><span class="s1"> 
            serializer=serializer</span><span class="s0">,</span><span class="s1"> 
        ) 
 
    </span><span class="s0">def </span><span class="s1">send(self</span><span class="s0">, </span><span class="s1">request</span><span class="s0">, </span><span class="s1">**kw): 
        </span><span class="s3">&quot;&quot;&quot; 
        Send a request. Use the request information to see if it 
        exists in the cache and cache the response if we need to and can. 
        &quot;&quot;&quot;</span><span class="s1"> 
        </span><span class="s0">if </span><span class="s1">request.method == </span><span class="s2">'GET'</span><span class="s1">: 
            cached_response = self.controller.cached_request(request) 
            </span><span class="s0">if </span><span class="s1">cached_response: 
                </span><span class="s0">return </span><span class="s1">self.build_response(request</span><span class="s0">, </span><span class="s1">cached_response</span><span class="s0">,</span><span class="s1"> 
                                           from_cache=</span><span class="s0">True</span><span class="s1">) 
 
            </span><span class="s4"># check for etags and add headers if appropriate</span><span class="s1"> 
            request.headers.update( 
                self.controller.conditional_headers(request) 
            ) 
 
        resp = super(CacheControlAdapter</span><span class="s0">, </span><span class="s1">self).send(request</span><span class="s0">, </span><span class="s1">**kw) 
 
        </span><span class="s0">return </span><span class="s1">resp 
 
    </span><span class="s0">def </span><span class="s1">build_response(self</span><span class="s0">, </span><span class="s1">request</span><span class="s0">, </span><span class="s1">response</span><span class="s0">, </span><span class="s1">from_cache=</span><span class="s0">False</span><span class="s1">): 
        </span><span class="s3">&quot;&quot;&quot; 
        Build a response by making a request or using the cache. 
 
        This will end up calling send and returning a potentially 
        cached response 
        &quot;&quot;&quot;</span><span class="s1"> 
        </span><span class="s0">if not </span><span class="s1">from_cache </span><span class="s0">and </span><span class="s1">request.method == </span><span class="s2">'GET'</span><span class="s1">: 
            </span><span class="s4"># Check for any heuristics that might update headers</span><span class="s1"> 
            </span><span class="s4"># before trying to cache.</span><span class="s1"> 
            </span><span class="s0">if </span><span class="s1">self.heuristic: 
                response = self.heuristic.apply(response) 
 
            </span><span class="s4"># apply any expiration heuristics</span><span class="s1"> 
            </span><span class="s0">if </span><span class="s1">response.status == </span><span class="s5">304</span><span class="s1">: 
                </span><span class="s4"># We must have sent an ETag request. This could mean</span><span class="s1"> 
                </span><span class="s4"># that we've been expired already or that we simply</span><span class="s1"> 
                </span><span class="s4"># have an etag. In either case, we want to try and</span><span class="s1"> 
                </span><span class="s4"># update the cache if that is the case.</span><span class="s1"> 
                cached_response = self.controller.update_cached_response( 
                    request</span><span class="s0">, </span><span class="s1">response 
                ) 
 
                </span><span class="s0">if </span><span class="s1">cached_response </span><span class="s0">is not </span><span class="s1">response: 
                    from_cache = </span><span class="s0">True</span><span class="s1"> 
 
                </span><span class="s4"># We are done with the server response, read a</span><span class="s1"> 
                </span><span class="s4"># possible response body (compliant servers will</span><span class="s1"> 
                </span><span class="s4"># not return one, but we cannot be 100% sure) and</span><span class="s1"> 
                </span><span class="s4"># release the connection back to the pool.</span><span class="s1"> 
                response.read(decode_content=</span><span class="s0">False</span><span class="s1">) 
                response.release_conn() 
 
                response = cached_response 
 
            </span><span class="s4"># We always cache the 301 responses</span><span class="s1"> 
            </span><span class="s0">elif </span><span class="s1">response.status == </span><span class="s5">301</span><span class="s1">: 
                self.controller.cache_response(request</span><span class="s0">, </span><span class="s1">response) 
            </span><span class="s0">else</span><span class="s1">: 
                </span><span class="s4"># Wrap the response file with a wrapper that will cache the</span><span class="s1"> 
                </span><span class="s4">#   response when the stream has been consumed.</span><span class="s1"> 
                response._fp = CallbackFileWrapper( 
                    response._fp</span><span class="s0">,</span><span class="s1"> 
                    functools.partial( 
                        self.controller.cache_response</span><span class="s0">,</span><span class="s1"> 
                        request</span><span class="s0">,</span><span class="s1"> 
                        response</span><span class="s0">,</span><span class="s1"> 
                    ) 
                ) 
                </span><span class="s0">if </span><span class="s1">response.chunked: 
                    super_update_chunk_length = response._update_chunk_length 
 
                    </span><span class="s0">def </span><span class="s1">_update_chunk_length(self): 
                        super_update_chunk_length() 
                        </span><span class="s0">if </span><span class="s1">self.chunk_left == </span><span class="s5">0</span><span class="s1">: 
                            self._fp._close() 
                    response._update_chunk_length = types.MethodType(_update_chunk_length</span><span class="s0">, </span><span class="s1">response) 
 
        resp = super(CacheControlAdapter</span><span class="s0">, </span><span class="s1">self).build_response( 
            request</span><span class="s0">, </span><span class="s1">response 
        ) 
 
        </span><span class="s4"># See if we should invalidate the cache.</span><span class="s1"> 
        </span><span class="s0">if </span><span class="s1">request.method </span><span class="s0">in </span><span class="s1">self.invalidating_methods </span><span class="s0">and </span><span class="s1">resp.ok: 
            cache_url = self.controller.cache_url(request.url) 
            self.cache.delete(cache_url) 
 
        </span><span class="s4"># Give the request a from_cache attr to let people use it</span><span class="s1"> 
        resp.from_cache = from_cache 
 
        </span><span class="s0">return </span><span class="s1">resp 
 
    </span><span class="s0">def </span><span class="s1">close(self): 
        self.cache.close() 
        super(CacheControlAdapter</span><span class="s0">, </span><span class="s1">self).close() 
</span></pre>
</body>
</html>