<html>
<head>
<title>req_set.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.ln { color: #606366; font-weight: normal; font-style: normal; }
.s0 { color: rgb(204,120,50); }
.s1 { color: rgb(169,183,198); }
.s2 { color: rgb(106,135,89); }
.s3 { color: rgb(98,151,85); font-style: italic; }
.s4 { color: rgb(104,151,187); }
.s5 { color: rgb(128,128,128); }
</style>
</head>
<BODY BGCOLOR="#2b2b2b">
<TABLE CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<TR><TD><CENTER>
<FONT FACE="Arial, Helvetica" COLOR="#000000">
req_set.py</FONT>
</center></TD></TR></TABLE>
<pre>
<span class="s0">from </span><span class="s1">__future__ </span><span class="s0">import </span><span class="s1">absolute_import 
 
</span><span class="s0">from </span><span class="s1">collections </span><span class="s0">import </span><span class="s1">defaultdict 
</span><span class="s0">from </span><span class="s1">itertools </span><span class="s0">import </span><span class="s1">chain 
</span><span class="s0">import </span><span class="s1">logging 
</span><span class="s0">import </span><span class="s1">os 
 
</span><span class="s0">from </span><span class="s1">pip._vendor </span><span class="s0">import </span><span class="s1">pkg_resources 
</span><span class="s0">from </span><span class="s1">pip._vendor </span><span class="s0">import </span><span class="s1">requests 
 
</span><span class="s0">from </span><span class="s1">pip.compat </span><span class="s0">import </span><span class="s1">expanduser 
</span><span class="s0">from </span><span class="s1">pip.download </span><span class="s0">import </span><span class="s1">(is_file_url</span><span class="s0">, </span><span class="s1">is_dir_url</span><span class="s0">, </span><span class="s1">is_vcs_url</span><span class="s0">, </span><span class="s1">url_to_path</span><span class="s0">,</span><span class="s1"> 
                          unpack_url) 
</span><span class="s0">from </span><span class="s1">pip.exceptions </span><span class="s0">import </span><span class="s1">(InstallationError</span><span class="s0">, </span><span class="s1">BestVersionAlreadyInstalled</span><span class="s0">,</span><span class="s1"> 
                            DistributionNotFound</span><span class="s0">, </span><span class="s1">PreviousBuildDirError</span><span class="s0">,</span><span class="s1"> 
                            HashError</span><span class="s0">, </span><span class="s1">HashErrors</span><span class="s0">, </span><span class="s1">HashUnpinned</span><span class="s0">,</span><span class="s1"> 
                            DirectoryUrlHashUnsupported</span><span class="s0">, </span><span class="s1">VcsHashUnsupported</span><span class="s0">,</span><span class="s1"> 
                            UnsupportedPythonVersion) 
</span><span class="s0">from </span><span class="s1">pip.req.req_install </span><span class="s0">import </span><span class="s1">InstallRequirement 
</span><span class="s0">from </span><span class="s1">pip.utils </span><span class="s0">import </span><span class="s1">( 
    display_path</span><span class="s0">, </span><span class="s1">dist_in_usersite</span><span class="s0">, </span><span class="s1">ensure_dir</span><span class="s0">, </span><span class="s1">normalize_path) 
</span><span class="s0">from </span><span class="s1">pip.utils.hashes </span><span class="s0">import </span><span class="s1">MissingHashes 
</span><span class="s0">from </span><span class="s1">pip.utils.logging </span><span class="s0">import </span><span class="s1">indent_log 
</span><span class="s0">from </span><span class="s1">pip.utils.packaging </span><span class="s0">import </span><span class="s1">check_dist_requires_python 
</span><span class="s0">from </span><span class="s1">pip.vcs </span><span class="s0">import </span><span class="s1">vcs 
</span><span class="s0">from </span><span class="s1">pip.wheel </span><span class="s0">import </span><span class="s1">Wheel 
 
logger = logging.getLogger(__name__) 
 
 
</span><span class="s0">class </span><span class="s1">Requirements(object): 
 
    </span><span class="s0">def </span><span class="s1">__init__(self): 
        self._keys = [] 
        self._dict = {} 
 
    </span><span class="s0">def </span><span class="s1">keys(self): 
        </span><span class="s0">return </span><span class="s1">self._keys 
 
    </span><span class="s0">def </span><span class="s1">values(self): 
        </span><span class="s0">return </span><span class="s1">[self._dict[key] </span><span class="s0">for </span><span class="s1">key </span><span class="s0">in </span><span class="s1">self._keys] 
 
    </span><span class="s0">def </span><span class="s1">__contains__(self</span><span class="s0">, </span><span class="s1">item): 
        </span><span class="s0">return </span><span class="s1">item </span><span class="s0">in </span><span class="s1">self._keys 
 
    </span><span class="s0">def </span><span class="s1">__setitem__(self</span><span class="s0">, </span><span class="s1">key</span><span class="s0">, </span><span class="s1">value): 
        </span><span class="s0">if </span><span class="s1">key </span><span class="s0">not in </span><span class="s1">self._keys: 
            self._keys.append(key) 
        self._dict[key] = value 
 
    </span><span class="s0">def </span><span class="s1">__getitem__(self</span><span class="s0">, </span><span class="s1">key): 
        </span><span class="s0">return </span><span class="s1">self._dict[key] 
 
    </span><span class="s0">def </span><span class="s1">__repr__(self): 
        values = [</span><span class="s2">'%s: %s' </span><span class="s1">% (repr(k)</span><span class="s0">, </span><span class="s1">repr(self[k])) </span><span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">self.keys()] 
        </span><span class="s0">return </span><span class="s2">'Requirements({%s})' </span><span class="s1">% </span><span class="s2">', '</span><span class="s1">.join(values) 
 
 
</span><span class="s0">class </span><span class="s1">DistAbstraction(object): 
    </span><span class="s3">&quot;&quot;&quot;Abstracts out the wheel vs non-wheel prepare_files logic. 
 
    The requirements for anything installable are as follows: 
     - we must be able to determine the requirement name 
       (or we can't correctly handle the non-upgrade case). 
     - we must be able to generate a list of run-time dependencies 
       without installing any additional packages (or we would 
       have to either burn time by doing temporary isolated installs 
       or alternatively violate pips 'don't start installing unless 
       all requirements are available' rule - neither of which are 
       desirable). 
     - for packages with setup requirements, we must also be able 
       to determine their requirements without installing additional 
       packages (for the same reason as run-time dependencies) 
     - we must be able to create a Distribution object exposing the 
       above metadata. 
    &quot;&quot;&quot;</span><span class="s1"> 
 
    </span><span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">req_to_install): 
        self.req_to_install = req_to_install 
 
    </span><span class="s0">def </span><span class="s1">dist(self</span><span class="s0">, </span><span class="s1">finder): 
        </span><span class="s3">&quot;&quot;&quot;Return a setuptools Dist object.&quot;&quot;&quot;</span><span class="s1"> 
        </span><span class="s0">raise </span><span class="s1">NotImplementedError(self.dist) 
 
    </span><span class="s0">def </span><span class="s1">prep_for_dist(self): 
        </span><span class="s3">&quot;&quot;&quot;Ensure that we can get a Dist for this requirement.&quot;&quot;&quot;</span><span class="s1"> 
        </span><span class="s0">raise </span><span class="s1">NotImplementedError(self.dist) 
 
 
</span><span class="s0">def </span><span class="s1">make_abstract_dist(req_to_install): 
    </span><span class="s3">&quot;&quot;&quot;Factory to make an abstract dist object. 
 
    Preconditions: Either an editable req with a source_dir, or satisfied_by or 
    a wheel link, or a non-editable req with a source_dir. 
 
    :return: A concrete DistAbstraction. 
    &quot;&quot;&quot;</span><span class="s1"> 
    </span><span class="s0">if </span><span class="s1">req_to_install.editable: 
        </span><span class="s0">return </span><span class="s1">IsSDist(req_to_install) 
    </span><span class="s0">elif </span><span class="s1">req_to_install.link </span><span class="s0">and </span><span class="s1">req_to_install.link.is_wheel: 
        </span><span class="s0">return </span><span class="s1">IsWheel(req_to_install) 
    </span><span class="s0">else</span><span class="s1">: 
        </span><span class="s0">return </span><span class="s1">IsSDist(req_to_install) 
 
 
</span><span class="s0">class </span><span class="s1">IsWheel(DistAbstraction): 
 
    </span><span class="s0">def </span><span class="s1">dist(self</span><span class="s0">, </span><span class="s1">finder): 
        </span><span class="s0">return </span><span class="s1">list(pkg_resources.find_distributions( 
            self.req_to_install.source_dir))[</span><span class="s4">0</span><span class="s1">] 
 
    </span><span class="s0">def </span><span class="s1">prep_for_dist(self): 
        </span><span class="s5"># FIXME:https://github.com/pypa/pip/issues/1112</span><span class="s1"> 
        </span><span class="s0">pass</span><span class="s1"> 
 
 
</span><span class="s0">class </span><span class="s1">IsSDist(DistAbstraction): 
 
    </span><span class="s0">def </span><span class="s1">dist(self</span><span class="s0">, </span><span class="s1">finder): 
        dist = self.req_to_install.get_dist() 
        </span><span class="s5"># FIXME: shouldn't be globally added:</span><span class="s1"> 
        </span><span class="s0">if </span><span class="s1">dist.has_metadata(</span><span class="s2">'dependency_links.txt'</span><span class="s1">): 
            finder.add_dependency_links( 
                dist.get_metadata_lines(</span><span class="s2">'dependency_links.txt'</span><span class="s1">) 
            ) 
        </span><span class="s0">return </span><span class="s1">dist 
 
    </span><span class="s0">def </span><span class="s1">prep_for_dist(self): 
        self.req_to_install.run_egg_info() 
        self.req_to_install.assert_source_matches_version() 
 
 
</span><span class="s0">class </span><span class="s1">Installed(DistAbstraction): 
 
    </span><span class="s0">def </span><span class="s1">dist(self</span><span class="s0">, </span><span class="s1">finder): 
        </span><span class="s0">return </span><span class="s1">self.req_to_install.satisfied_by 
 
    </span><span class="s0">def </span><span class="s1">prep_for_dist(self): 
        </span><span class="s0">pass</span><span class="s1"> 
 
 
</span><span class="s0">class </span><span class="s1">RequirementSet(object): 
 
    </span><span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">build_dir</span><span class="s0">, </span><span class="s1">src_dir</span><span class="s0">, </span><span class="s1">download_dir</span><span class="s0">, </span><span class="s1">upgrade=</span><span class="s0">False,</span><span class="s1"> 
                 upgrade_strategy=</span><span class="s0">None, </span><span class="s1">ignore_installed=</span><span class="s0">False, </span><span class="s1">as_egg=</span><span class="s0">False,</span><span class="s1"> 
                 target_dir=</span><span class="s0">None, </span><span class="s1">ignore_dependencies=</span><span class="s0">False,</span><span class="s1"> 
                 force_reinstall=</span><span class="s0">False, </span><span class="s1">use_user_site=</span><span class="s0">False, </span><span class="s1">session=</span><span class="s0">None,</span><span class="s1"> 
                 pycompile=</span><span class="s0">True, </span><span class="s1">isolated=</span><span class="s0">False, </span><span class="s1">wheel_download_dir=</span><span class="s0">None,</span><span class="s1"> 
                 wheel_cache=</span><span class="s0">None, </span><span class="s1">require_hashes=</span><span class="s0">False,</span><span class="s1"> 
                 ignore_requires_python=</span><span class="s0">False</span><span class="s1">): 
        </span><span class="s3">&quot;&quot;&quot;Create a RequirementSet. 
 
        :param wheel_download_dir: Where still-packed .whl files should be 
            written to. If None they are written to the download_dir parameter. 
            Separate to download_dir to permit only keeping wheel archives for 
            pip wheel. 
        :param download_dir: Where still packed archives should be written to. 
            If None they are not saved, and are deleted immediately after 
            unpacking. 
        :param wheel_cache: The pip wheel cache, for passing to 
            InstallRequirement. 
        &quot;&quot;&quot;</span><span class="s1"> 
        </span><span class="s0">if </span><span class="s1">session </span><span class="s0">is None</span><span class="s1">: 
            </span><span class="s0">raise </span><span class="s1">TypeError( 
                </span><span class="s2">&quot;RequirementSet() missing 1 required keyword argument: &quot;</span><span class="s1"> 
                </span><span class="s2">&quot;'session'&quot;</span><span class="s1"> 
            ) 
 
        self.build_dir = build_dir 
        self.src_dir = src_dir 
        </span><span class="s5"># XXX: download_dir and wheel_download_dir overlap semantically and may</span><span class="s1"> 
        </span><span class="s5"># be combined if we're willing to have non-wheel archives present in</span><span class="s1"> 
        </span><span class="s5"># the wheelhouse output by 'pip wheel'.</span><span class="s1"> 
        self.download_dir = download_dir 
        self.upgrade = upgrade 
        self.upgrade_strategy = upgrade_strategy 
        self.ignore_installed = ignore_installed 
        self.force_reinstall = force_reinstall 
        self.requirements = Requirements() 
        </span><span class="s5"># Mapping of alias: real_name</span><span class="s1"> 
        self.requirement_aliases = {} 
        self.unnamed_requirements = [] 
        self.ignore_dependencies = ignore_dependencies 
        self.ignore_requires_python = ignore_requires_python 
        self.successfully_downloaded = [] 
        self.successfully_installed = [] 
        self.reqs_to_cleanup = [] 
        self.as_egg = as_egg 
        self.use_user_site = use_user_site 
        self.target_dir = target_dir  </span><span class="s5"># set from --target option</span><span class="s1"> 
        self.session = session 
        self.pycompile = pycompile 
        self.isolated = isolated 
        </span><span class="s0">if </span><span class="s1">wheel_download_dir: 
            wheel_download_dir = normalize_path(wheel_download_dir) 
        self.wheel_download_dir = wheel_download_dir 
        self._wheel_cache = wheel_cache 
        self.require_hashes = require_hashes 
        </span><span class="s5"># Maps from install_req -&gt; dependencies_of_install_req</span><span class="s1"> 
        self._dependencies = defaultdict(list) 
 
    </span><span class="s0">def </span><span class="s1">__str__(self): 
        reqs = [req </span><span class="s0">for </span><span class="s1">req </span><span class="s0">in </span><span class="s1">self.requirements.values() 
                </span><span class="s0">if not </span><span class="s1">req.comes_from] 
        reqs.sort(key=</span><span class="s0">lambda </span><span class="s1">req: req.name.lower()) 
        </span><span class="s0">return </span><span class="s2">' '</span><span class="s1">.join([str(req.req) </span><span class="s0">for </span><span class="s1">req </span><span class="s0">in </span><span class="s1">reqs]) 
 
    </span><span class="s0">def </span><span class="s1">__repr__(self): 
        reqs = [req </span><span class="s0">for </span><span class="s1">req </span><span class="s0">in </span><span class="s1">self.requirements.values()] 
        reqs.sort(key=</span><span class="s0">lambda </span><span class="s1">req: req.name.lower()) 
        reqs_str = </span><span class="s2">', '</span><span class="s1">.join([str(req.req) </span><span class="s0">for </span><span class="s1">req </span><span class="s0">in </span><span class="s1">reqs]) 
        </span><span class="s0">return </span><span class="s1">(</span><span class="s2">'&lt;%s object; %d requirement(s): %s&gt;'</span><span class="s1"> 
                % (self.__class__.__name__</span><span class="s0">, </span><span class="s1">len(reqs)</span><span class="s0">, </span><span class="s1">reqs_str)) 
 
    </span><span class="s0">def </span><span class="s1">add_requirement(self</span><span class="s0">, </span><span class="s1">install_req</span><span class="s0">, </span><span class="s1">parent_req_name=</span><span class="s0">None,</span><span class="s1"> 
                        extras_requested=</span><span class="s0">None</span><span class="s1">): 
        </span><span class="s3">&quot;&quot;&quot;Add install_req as a requirement to install. 
 
        :param parent_req_name: The name of the requirement that needed this 
            added. The name is used because when multiple unnamed requirements 
            resolve to the same name, we could otherwise end up with dependency 
            links that point outside the Requirements set. parent_req must 
            already be added. Note that None implies that this is a user 
            supplied requirement, vs an inferred one. 
        :param extras_requested: an iterable of extras used to evaluate the 
            environement markers. 
        :return: Additional requirements to scan. That is either [] if 
            the requirement is not applicable, or [install_req] if the 
            requirement is applicable and has just been added. 
        &quot;&quot;&quot;</span><span class="s1"> 
        name = install_req.name 
        </span><span class="s0">if not </span><span class="s1">install_req.match_markers(extras_requested): 
            logger.warning(</span><span class="s2">&quot;Ignoring %s: markers '%s' don't match your &quot;</span><span class="s1"> 
                           </span><span class="s2">&quot;environment&quot;</span><span class="s0">, </span><span class="s1">install_req.name</span><span class="s0">,</span><span class="s1"> 
                           install_req.markers) 
            </span><span class="s0">return </span><span class="s1">[] 
 
        </span><span class="s5"># This check has to come after we filter requirements with the</span><span class="s1"> 
        </span><span class="s5"># environment markers.</span><span class="s1"> 
        </span><span class="s0">if </span><span class="s1">install_req.link </span><span class="s0">and </span><span class="s1">install_req.link.is_wheel: 
            wheel = Wheel(install_req.link.filename) 
            </span><span class="s0">if not </span><span class="s1">wheel.supported(): 
                </span><span class="s0">raise </span><span class="s1">InstallationError( 
                    </span><span class="s2">&quot;%s is not a supported wheel on this platform.&quot; </span><span class="s1">% 
                    wheel.filename 
                ) 
 
        install_req.as_egg = self.as_egg 
        install_req.use_user_site = self.use_user_site 
        install_req.target_dir = self.target_dir 
        install_req.pycompile = self.pycompile 
        install_req.is_direct = (parent_req_name </span><span class="s0">is None</span><span class="s1">) 
 
        </span><span class="s0">if not </span><span class="s1">name: 
            </span><span class="s5"># url or path requirement w/o an egg fragment</span><span class="s1"> 
            self.unnamed_requirements.append(install_req) 
            </span><span class="s0">return </span><span class="s1">[install_req] 
        </span><span class="s0">else</span><span class="s1">: 
            </span><span class="s0">try</span><span class="s1">: 
                existing_req = self.get_requirement(name) 
            </span><span class="s0">except </span><span class="s1">KeyError: 
                existing_req = </span><span class="s0">None</span><span class="s1"> 
            </span><span class="s0">if </span><span class="s1">(parent_req_name </span><span class="s0">is None and </span><span class="s1">existing_req </span><span class="s0">and not</span><span class="s1"> 
                    existing_req.constraint </span><span class="s0">and</span><span class="s1"> 
                    existing_req.extras == install_req.extras </span><span class="s0">and not</span><span class="s1"> 
                    existing_req.req.specifier == install_req.req.specifier): 
                </span><span class="s0">raise </span><span class="s1">InstallationError( 
                    </span><span class="s2">'Double requirement given: %s (already in %s, name=%r)'</span><span class="s1"> 
                    % (install_req</span><span class="s0">, </span><span class="s1">existing_req</span><span class="s0">, </span><span class="s1">name)) 
            </span><span class="s0">if not </span><span class="s1">existing_req: 
                </span><span class="s5"># Add requirement</span><span class="s1"> 
                self.requirements[name] = install_req 
                </span><span class="s5"># FIXME: what about other normalizations?  E.g., _ vs. -?</span><span class="s1"> 
                </span><span class="s0">if </span><span class="s1">name.lower() != name: 
                    self.requirement_aliases[name.lower()] = name 
                result = [install_req] 
            </span><span class="s0">else</span><span class="s1">: 
                </span><span class="s5"># Assume there's no need to scan, and that we've already</span><span class="s1"> 
                </span><span class="s5"># encountered this for scanning.</span><span class="s1"> 
                result = [] 
                </span><span class="s0">if not </span><span class="s1">install_req.constraint </span><span class="s0">and </span><span class="s1">existing_req.constraint: 
                    </span><span class="s0">if </span><span class="s1">(install_req.link </span><span class="s0">and not </span><span class="s1">(existing_req.link </span><span class="s0">and</span><span class="s1"> 
                       install_req.link.path == existing_req.link.path)): 
                        self.reqs_to_cleanup.append(install_req) 
                        </span><span class="s0">raise </span><span class="s1">InstallationError( 
                            </span><span class="s2">&quot;Could not satisfy constraints for '%s': &quot;</span><span class="s1"> 
                            </span><span class="s2">&quot;installation from path or url cannot be &quot;</span><span class="s1"> 
                            </span><span class="s2">&quot;constrained to a version&quot; </span><span class="s1">% name) 
                    </span><span class="s5"># If we're now installing a constraint, mark the existing</span><span class="s1"> 
                    </span><span class="s5"># object for real installation.</span><span class="s1"> 
                    existing_req.constraint = </span><span class="s0">False</span><span class="s1"> 
                    existing_req.extras = tuple( 
                        sorted(set(existing_req.extras).union( 
                               set(install_req.extras)))) 
                    logger.debug(</span><span class="s2">&quot;Setting %s extras to: %s&quot;</span><span class="s0">,</span><span class="s1"> 
                                 existing_req</span><span class="s0">, </span><span class="s1">existing_req.extras) 
                    </span><span class="s5"># And now we need to scan this.</span><span class="s1"> 
                    result = [existing_req] 
                </span><span class="s5"># Canonicalise to the already-added object for the backref</span><span class="s1"> 
                </span><span class="s5"># check below.</span><span class="s1"> 
                install_req = existing_req 
            </span><span class="s0">if </span><span class="s1">parent_req_name: 
                parent_req = self.get_requirement(parent_req_name) 
                self._dependencies[parent_req].append(install_req) 
            </span><span class="s0">return </span><span class="s1">result 
 
    </span><span class="s0">def </span><span class="s1">has_requirement(self</span><span class="s0">, </span><span class="s1">project_name): 
        name = project_name.lower() 
        </span><span class="s0">if </span><span class="s1">(name </span><span class="s0">in </span><span class="s1">self.requirements </span><span class="s0">and</span><span class="s1"> 
           </span><span class="s0">not </span><span class="s1">self.requirements[name].constraint </span><span class="s0">or</span><span class="s1"> 
           name </span><span class="s0">in </span><span class="s1">self.requirement_aliases </span><span class="s0">and</span><span class="s1"> 
           </span><span class="s0">not </span><span class="s1">self.requirements[self.requirement_aliases[name]].constraint): 
            </span><span class="s0">return True</span><span class="s1"> 
        </span><span class="s0">return False</span><span class="s1"> 
 
    @property 
    </span><span class="s0">def </span><span class="s1">has_requirements(self): 
        </span><span class="s0">return </span><span class="s1">list(req </span><span class="s0">for </span><span class="s1">req </span><span class="s0">in </span><span class="s1">self.requirements.values() </span><span class="s0">if not</span><span class="s1"> 
                    req.constraint) </span><span class="s0">or </span><span class="s1">self.unnamed_requirements 
 
    @property 
    </span><span class="s0">def </span><span class="s1">is_download(self): 
        </span><span class="s0">if </span><span class="s1">self.download_dir: 
            self.download_dir = expanduser(self.download_dir) 
            </span><span class="s0">if </span><span class="s1">os.path.exists(self.download_dir): 
                </span><span class="s0">return True</span><span class="s1"> 
            </span><span class="s0">else</span><span class="s1">: 
                logger.critical(</span><span class="s2">'Could not find download directory'</span><span class="s1">) 
                </span><span class="s0">raise </span><span class="s1">InstallationError( 
                    </span><span class="s2">&quot;Could not find or access download directory '%s'&quot;</span><span class="s1"> 
                    % display_path(self.download_dir)) 
        </span><span class="s0">return False</span><span class="s1"> 
 
    </span><span class="s0">def </span><span class="s1">get_requirement(self</span><span class="s0">, </span><span class="s1">project_name): 
        </span><span class="s0">for </span><span class="s1">name </span><span class="s0">in </span><span class="s1">project_name</span><span class="s0">, </span><span class="s1">project_name.lower(): 
            </span><span class="s0">if </span><span class="s1">name </span><span class="s0">in </span><span class="s1">self.requirements: 
                </span><span class="s0">return </span><span class="s1">self.requirements[name] 
            </span><span class="s0">if </span><span class="s1">name </span><span class="s0">in </span><span class="s1">self.requirement_aliases: 
                </span><span class="s0">return </span><span class="s1">self.requirements[self.requirement_aliases[name]] 
        </span><span class="s0">raise </span><span class="s1">KeyError(</span><span class="s2">&quot;No project with the name %r&quot; </span><span class="s1">% project_name) 
 
    </span><span class="s0">def </span><span class="s1">uninstall(self</span><span class="s0">, </span><span class="s1">auto_confirm=</span><span class="s0">False</span><span class="s1">): 
        </span><span class="s0">for </span><span class="s1">req </span><span class="s0">in </span><span class="s1">self.requirements.values(): 
            </span><span class="s0">if </span><span class="s1">req.constraint: 
                </span><span class="s0">continue</span><span class="s1"> 
            req.uninstall(auto_confirm=auto_confirm) 
            req.commit_uninstall() 
 
    </span><span class="s0">def </span><span class="s1">prepare_files(self</span><span class="s0">, </span><span class="s1">finder): 
        </span><span class="s3">&quot;&quot;&quot; 
        Prepare process. Create temp directories, download and/or unpack files. 
        &quot;&quot;&quot;</span><span class="s1"> 
        </span><span class="s5"># make the wheelhouse</span><span class="s1"> 
        </span><span class="s0">if </span><span class="s1">self.wheel_download_dir: 
            ensure_dir(self.wheel_download_dir) 
 
        </span><span class="s5"># If any top-level requirement has a hash specified, enter</span><span class="s1"> 
        </span><span class="s5"># hash-checking mode, which requires hashes from all.</span><span class="s1"> 
        root_reqs = self.unnamed_requirements + self.requirements.values() 
        require_hashes = (self.require_hashes </span><span class="s0">or</span><span class="s1"> 
                          any(req.has_hash_options </span><span class="s0">for </span><span class="s1">req </span><span class="s0">in </span><span class="s1">root_reqs)) 
        </span><span class="s0">if </span><span class="s1">require_hashes </span><span class="s0">and </span><span class="s1">self.as_egg: 
            </span><span class="s0">raise </span><span class="s1">InstallationError( 
                </span><span class="s2">'--egg is not allowed with --require-hashes mode, since it '</span><span class="s1"> 
                </span><span class="s2">'delegates dependency resolution to setuptools and could thus '</span><span class="s1"> 
                </span><span class="s2">'result in installation of unhashed packages.'</span><span class="s1">) 
 
        </span><span class="s5"># Actually prepare the files, and collect any exceptions. Most hash</span><span class="s1"> 
        </span><span class="s5"># exceptions cannot be checked ahead of time, because</span><span class="s1"> 
        </span><span class="s5"># req.populate_link() needs to be called before we can make decisions</span><span class="s1"> 
        </span><span class="s5"># based on link type.</span><span class="s1"> 
        discovered_reqs = [] 
        hash_errors = HashErrors() 
        </span><span class="s0">for </span><span class="s1">req </span><span class="s0">in </span><span class="s1">chain(root_reqs</span><span class="s0">, </span><span class="s1">discovered_reqs): 
            </span><span class="s0">try</span><span class="s1">: 
                discovered_reqs.extend(self._prepare_file( 
                    finder</span><span class="s0">,</span><span class="s1"> 
                    req</span><span class="s0">,</span><span class="s1"> 
                    require_hashes=require_hashes</span><span class="s0">,</span><span class="s1"> 
                    ignore_dependencies=self.ignore_dependencies)) 
            </span><span class="s0">except </span><span class="s1">HashError </span><span class="s0">as </span><span class="s1">exc: 
                exc.req = req 
                hash_errors.append(exc) 
 
        </span><span class="s0">if </span><span class="s1">hash_errors: 
            </span><span class="s0">raise </span><span class="s1">hash_errors 
 
    </span><span class="s0">def </span><span class="s1">_is_upgrade_allowed(self</span><span class="s0">, </span><span class="s1">req): 
        </span><span class="s0">return </span><span class="s1">self.upgrade </span><span class="s0">and </span><span class="s1">( 
            self.upgrade_strategy == </span><span class="s2">&quot;eager&quot; </span><span class="s0">or </span><span class="s1">( 
                self.upgrade_strategy == </span><span class="s2">&quot;only-if-needed&quot; </span><span class="s0">and </span><span class="s1">req.is_direct 
            ) 
        ) 
 
    </span><span class="s0">def </span><span class="s1">_check_skip_installed(self</span><span class="s0">, </span><span class="s1">req_to_install</span><span class="s0">, </span><span class="s1">finder): 
        </span><span class="s3">&quot;&quot;&quot;Check if req_to_install should be skipped. 
 
        This will check if the req is installed, and whether we should upgrade 
        or reinstall it, taking into account all the relevant user options. 
 
        After calling this req_to_install will only have satisfied_by set to 
        None if the req_to_install is to be upgraded/reinstalled etc. Any 
        other value will be a dist recording the current thing installed that 
        satisfies the requirement. 
 
        Note that for vcs urls and the like we can't assess skipping in this 
        routine - we simply identify that we need to pull the thing down, 
        then later on it is pulled down and introspected to assess upgrade/ 
        reinstalls etc. 
 
        :return: A text reason for why it was skipped, or None. 
        &quot;&quot;&quot;</span><span class="s1"> 
        </span><span class="s5"># Check whether to upgrade/reinstall this req or not.</span><span class="s1"> 
        req_to_install.check_if_exists() 
        </span><span class="s0">if </span><span class="s1">req_to_install.satisfied_by: 
            upgrade_allowed = self._is_upgrade_allowed(req_to_install) 
 
            </span><span class="s5"># Is the best version is installed.</span><span class="s1"> 
            best_installed = </span><span class="s0">False</span><span class="s1"> 
 
            </span><span class="s0">if </span><span class="s1">upgrade_allowed: 
                </span><span class="s5"># For link based requirements we have to pull the</span><span class="s1"> 
                </span><span class="s5"># tree down and inspect to assess the version #, so</span><span class="s1"> 
                </span><span class="s5"># its handled way down.</span><span class="s1"> 
                </span><span class="s0">if not </span><span class="s1">(self.force_reinstall </span><span class="s0">or </span><span class="s1">req_to_install.link): 
                    </span><span class="s0">try</span><span class="s1">: 
                        finder.find_requirement( 
                            req_to_install</span><span class="s0">, </span><span class="s1">upgrade_allowed) 
                    </span><span class="s0">except </span><span class="s1">BestVersionAlreadyInstalled: 
                        best_installed = </span><span class="s0">True</span><span class="s1"> 
                    </span><span class="s0">except </span><span class="s1">DistributionNotFound: 
                        </span><span class="s5"># No distribution found, so we squash the</span><span class="s1"> 
                        </span><span class="s5"># error - it will be raised later when we</span><span class="s1"> 
                        </span><span class="s5"># re-try later to do the install.</span><span class="s1"> 
                        </span><span class="s5"># Why don't we just raise here?</span><span class="s1"> 
                        </span><span class="s0">pass</span><span class="s1"> 
 
                </span><span class="s0">if not </span><span class="s1">best_installed: 
                    </span><span class="s5"># don't uninstall conflict if user install and</span><span class="s1"> 
                    </span><span class="s5"># conflict is not user install</span><span class="s1"> 
                    </span><span class="s0">if not </span><span class="s1">(self.use_user_site </span><span class="s0">and not</span><span class="s1"> 
                            dist_in_usersite(req_to_install.satisfied_by)): 
                        req_to_install.conflicts_with = \ 
                            req_to_install.satisfied_by 
                    req_to_install.satisfied_by = </span><span class="s0">None</span><span class="s1"> 
 
            </span><span class="s5"># Figure out a nice message to say why we're skipping this.</span><span class="s1"> 
            </span><span class="s0">if </span><span class="s1">best_installed: 
                skip_reason = </span><span class="s2">'already up-to-date'</span><span class="s1"> 
            </span><span class="s0">elif </span><span class="s1">self.upgrade_strategy == </span><span class="s2">&quot;only-if-needed&quot;</span><span class="s1">: 
                skip_reason = </span><span class="s2">'not upgraded as not directly required'</span><span class="s1"> 
            </span><span class="s0">else</span><span class="s1">: 
                skip_reason = </span><span class="s2">'already satisfied'</span><span class="s1"> 
 
            </span><span class="s0">return </span><span class="s1">skip_reason 
        </span><span class="s0">else</span><span class="s1">: 
            </span><span class="s0">return None</span><span class="s1"> 
 
    </span><span class="s0">def </span><span class="s1">_prepare_file(self</span><span class="s0">,</span><span class="s1"> 
                      finder</span><span class="s0">,</span><span class="s1"> 
                      req_to_install</span><span class="s0">,</span><span class="s1"> 
                      require_hashes=</span><span class="s0">False,</span><span class="s1"> 
                      ignore_dependencies=</span><span class="s0">False</span><span class="s1">): 
        </span><span class="s3">&quot;&quot;&quot;Prepare a single requirements file. 
 
        :return: A list of additional InstallRequirements to also install. 
        &quot;&quot;&quot;</span><span class="s1"> 
        </span><span class="s5"># Tell user what we are doing for this requirement:</span><span class="s1"> 
        </span><span class="s5"># obtain (editable), skipping, processing (local url), collecting</span><span class="s1"> 
        </span><span class="s5"># (remote url or package name)</span><span class="s1"> 
        </span><span class="s0">if </span><span class="s1">req_to_install.constraint </span><span class="s0">or </span><span class="s1">req_to_install.prepared: 
            </span><span class="s0">return </span><span class="s1">[] 
 
        req_to_install.prepared = </span><span class="s0">True</span><span class="s1"> 
 
        </span><span class="s5"># ###################### #</span><span class="s1"> 
        </span><span class="s5"># # print log messages # #</span><span class="s1"> 
        </span><span class="s5"># ###################### #</span><span class="s1"> 
        </span><span class="s0">if </span><span class="s1">req_to_install.editable: 
            logger.info(</span><span class="s2">'Obtaining %s'</span><span class="s0">, </span><span class="s1">req_to_install) 
        </span><span class="s0">else</span><span class="s1">: 
            </span><span class="s5"># satisfied_by is only evaluated by calling _check_skip_installed,</span><span class="s1"> 
            </span><span class="s5"># so it must be None here.</span><span class="s1"> 
            </span><span class="s0">assert </span><span class="s1">req_to_install.satisfied_by </span><span class="s0">is None</span><span class="s1"> 
            </span><span class="s0">if not </span><span class="s1">self.ignore_installed: 
                skip_reason = self._check_skip_installed( 
                    req_to_install</span><span class="s0">, </span><span class="s1">finder) 
 
            </span><span class="s0">if </span><span class="s1">req_to_install.satisfied_by: 
                </span><span class="s0">assert </span><span class="s1">skip_reason </span><span class="s0">is not None, </span><span class="s1">( 
                    </span><span class="s2">'_check_skip_installed returned None but '</span><span class="s1"> 
                    </span><span class="s2">'req_to_install.satisfied_by is set to %r'</span><span class="s1"> 
                    % (req_to_install.satisfied_by</span><span class="s0">,</span><span class="s1">)) 
                logger.info( 
                    </span><span class="s2">'Requirement %s: %s'</span><span class="s0">, </span><span class="s1">skip_reason</span><span class="s0">,</span><span class="s1"> 
                    req_to_install) 
            </span><span class="s0">else</span><span class="s1">: 
                </span><span class="s0">if </span><span class="s1">(req_to_install.link </span><span class="s0">and</span><span class="s1"> 
                        req_to_install.link.scheme == </span><span class="s2">'file'</span><span class="s1">): 
                    path = url_to_path(req_to_install.link.url) 
                    logger.info(</span><span class="s2">'Processing %s'</span><span class="s0">, </span><span class="s1">display_path(path)) 
                </span><span class="s0">else</span><span class="s1">: 
                    logger.info(</span><span class="s2">'Collecting %s'</span><span class="s0">, </span><span class="s1">req_to_install) 
 
        </span><span class="s0">with </span><span class="s1">indent_log(): 
            </span><span class="s5"># ################################ #</span><span class="s1"> 
            </span><span class="s5"># # vcs update or unpack archive # #</span><span class="s1"> 
            </span><span class="s5"># ################################ #</span><span class="s1"> 
            </span><span class="s0">if </span><span class="s1">req_to_install.editable: 
                </span><span class="s0">if </span><span class="s1">require_hashes: 
                    </span><span class="s0">raise </span><span class="s1">InstallationError( 
                        </span><span class="s2">'The editable requirement %s cannot be installed when '</span><span class="s1"> 
                        </span><span class="s2">'requiring hashes, because there is no single file to '</span><span class="s1"> 
                        </span><span class="s2">'hash.' </span><span class="s1">% req_to_install) 
                req_to_install.ensure_has_source_dir(self.src_dir) 
                req_to_install.update_editable(</span><span class="s0">not </span><span class="s1">self.is_download) 
                abstract_dist = make_abstract_dist(req_to_install) 
                abstract_dist.prep_for_dist() 
                </span><span class="s0">if </span><span class="s1">self.is_download: 
                    req_to_install.archive(self.download_dir) 
                req_to_install.check_if_exists() 
            </span><span class="s0">elif </span><span class="s1">req_to_install.satisfied_by: 
                </span><span class="s0">if </span><span class="s1">require_hashes: 
                    logger.debug( 
                        </span><span class="s2">'Since it is already installed, we are trusting this '</span><span class="s1"> 
                        </span><span class="s2">'package without checking its hash. To ensure a '</span><span class="s1"> 
                        </span><span class="s2">'completely repeatable environment, install into an '</span><span class="s1"> 
                        </span><span class="s2">'empty virtualenv.'</span><span class="s1">) 
                abstract_dist = Installed(req_to_install) 
            </span><span class="s0">else</span><span class="s1">: 
                </span><span class="s5"># @@ if filesystem packages are not marked</span><span class="s1"> 
                </span><span class="s5"># editable in a req, a non deterministic error</span><span class="s1"> 
                </span><span class="s5"># occurs when the script attempts to unpack the</span><span class="s1"> 
                </span><span class="s5"># build directory</span><span class="s1"> 
                req_to_install.ensure_has_source_dir(self.build_dir) 
                </span><span class="s5"># If a checkout exists, it's unwise to keep going.  version</span><span class="s1"> 
                </span><span class="s5"># inconsistencies are logged later, but do not fail the</span><span class="s1"> 
                </span><span class="s5"># installation.</span><span class="s1"> 
                </span><span class="s5"># FIXME: this won't upgrade when there's an existing</span><span class="s1"> 
                </span><span class="s5"># package unpacked in `req_to_install.source_dir`</span><span class="s1"> 
                </span><span class="s0">if </span><span class="s1">os.path.exists( 
                        os.path.join(req_to_install.source_dir</span><span class="s0">, </span><span class="s2">'setup.py'</span><span class="s1">)): 
                    </span><span class="s0">raise </span><span class="s1">PreviousBuildDirError( 
                        </span><span class="s2">&quot;pip can't proceed with requirements '%s' due to a&quot;</span><span class="s1"> 
                        </span><span class="s2">&quot; pre-existing build directory (%s). This is &quot;</span><span class="s1"> 
                        </span><span class="s2">&quot;likely due to a previous installation that failed&quot;</span><span class="s1"> 
                        </span><span class="s2">&quot;. pip is being responsible and not assuming it &quot;</span><span class="s1"> 
                        </span><span class="s2">&quot;can delete this. Please delete it and try again.&quot;</span><span class="s1"> 
                        % (req_to_install</span><span class="s0">, </span><span class="s1">req_to_install.source_dir) 
                    ) 
                req_to_install.populate_link( 
                    finder</span><span class="s0">,</span><span class="s1"> 
                    self._is_upgrade_allowed(req_to_install)</span><span class="s0">,</span><span class="s1"> 
                    require_hashes 
                ) 
                </span><span class="s5"># We can't hit this spot and have populate_link return None.</span><span class="s1"> 
                </span><span class="s5"># req_to_install.satisfied_by is None here (because we're</span><span class="s1"> 
                </span><span class="s5"># guarded) and upgrade has no impact except when satisfied_by</span><span class="s1"> 
                </span><span class="s5"># is not None.</span><span class="s1"> 
                </span><span class="s5"># Then inside find_requirement existing_applicable -&gt; False</span><span class="s1"> 
                </span><span class="s5"># If no new versions are found, DistributionNotFound is raised,</span><span class="s1"> 
                </span><span class="s5"># otherwise a result is guaranteed.</span><span class="s1"> 
                </span><span class="s0">assert </span><span class="s1">req_to_install.link 
                link = req_to_install.link 
 
                </span><span class="s5"># Now that we have the real link, we can tell what kind of</span><span class="s1"> 
                </span><span class="s5"># requirements we have and raise some more informative errors</span><span class="s1"> 
                </span><span class="s5"># than otherwise. (For example, we can raise VcsHashUnsupported</span><span class="s1"> 
                </span><span class="s5"># for a VCS URL rather than HashMissing.)</span><span class="s1"> 
                </span><span class="s0">if </span><span class="s1">require_hashes: 
                    </span><span class="s5"># We could check these first 2 conditions inside</span><span class="s1"> 
                    </span><span class="s5"># unpack_url and save repetition of conditions, but then</span><span class="s1"> 
                    </span><span class="s5"># we would report less-useful error messages for</span><span class="s1"> 
                    </span><span class="s5"># unhashable requirements, complaining that there's no</span><span class="s1"> 
                    </span><span class="s5"># hash provided.</span><span class="s1"> 
                    </span><span class="s0">if </span><span class="s1">is_vcs_url(link): 
                        </span><span class="s0">raise </span><span class="s1">VcsHashUnsupported() 
                    </span><span class="s0">elif </span><span class="s1">is_file_url(link) </span><span class="s0">and </span><span class="s1">is_dir_url(link): 
                        </span><span class="s0">raise </span><span class="s1">DirectoryUrlHashUnsupported() 
                    </span><span class="s0">if </span><span class="s1">(</span><span class="s0">not </span><span class="s1">req_to_install.original_link </span><span class="s0">and</span><span class="s1"> 
                            </span><span class="s0">not </span><span class="s1">req_to_install.is_pinned): 
                        </span><span class="s5"># Unpinned packages are asking for trouble when a new</span><span class="s1"> 
                        </span><span class="s5"># version is uploaded. This isn't a security check, but</span><span class="s1"> 
                        </span><span class="s5"># it saves users a surprising hash mismatch in the</span><span class="s1"> 
                        </span><span class="s5"># future.</span><span class="s1"> 
                        </span><span class="s5">#</span><span class="s1"> 
                        </span><span class="s5"># file:/// URLs aren't pinnable, so don't complain</span><span class="s1"> 
                        </span><span class="s5"># about them not being pinned.</span><span class="s1"> 
                        </span><span class="s0">raise </span><span class="s1">HashUnpinned() 
                hashes = req_to_install.hashes( 
                    trust_internet=</span><span class="s0">not </span><span class="s1">require_hashes) 
                </span><span class="s0">if </span><span class="s1">require_hashes </span><span class="s0">and not </span><span class="s1">hashes: 
                    </span><span class="s5"># Known-good hashes are missing for this requirement, so</span><span class="s1"> 
                    </span><span class="s5"># shim it with a facade object that will provoke hash</span><span class="s1"> 
                    </span><span class="s5"># computation and then raise a HashMissing exception</span><span class="s1"> 
                    </span><span class="s5"># showing the user what the hash should be.</span><span class="s1"> 
                    hashes = MissingHashes() 
 
                </span><span class="s0">try</span><span class="s1">: 
                    download_dir = self.download_dir 
                    </span><span class="s5"># We always delete unpacked sdists after pip ran.</span><span class="s1"> 
                    autodelete_unpacked = </span><span class="s0">True</span><span class="s1"> 
                    </span><span class="s0">if </span><span class="s1">req_to_install.link.is_wheel \ 
                            </span><span class="s0">and </span><span class="s1">self.wheel_download_dir: 
                        </span><span class="s5"># when doing 'pip wheel` we download wheels to a</span><span class="s1"> 
                        </span><span class="s5"># dedicated dir.</span><span class="s1"> 
                        download_dir = self.wheel_download_dir 
                    </span><span class="s0">if </span><span class="s1">req_to_install.link.is_wheel: 
                        </span><span class="s0">if </span><span class="s1">download_dir: 
                            </span><span class="s5"># When downloading, we only unpack wheels to get</span><span class="s1"> 
                            </span><span class="s5"># metadata.</span><span class="s1"> 
                            autodelete_unpacked = </span><span class="s0">True</span><span class="s1"> 
                        </span><span class="s0">else</span><span class="s1">: 
                            </span><span class="s5"># When installing a wheel, we use the unpacked</span><span class="s1"> 
                            </span><span class="s5"># wheel.</span><span class="s1"> 
                            autodelete_unpacked = </span><span class="s0">False</span><span class="s1"> 
                    unpack_url( 
                        req_to_install.link</span><span class="s0">, </span><span class="s1">req_to_install.source_dir</span><span class="s0">,</span><span class="s1"> 
                        download_dir</span><span class="s0">, </span><span class="s1">autodelete_unpacked</span><span class="s0">,</span><span class="s1"> 
                        session=self.session</span><span class="s0">, </span><span class="s1">hashes=hashes) 
                </span><span class="s0">except </span><span class="s1">requests.HTTPError </span><span class="s0">as </span><span class="s1">exc: 
                    logger.critical( 
                        </span><span class="s2">'Could not install requirement %s because '</span><span class="s1"> 
                        </span><span class="s2">'of error %s'</span><span class="s0">,</span><span class="s1"> 
                        req_to_install</span><span class="s0">,</span><span class="s1"> 
                        exc</span><span class="s0">,</span><span class="s1"> 
                    ) 
                    </span><span class="s0">raise </span><span class="s1">InstallationError( 
                        </span><span class="s2">'Could not install requirement %s because '</span><span class="s1"> 
                        </span><span class="s2">'of HTTP error %s for URL %s' </span><span class="s1">% 
                        (req_to_install</span><span class="s0">, </span><span class="s1">exc</span><span class="s0">, </span><span class="s1">req_to_install.link) 
                    ) 
                abstract_dist = make_abstract_dist(req_to_install) 
                abstract_dist.prep_for_dist() 
                </span><span class="s0">if </span><span class="s1">self.is_download: 
                    </span><span class="s5"># Make a .zip of the source_dir we already created.</span><span class="s1"> 
                    </span><span class="s0">if </span><span class="s1">req_to_install.link.scheme </span><span class="s0">in </span><span class="s1">vcs.all_schemes: 
                        req_to_install.archive(self.download_dir) 
                </span><span class="s5"># req_to_install.req is only avail after unpack for URL</span><span class="s1"> 
                </span><span class="s5"># pkgs repeat check_if_exists to uninstall-on-upgrade</span><span class="s1"> 
                </span><span class="s5"># (#14)</span><span class="s1"> 
                </span><span class="s0">if not </span><span class="s1">self.ignore_installed: 
                    req_to_install.check_if_exists() 
                </span><span class="s0">if </span><span class="s1">req_to_install.satisfied_by: 
                    </span><span class="s0">if </span><span class="s1">self.upgrade </span><span class="s0">or </span><span class="s1">self.ignore_installed: 
                        </span><span class="s5"># don't uninstall conflict if user install and</span><span class="s1"> 
                        </span><span class="s5"># conflict is not user install</span><span class="s1"> 
                        </span><span class="s0">if not </span><span class="s1">(self.use_user_site </span><span class="s0">and not</span><span class="s1"> 
                                dist_in_usersite( 
                                    req_to_install.satisfied_by)): 
                            req_to_install.conflicts_with = \ 
                                req_to_install.satisfied_by 
                        req_to_install.satisfied_by = </span><span class="s0">None</span><span class="s1"> 
                    </span><span class="s0">else</span><span class="s1">: 
                        logger.info( 
                            </span><span class="s2">'Requirement already satisfied (use '</span><span class="s1"> 
                            </span><span class="s2">'--upgrade to upgrade): %s'</span><span class="s0">,</span><span class="s1"> 
                            req_to_install</span><span class="s0">,</span><span class="s1"> 
                        ) 
 
            </span><span class="s5"># ###################### #</span><span class="s1"> 
            </span><span class="s5"># # parse dependencies # #</span><span class="s1"> 
            </span><span class="s5"># ###################### #</span><span class="s1"> 
            dist = abstract_dist.dist(finder) 
            </span><span class="s0">try</span><span class="s1">: 
                check_dist_requires_python(dist) 
            </span><span class="s0">except </span><span class="s1">UnsupportedPythonVersion </span><span class="s0">as </span><span class="s1">e: 
                </span><span class="s0">if </span><span class="s1">self.ignore_requires_python: 
                    logger.warning(e.args[</span><span class="s4">0</span><span class="s1">]) 
                </span><span class="s0">else</span><span class="s1">: 
                    req_to_install.remove_temporary_source() 
                    </span><span class="s0">raise</span><span class="s1"> 
            more_reqs = [] 
 
            </span><span class="s0">def </span><span class="s1">add_req(subreq</span><span class="s0">, </span><span class="s1">extras_requested): 
                sub_install_req = InstallRequirement( 
                    str(subreq)</span><span class="s0">,</span><span class="s1"> 
                    req_to_install</span><span class="s0">,</span><span class="s1"> 
                    isolated=self.isolated</span><span class="s0">,</span><span class="s1"> 
                    wheel_cache=self._wheel_cache</span><span class="s0">,</span><span class="s1"> 
                ) 
                more_reqs.extend(self.add_requirement( 
                    sub_install_req</span><span class="s0">, </span><span class="s1">req_to_install.name</span><span class="s0">,</span><span class="s1"> 
                    extras_requested=extras_requested)) 
 
            </span><span class="s5"># We add req_to_install before its dependencies, so that we</span><span class="s1"> 
            </span><span class="s5"># can refer to it when adding dependencies.</span><span class="s1"> 
            </span><span class="s0">if not </span><span class="s1">self.has_requirement(req_to_install.name): 
                </span><span class="s5"># 'unnamed' requirements will get added here</span><span class="s1"> 
                self.add_requirement(req_to_install</span><span class="s0">, None</span><span class="s1">) 
 
            </span><span class="s0">if not </span><span class="s1">ignore_dependencies: 
                </span><span class="s0">if </span><span class="s1">(req_to_install.extras): 
                    logger.debug( 
                        </span><span class="s2">&quot;Installing extra requirements: %r&quot;</span><span class="s0">,</span><span class="s1"> 
                        </span><span class="s2">','</span><span class="s1">.join(req_to_install.extras)</span><span class="s0">,</span><span class="s1"> 
                    ) 
                missing_requested = sorted( 
                    set(req_to_install.extras) - set(dist.extras) 
                ) 
                </span><span class="s0">for </span><span class="s1">missing </span><span class="s0">in </span><span class="s1">missing_requested: 
                    logger.warning( 
                        </span><span class="s2">'%s does not provide the extra </span><span class="s0">\'</span><span class="s2">%s</span><span class="s0">\'</span><span class="s2">'</span><span class="s0">,</span><span class="s1"> 
                        dist</span><span class="s0">, </span><span class="s1">missing 
                    ) 
 
                available_requested = sorted( 
                    set(dist.extras) &amp; set(req_to_install.extras) 
                ) 
                </span><span class="s0">for </span><span class="s1">subreq </span><span class="s0">in </span><span class="s1">dist.requires(available_requested): 
                    add_req(subreq</span><span class="s0">, </span><span class="s1">extras_requested=available_requested) 
 
            </span><span class="s5"># cleanup tmp src</span><span class="s1"> 
            self.reqs_to_cleanup.append(req_to_install) 
 
            </span><span class="s0">if not </span><span class="s1">req_to_install.editable </span><span class="s0">and not </span><span class="s1">req_to_install.satisfied_by: 
                </span><span class="s5"># XXX: --no-install leads this to report 'Successfully</span><span class="s1"> 
                </span><span class="s5"># downloaded' for only non-editable reqs, even though we took</span><span class="s1"> 
                </span><span class="s5"># action on them.</span><span class="s1"> 
                self.successfully_downloaded.append(req_to_install) 
 
        </span><span class="s0">return </span><span class="s1">more_reqs 
 
    </span><span class="s0">def </span><span class="s1">cleanup_files(self): 
        </span><span class="s3">&quot;&quot;&quot;Clean up files, remove builds.&quot;&quot;&quot;</span><span class="s1"> 
        logger.debug(</span><span class="s2">'Cleaning up...'</span><span class="s1">) 
        </span><span class="s0">with </span><span class="s1">indent_log(): 
            </span><span class="s0">for </span><span class="s1">req </span><span class="s0">in </span><span class="s1">self.reqs_to_cleanup: 
                req.remove_temporary_source() 
 
    </span><span class="s0">def </span><span class="s1">_to_install(self): 
        </span><span class="s3">&quot;&quot;&quot;Create the installation order. 
 
        The installation order is topological - requirements are installed 
        before the requiring thing. We break cycles at an arbitrary point, 
        and make no other guarantees. 
        &quot;&quot;&quot;</span><span class="s1"> 
        </span><span class="s5"># The current implementation, which we may change at any point</span><span class="s1"> 
        </span><span class="s5"># installs the user specified things in the order given, except when</span><span class="s1"> 
        </span><span class="s5"># dependencies must come earlier to achieve topological order.</span><span class="s1"> 
        order = [] 
        ordered_reqs = set() 
 
        </span><span class="s0">def </span><span class="s1">schedule(req): 
            </span><span class="s0">if </span><span class="s1">req.satisfied_by </span><span class="s0">or </span><span class="s1">req </span><span class="s0">in </span><span class="s1">ordered_reqs: 
                </span><span class="s0">return</span><span class="s1"> 
            </span><span class="s0">if </span><span class="s1">req.constraint: 
                </span><span class="s0">return</span><span class="s1"> 
            ordered_reqs.add(req) 
            </span><span class="s0">for </span><span class="s1">dep </span><span class="s0">in </span><span class="s1">self._dependencies[req]: 
                schedule(dep) 
            order.append(req) 
        </span><span class="s0">for </span><span class="s1">install_req </span><span class="s0">in </span><span class="s1">self.requirements.values(): 
            schedule(install_req) 
        </span><span class="s0">return </span><span class="s1">order 
 
    </span><span class="s0">def </span><span class="s1">install(self</span><span class="s0">, </span><span class="s1">install_options</span><span class="s0">, </span><span class="s1">global_options=()</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs): 
        </span><span class="s3">&quot;&quot;&quot; 
        Install everything in this set (after having downloaded and unpacked 
        the packages) 
        &quot;&quot;&quot;</span><span class="s1"> 
        to_install = self._to_install() 
 
        </span><span class="s0">if </span><span class="s1">to_install: 
            logger.info( 
                </span><span class="s2">'Installing collected packages: %s'</span><span class="s0">,</span><span class="s1"> 
                </span><span class="s2">', '</span><span class="s1">.join([req.name </span><span class="s0">for </span><span class="s1">req </span><span class="s0">in </span><span class="s1">to_install])</span><span class="s0">,</span><span class="s1"> 
            ) 
 
        </span><span class="s0">with </span><span class="s1">indent_log(): 
            </span><span class="s0">for </span><span class="s1">requirement </span><span class="s0">in </span><span class="s1">to_install: 
                </span><span class="s0">if </span><span class="s1">requirement.conflicts_with: 
                    logger.info( 
                        </span><span class="s2">'Found existing installation: %s'</span><span class="s0">,</span><span class="s1"> 
                        requirement.conflicts_with</span><span class="s0">,</span><span class="s1"> 
                    ) 
                    </span><span class="s0">with </span><span class="s1">indent_log(): 
                        requirement.uninstall(auto_confirm=</span><span class="s0">True</span><span class="s1">) 
                </span><span class="s0">try</span><span class="s1">: 
                    requirement.install( 
                        install_options</span><span class="s0">,</span><span class="s1"> 
                        global_options</span><span class="s0">,</span><span class="s1"> 
                        *args</span><span class="s0">,</span><span class="s1"> 
                        **kwargs 
                    ) 
                </span><span class="s0">except</span><span class="s1">: 
                    </span><span class="s5"># if install did not succeed, rollback previous uninstall</span><span class="s1"> 
                    </span><span class="s0">if </span><span class="s1">(requirement.conflicts_with </span><span class="s0">and not</span><span class="s1"> 
                            requirement.install_succeeded): 
                        requirement.rollback_uninstall() 
                    </span><span class="s0">raise</span><span class="s1"> 
                </span><span class="s0">else</span><span class="s1">: 
                    </span><span class="s0">if </span><span class="s1">(requirement.conflicts_with </span><span class="s0">and</span><span class="s1"> 
                            requirement.install_succeeded): 
                        requirement.commit_uninstall() 
                requirement.remove_temporary_source() 
 
        self.successfully_installed = to_install 
</span></pre>
</body>
</html>